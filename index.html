<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="utf-8" name="format-detection" content="telephone=no">
  <title>F1DESK CONFIGURATOR - Updated</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.0.7/js/swiper.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.0.7/css/swiper.min.css" media="only screen and (max-width:1024px)">
  <script>
    $(document).ready(function(){
      $(".mal_buttons>div").click(function(){
        // ㄱ자 하부 서랍 메뉴는 별도 처리
        if ($(this).closest("#giyeok-drawer-color-left, #giyeok-drawer-color-right").length > 0) {
          // 색상 선택 메뉴는 별도 함수에서 처리하므로 여기서는 처리하지 않음
          return;
        }
        if ($(this).closest("#giyeok-drawer-type-left, #giyeok-drawer-type-right").length > 0) {
          // 타입 선택 메뉴는 별도 함수에서 처리하므로 여기서는 처리하지 않음
          return;
        }
        $(".mal_buttons>div").removeClass("sel");
        $(this).addClass("sel");
        $(".menu_all_list").fadeOut();

        var seltext = $(this).html();
        $(this).parents("div.swiper-slide").find(".menu_sel_text").html(seltext);
      });

      $(".swiper-button-prev, .swiper-button-next").click(function(){
        $(".menu_all_list").fadeOut();
      });

      var windowWidth = $( window ).width();
      var swiper; // Swiper 인스턴스를 전역 변수로 선언
      if(windowWidth < 1024) {
       swiper = new Swiper('.sidebar .swiper-container', {
          slidesPerView: 4,
          spaceBetween: 0,
          slidesPerGroup: 4,
          freeMode: true,
          navigation: {
            nextEl: '.sidebar .swiper-button-next',
            prevEl: '.sidebar .swiper-button-prev',
          },
        });

        var btnWidth = parseInt($(".swiper-slide").css("width"));
        $(".sidebar, .swiper-slide").css({"height":btnWidth});
        var sideWidth = windowWidth-80;
        $(".line2").css({"margin-top":"2%"});

        $(".menu_box").click(function(){
          var mboxIdx = $(".swiper-slide .menu_box").index(this);
          $(".m_sidebar>.menu_all_list").fadeOut();
          $(".m_sidebar>.menu_all_list:eq(" + mboxIdx + ")").fadeIn();
        });

        $(".mal_buttons>div").click(function(){
          var seltextIdx = $(this).parents(".menu_all_list").index();
          var seltext = $(this).html();
          $(".sidebar .swiper-slide:eq("+ seltextIdx +") .menu_sel_text").html(seltext);
        });

      } else {
       swiper = new Swiper('.sidebar .swiper-container', {
          direction: 'vertical',
          slidesPerView: 5,
          spaceBetween: 0,
          slidesPerGroup: 5,
          freeMode: true,
          mousewheel: {
            enabled: true,
            sensitivity: 1,
            releaseOnEdges: false,
          },
          navigation: {
            nextEl: '.sidebar .swiper-button-next',
            prevEl: '.sidebar .swiper-button-prev',
          }
        });
        

        $(".sidebar .menu_box").click(function(){
          $(".sidebar .menu_box").removeClass("sel");
          $(this).addClass("sel");
          $(".sidebar .menu_all_list").fadeOut();
          var menuList = $(this).siblings(".menu_all_list");
          menuList.css("display", "block"); // width 계산을 위해 임시로 표시
          var menuWidth = menuList.outerWidth() || menuList[0].scrollWidth || 0;
          menuList.css("display", ""); // 원래대로 복원
          var aaWidth = Math.max(menuWidth + 130, 130);
          menuList.fadeIn();
          $(".sidebar").animate({"width":aaWidth});
        });

        $(".sidebar .swiper-button-prev, .sidebar .swiper-button-next").click(function(){
          $(".sidebar").animate({"width":"130px"});
        });
      }
      
      // Swiper 인스턴스를 전역으로 저장하여 나중에 업데이트할 수 있도록 함
      window.swiperInstance = swiper;
  });
  </script>
  <style>
    @import url(http://fonts.googleapis.com/earlyaccess/notosanskr.css);
    @import url('https://fonts.googleapis.com/css?family=Montserrat');
    @import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.min.css');

    container { width: 100%; overflow: hidden; font-family: 'Montserrat', sans-serif; }
    #canvas { position: absolute; border: 0px; left: 0px; right: 0px; top: 99px; bottom: 0px; overflow: hidden; z-index: -1; display: block; }
    * { list-style: none; border-style: none; border-width: 0; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; font-family: Montserrat, 'Noto Sans KR', Helvetica, Arial, sans-serif; margin: 0; outline: none; overflow: visible; padding: 0; }

    .header { position: fixed; z-index: 1; width: 100%; height: 99px; padding: 0 50px; background-color: #fff; border-bottom: 1px solid #eaeaea; }
    .h_title { float: left; padding-top: 21px; }
    .h_logo { float: right; padding-top: 22px; }

    .sidebar { overflow: visible; position: fixed; left: 50px; top: 99px; width: 130px; height: 730px; padding-top: 40px; }
    .sidebar .swiper-container { height:650px; }
    .sidebar .swiper-slide { position: relative; }
    .sidebar .swiper-button-next, .sidebar .swiper-button-prev { display: block; position: absolute; left: 0; height: 40px; width: 130px; line-height: 40px; background-color: #888; text-align: center; color: #fff; font-size: 20px; }
    .sidebar .swiper-button-next:hover, .sidebar .swiper-button-prev:hover { background-color: #555; }
    .sidebar .swiper-button-next { top: 690px; }
    .sidebar .swiper-button-prev { top: 0; }
    
    .m_sidebar { display: none; }
    .menu_box { position: relative; width: 130px; height: 130px; padding: 15px; background: #fff url("img/btn_menubg.gif") no-repeat 18px 50%;  text-align: center; border-top: 1px dashed #b1b1b1; }
    .menu_box.sel { background-image: url("img/btn_menubg_sel.png");}
      .menu_title { height: 30px; padding-top: 2px; color: #fff; font-size: 17px; }
      .menu_sel_text { position: relative; width: 77px; height: 64px; margin: 0 auto; line-height: 72px; font-size: 19px; }
        .menu_sel_text>img { position: absolute; left: 0; top: 13px; width: 77px; height: 44px; }
        .menu_sel_text>span { display: block; position: absolute; left: 0; top: 13px; width: 77px; height: 44px; line-height: 46px; }
    
    .menu_all_list { display: none; position: absolute; left: 122px; top: 18px; min-height: 94px; background-color: #fff; border: 1px solid #eaeaea; overflow: visible; white-space: nowrap; width: auto; max-width: none; }
      .mal_buttons { overflow: visible; white-space: nowrap; display: block; }
      .menu_all_list .mal_buttons + .mal_buttons { margin-top: 10px; }
      .mal_buttons>div { overflow: hidden; position: relative; width: 50px; height: 92px; background-color: #fff; text-align: center; line-height: 98px; font-size: 18px; cursor: pointer; color: #888; font-weight: 500; display: inline-block; vertical-align: top; }
        .mal_buttons>div>img { width: 50px; height: 92px; }
        .mal_buttons>div>span { position: absolute; left: 0; top: 0; display: block; width: 100%; height: 100%; text-align: center; color: #aaa; font-size: 12px; }
      .mal_buttons>div.sel,
      .mal_buttons>div:hover { border: 4px solid #ed9c00; line-height: 90px; color: #aaa; }
      .mal_buttons>div.sel>img,
      .mal_buttons>div:hover>img { width: 46px; height: 84px; }
      .mal_buttons>div:hover>span { color: #888; }

    .footer { position: fixed; left: 0; bottom: 0; width: 100%; max-height: 50vh; padding:20px 0; background-color: rgba(0, 0, 0, 0.85); display: flex; flex-direction: column; z-index: 100;}
        .ft_inner { display: flex; flex-wrap: wrap; padding: 0 20px; }
        .ft_inner>div { float: left; padding: 20px 40px 0; border-left: 1px solid rgba(255, 255, 255, 0.1);}
        
        /* 옵션 명세 리스트 영역 */
        .option_spec_container { width: 100%; margin-top: 20px; padding: 0 20px 20px; border-top: 1px solid rgba(255, 255, 255, 0.2); }
        .option_spec_header { display: flex; justify-content: space-between; align-items: center; padding: 15px 0; border-bottom: 1px solid rgba(255, 255, 255, 0.1); cursor: pointer; }
        .option_spec_header:hover { background-color: rgba(255, 255, 255, 0.05); }
        .option_spec_title { color: #fff; font-size: 18px; font-weight: bold; font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, sans-serif; }
        .option_spec_toggle { color: #9f9f9f; font-size: 14px; font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, sans-serif; }
        .option_spec_list { max-height: 300px; overflow-y: auto; overflow-x: hidden; display: block; }
        .option_spec_list.hidden { display: none; }
        .option_spec_list::-webkit-scrollbar { width: 8px; }
        .option_spec_list::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.1); }
        .option_spec_list::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.3); border-radius: 4px; }
        .option_spec_list::-webkit-scrollbar-thumb:hover { background: rgba(255, 255, 255, 0.5); }
        .option_spec_item { display: flex; justify-content: space-between; align-items: center; padding: 12px 15px; border-bottom: 1px solid rgba(255, 255, 255, 0.05); }
        .option_spec_item:hover { background-color: rgba(255, 255, 255, 0.03); }
        .option_spec_name { flex: 1; color: #fff; font-size: 14px; font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, sans-serif; }
        .option_spec_qty { width: 60px; text-align: center; color: #9f9f9f; font-size: 14px; font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, sans-serif; }
        .option_spec_unit { width: 120px; text-align: right; color: #fff; font-size: 14px; font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, sans-serif; }
        .option_spec_total { width: 140px; text-align: right; color: #fff; font-size: 14px; font-weight: bold; font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, sans-serif; }
        .option_spec_item.header { background-color: rgba(255, 255, 255, 0.1); font-weight: bold; border-bottom: 2px solid rgba(255, 255, 255, 0.2); }
        .option_spec_item.header .option_spec_name,
        .option_spec_item.header .option_spec_qty,
        .option_spec_item.header .option_spec_unit,
        .option_spec_item.header .option_spec_total { color: #ed9c00; }

          .ft_title { font-weight: normal; color: #9f9f9f; font-size: 16px; font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, sans-serif; }
          .ft_prd_code { color: #fff; font-size: 18px; letter-spacing: -0.5px; font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, sans-serif; font-weight: 300; }

          .delivery_box { float: left; }
          .delivery_box:first-child { margin-right: 20px; }
            .delivery_info { position: relative; width: 175px; height: 35px; line-height: 35px; background-color: #000; overflow: hidden; color: #fff; text-indent: 10px; font-size: 18px; margin-top: 5px; font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, sans-serif; }
            .delivery_info.price { text-align: right; padding-right: 10px; }
              .delivery_area_list { height: 35px; }
                .delivery_area_list>li { line-height: 35px; list-style: none; font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, sans-serif; }
              .delivery_list_more { position: absolute; right: 10px; top: 0; font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, sans-serif; }
              .delivery_info.price>span { font-size: 14px; font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, sans-serif; }

            .ft_total_title { display: block; float: left; line-height: 110px; font-size: 24px; color: #fff; font-weight: normal; font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, sans-serif; }
            .ft_total_price { display: block; float: right; line-height: 110px; font-size: 25px; color: #fff; font-weight: bold; font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, sans-serif; }
              .ft_total_price>span { padding-left: 5px; font-size: 20px; font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, sans-serif; }
  
    @media (max-width:1024px) {
      .sidebar,
      .m_sidebar {display: block; overflow: hidden; position: fixed; left: 50%; top: 100px; width: 840px; height: 130px; padding: 0; margin-left: -420px; box-sizing: border-box; background-color: #fff; }
      .sidebar .swiper-container { position: static; width: 720px;; height: 100%; }
      .sidebar .swiper-wrapper { position: static; height: 100%; }
      .swiper-slide { position: static !important; }
      .swiper-slide:first-child { border-left: 0; }

      .sidebar .swiper-button-next, .sidebar .swiper-button-prev { display: block; position: absolute; top: 0; width: 60px; height: 180px; line-height: 180px; background-color: #888; text-align: center; color: #fff; background-image: none; margin-top: 0; }
      .sidebar .swiper-button-next:hover, .sidebar .swiper-button-prev:hover { background-color: #555; }
      .sidebar .swiper-button-next { left: 780px !important; }
      .sidebar .swiper-button-prev { left: 0; }

      .menu_box { width: 180px; height: 180px; border-top: 0; background-image: url("img/btn_menubg_m.gif"); background-size: 144px auto; background-position: center;  padding: 12px 17px;}
      .menu_box.sel { background-image: url("img/btn_menubg_sel_m.png");}

      .menu_all_list { display: none; position: absolute; z-index: 100; left: 50%; top: 130px; width: 100%;}
      .menu_sel_text { width: 120px; height: 68px; line-height: 68px; font-size: 24px; text-align: center; margin: 14px 0 0 14px; }
      .menu_sel_text>img { width: 100%; height: 100%; position: static; }
      .menu_sel_text>span { line-height: 3.2; width: 100%; height: 100%; top: 0;}
      .menu_title { height: 62px; line-height: 54px; font-size: 22px;}

      .m_sidebar { top: 270px; height: 130px; z-index: 10; background: none; }
      .m_sidebar .menu_all_list { display: none; top: 0; }
    
      
      .footer { max-height: 60vh; }
      .ft_inner>div { height: auto; min-height: 140px; }
      .delivery_box { margin-bottom: 10px; }
      .ft_total_price { position: relative; top: -50px; }
      .option_spec_container { padding: 10px; }
      .option_spec_list { max-height: 200px; }
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <div class="h_title"><img id="configurator_img" src="img/configurator.jpg"></div>
      <div class="h_logo"><img id="logo_img" src="img/logo.png"></div>
    </div>
    <div class="sidebar">
      <div class="swiper-container">
        <div class="swiper-wrapper">
          <div class="swiper-slide">
            <div class="menu_box" style=" border-top: 0;">
              <p class="menu_sel_text">기본형</p>
              <div class="menu_title">스타일</div>
            </div>
            <div class="menu_all_list" style="width: 100px;">
              <div class="mal_buttons">
                <div onclick="setMium(0)">기본형</div>
                <div onclick="setMium(1)">ㅁ다리</div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">1200</p>
              <div class="menu_title">폭(W)</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setWidth(1200)">1200</div>
                <div onclick="setWidth(1400)">1400</div>
                <div onclick="setWidth(1600)">1600</div>
                <div onclick="setWidth(1800)">1800</div>
                <div onclick="setWidth(2060)">2060</div>
                <div onclick="setWidth(2360)">2360</div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">500</p>
              <div class="menu_title">깊이(D)</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setDepth(500)">500</div>
                <div onclick="setDepth(600)">600</div>
                <div onclick="setDepth(700)">700</div>
                <div onclick="setDepth(800)">800</div>
                <div onclick="setDepth(1000)">1000</div>
                <div onclick="setDepth(1200)">1200</div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title">수직부재</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setVertical(0)">없음</div>
                <div onclick="setVertical(1)">646</div>
                <div onclick="setVertical(2)">925</div>
                <div onclick="setVertical(3)">1400</div>
                <div onclick="setVertical(4)">1860</div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">위</p>
              <div class="menu_title">수직부재<br>위치조정</div>
            </div>
            <div class="menu_all_list" style="width: 100px;">
              <div class="mal_buttons">
                <div onclick="moveVerticalUp()">위</div>
                <div onclick="moveVerticalDown()">아래</div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">1</p>
              <div class="menu_title">선반갯수</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setShelfNum(1)">1</div>
                <div onclick="setShelfNum(2)">2</div>
                <div onclick="setShelfNum(3)">3</div>
                <div onclick="setShelfNum(4)">4</div>
                <div onclick="setShelfNum(5)">5</div>
                <div onclick="setShelfNum(6)">6</div>
                <div onclick="setShelfNum(7)">7</div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">바깥쪽</p>
              <div class="menu_title">선반방향</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setShelfDirection(0)">바깥쪽</div>
                <div onclick="setShelfDirection(1)">안쪽</div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">화이트</p>
              <div class="menu_title">상판색상</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setBoardColor(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setBoardColor(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
                <div onclick="setBoardColor(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setBoardColor(8)"><img src="texture/maple.jpg"><span>밝은우드</span></div>
                <div onclick="setBoardColor(9)"><img src="texture/natural.jpg"><span>중간우드</span></div>
                <div onclick="setBoardColor(10)"><img src="texture/walnut.jpg"><span>월넛우드</span></div>
                <div onclick="setBoardColor(4)"><img src="texture/natural.jpg"><span>내추럴</span></div>
                <div onclick="setBoardColor(5)"><img src="texture/pine.jpg"><span>파인</span></div>
                <div onclick="setBoardColor(6)"><img src="texture/concrete.jpg"><span>콘크리트</span></div>
                <div onclick="setBoardColor(7)"><img src="texture/redpine.jpg"><span>레드파인</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">화이트</p>
              <div class="menu_title" >프레임색상</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setFrameColor(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setFrameColor(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setFrameColor(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">화이트</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">수직프레임<br>색상</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setVerticalColor(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setVerticalColor(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setVerticalColor(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">화이트</p>
              <div class="menu_title">선반색상</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setShelfBoardColor(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setShelfBoardColor(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
                <div onclick="setShelfBoardColor(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setShelfBoardColor(8)"><img src="texture/maple.jpg"><span>밝은우드</span></div>
                <div onclick="setShelfBoardColor(9)"><img src="texture/natural.jpg"><span>중간우드</span></div>
                <div onclick="setShelfBoardColor(10)"><img src="texture/walnut.jpg"><span>월넛우드</span></div>
                <div onclick="setShelfBoardColor(4)"><img src="texture/natural.jpg"><span>내추럴</span></div>
                <div onclick="setShelfBoardColor(5)"><img src="texture/pine.jpg"><span>파인</span></div>
                <div onclick="setShelfBoardColor(6)"><img src="texture/concrete.jpg"><span>콘크리트</span></div>
                <div onclick="setShelfBoardColor(7)"><img src="texture/redpine.jpg"><span>레드파인</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">화이트</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">선반프레임<br>색상</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setShelfFrameColor(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setShelfFrameColor(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setShelfFrameColor(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title">ㄱ자 모듈</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setGiyeok(0)">없음</div>
                <div onclick="setGiyeok(1)">왼쪽</div>
                <div onclick="setGiyeok(2)">오른쪽</div>
                <div onclick="setGiyeok(3)">중앙</div>
                <div onclick="setGiyeok(4)">양쪽</div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">ㄱ자하부<br>서랍(좌)</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons" id="giyeok-drawer-type-left">
                <div onclick="setGiyeokDrawerTypeLeft(0)">없음</div>
                <div onclick="setGiyeokDrawerTypeLeft(1)">부착서랍1단</div>
                <div onclick="setGiyeokDrawerTypeLeft(2)">부착서랍2단</div>
                <div onclick="setGiyeokDrawerTypeLeft(3)">본체함</div>
                <div onclick="setGiyeokDrawerTypeLeft(4)">이동서랍2단</div>
                <div onclick="setGiyeokDrawerTypeLeft(5)">이동서랍3단</div>
              </div>
              <div class="mal_buttons" id="giyeok-drawer-color-left" style="display: none;">
                <div onclick="setGiyeokDrawerColorLeft(0)">없음</div>
                <div onclick="setGiyeokDrawerColorLeft(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setGiyeokDrawerColorLeft(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
                <div onclick="setGiyeokDrawerColorLeft(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setGiyeokDrawerColorLeft(8)"><img src="texture/maple.jpg"><span>밝은우드</span></div>
                <div onclick="setGiyeokDrawerColorLeft(9)"><img src="texture/natural.jpg"><span>중간우드</span></div>
                <div onclick="setGiyeokDrawerColorLeft(10)"><img src="texture/walnut.jpg"><span>월넛우드</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">ㄱ자하부<br>서랍(우)</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons" id="giyeok-drawer-type-right">
                <div onclick="setGiyeokDrawerTypeRight(0)">없음</div>
                <div onclick="setGiyeokDrawerTypeRight(1)">부착서랍1단</div>
                <div onclick="setGiyeokDrawerTypeRight(2)">부착서랍2단</div>
                <div onclick="setGiyeokDrawerTypeRight(3)">본체함</div>
                <div onclick="setGiyeokDrawerTypeRight(4)">이동서랍2단</div>
                <div onclick="setGiyeokDrawerTypeRight(5)">이동서랍3단</div>
              </div>
              <div class="mal_buttons" id="giyeok-drawer-color-right" style="display: none;">
                <div onclick="setGiyeokDrawerColorRight(0)">없음</div>
                <div onclick="setGiyeokDrawerColorRight(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setGiyeokDrawerColorRight(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
                <div onclick="setGiyeokDrawerColorRight(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setGiyeokDrawerColorRight(8)"><img src="texture/maple.jpg"><span>밝은우드</span></div>
                <div onclick="setGiyeokDrawerColorRight(9)"><img src="texture/natural.jpg"><span>중간우드</span></div>
                <div onclick="setGiyeokDrawerColorRight(10)"><img src="texture/walnut.jpg"><span>월넛우드</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title">데스크매트</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setDeskMat(0)">없음</div>
                <div onclick="setDeskMat(1)"><img src="texture/gray.jpg"><span>그레이</span></div>
                <div onclick="setDeskMat(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setDeskMat(3)"><span>라이트그레이</span></div>
                <div onclick="setDeskMat(4)"><span>베이지</span></div>
                <div onclick="setDeskMat(5)"><span>브라운</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title">미니서랍</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setDrawerColor(0)">없음</div>
                <div onclick="setDrawerColor(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setDrawerColor(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setDrawerColor(3)"><span>오렌지</span></div>
                <div onclick="setDrawerColor(4)"><span>오렌지투명</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title">하부가림판</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setFence(0)">없음</div>
                <div onclick="setFence(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setFence(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
                <div onclick="setFence(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setFence(8)"><img src="texture/maple.jpg"><span>밝은우드</span></div>
                <div onclick="setFence(9)"><img src="texture/natural.jpg"><span>중간우드</span></div>
                <div onclick="setFence(10)"><img src="texture/walnut.jpg"><span>월넛우드</span></div>
                <div onclick="setFence(4)"><img src="texture/natural.jpg"><span>내추럴</span></div>
                <div onclick="setFence(5)"><img src="texture/pine.jpg"><span>파인</span></div>
                <div onclick="setFence(6)"><img src="texture/concrete.jpg"><span>콘크리트</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">이동서랍<br>2단</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setMoving2(0)">없음</div>
                <div onclick="setMoving2(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setMoving2(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
                <div onclick="setMoving2(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setMoving2(8)"><img src="texture/maple.jpg"><span>밝은우드</span></div>
                <div onclick="setMoving2(9)"><img src="texture/natural.jpg"><span>중간우드</span></div>
                <div onclick="setMoving2(10)"><img src="texture/walnut.jpg"><span>월넛우드</span></div>
                <div onclick="setMoving2(14)"><span>오렌지</span></div>
                <div onclick="setMoving2(16)"><span>레몬</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">이동서랍<br>3단</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setMoving3(0)">없음</div>
                <div onclick="setMoving3(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setMoving3(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
                <div onclick="setMoving3(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setMoving3(8)"><img src="texture/maple.jpg"><span>밝은우드</span></div>
                <div onclick="setMoving3(9)"><img src="texture/natural.jpg"><span>중간우드</span></div>
                <div onclick="setMoving3(10)"><img src="texture/walnut.jpg"><span>월넛우드</span></div>
                <div onclick="setMoving3(14)"><span>오렌지</span></div>
                <div onclick="setMoving3(16)"><span>레몬</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">200</p>
              <div class="menu_title">선반깊이</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setShelfDepth(200)">200</div>
                <div onclick="setShelfDepth(360)">360</div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">부착형서랍<br>1단</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setAttach1Left(0)">없음</div>
                <div onclick="setAttach1Left(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setAttach1Left(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
                <div onclick="setAttach1Left(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setAttach1Left(8)"><img src="texture/maple.jpg"><span>밝은우드</span></div>
                <div onclick="setAttach1Left(9)"><img src="texture/natural.jpg"><span>중간우드</span></div>
                <div onclick="setAttach1Left(10)"><img src="texture/walnut.jpg"><span>월넛우드</span></div>
                <div onclick="setAttach1Left(14)"><span>오렌지</span></div>
                <div onclick="setAttach1Left(16)"><span>레몬</span></div>
                <div onclick="setAttach1Right(0)">없음</div>
                <div onclick="setAttach1Right(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setAttach1Right(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
                <div onclick="setAttach1Right(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setAttach1Right(8)"><img src="texture/maple.jpg"><span>밝은우드</span></div>
                <div onclick="setAttach1Right(9)"><img src="texture/natural.jpg"><span>중간우드</span></div>
                <div onclick="setAttach1Right(10)"><img src="texture/walnut.jpg"><span>월넛우드</span></div>
                <div onclick="setAttach1Right(14)"><span>오렌지</span></div>
                <div onclick="setAttach1Right(16)"><span>레몬</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">부착형서랍<br>2단</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setAttach2Left(0)">없음</div>
                <div onclick="setAttach2Left(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setAttach2Left(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
                <div onclick="setAttach2Left(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setAttach2Left(8)"><img src="texture/maple.jpg"><span>밝은우드</span></div>
                <div onclick="setAttach2Left(9)"><img src="texture/natural.jpg"><span>중간우드</span></div>
                <div onclick="setAttach2Left(10)"><img src="texture/walnut.jpg"><span>월넛우드</span></div>
                <div onclick="setAttach2Left(14)"><span>오렌지</span></div>
                <div onclick="setAttach2Left(16)"><span>레몬</span></div>
                <div onclick="setAttach2Right(0)">없음</div>
                <div onclick="setAttach2Right(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setAttach2Right(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
                <div onclick="setAttach2Right(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setAttach2Right(8)"><img src="texture/maple.jpg"><span>밝은우드</span></div>
                <div onclick="setAttach2Right(9)"><img src="texture/natural.jpg"><span>중간우드</span></div>
                <div onclick="setAttach2Right(10)"><img src="texture/walnut.jpg"><span>월넛우드</span></div>
                <div onclick="setAttach2Right(14)"><span>오렌지</span></div>
                <div onclick="setAttach2Right(16)"><span>레몬</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title">본체함</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setAttach3Left(0)">없음</div>
                <div onclick="setAttach3Left(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setAttach3Left(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
                <div onclick="setAttach3Left(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setAttach3Left(8)"><img src="texture/maple.jpg"><span>밝은우드</span></div>
                <div onclick="setAttach3Left(9)"><img src="texture/natural.jpg"><span>중간우드</span></div>
                <div onclick="setAttach3Left(10)"><img src="texture/walnut.jpg"><span>월넛우드</span></div>
                <div onclick="setAttach3Left(14)"><span>오렌지</span></div>
                <div onclick="setAttach3Left(16)"><span>레몬</span></div>
                <div onclick="setAttach3Right(0)">없음</div>
                <div onclick="setAttach3Right(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setAttach3Right(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
                <div onclick="setAttach3Right(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setAttach3Right(8)"><img src="texture/maple.jpg"><span>밝은우드</span></div>
                <div onclick="setAttach3Right(9)"><img src="texture/natural.jpg"><span>중간우드</span></div>
                <div onclick="setAttach3Right(10)"><img src="texture/walnut.jpg"><span>월넛우드</span></div>
                <div onclick="setAttach3Right(14)"><span>오렌지</span></div>
                <div onclick="setAttach3Right(16)"><span>레몬</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">슬라이딩도어<br>1단</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setStorageSliding1(0)">없음</div>
                <div onclick="setStorageSliding1(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setStorageSliding1(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
                <div onclick="setStorageSliding1(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setStorageSliding1(8)"><img src="texture/maple.jpg"><span>밝은우드</span></div>
                <div onclick="setStorageSliding1(9)"><img src="texture/natural.jpg"><span>중간우드</span></div>
                <div onclick="setStorageSliding1(10)"><img src="texture/walnut.jpg"><span>월넛우드</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">슬라이딩도어<br>2단</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setStorageSliding2(0)">없음</div>
                <div onclick="setStorageSliding2(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setStorageSliding2(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
                <div onclick="setStorageSliding2(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setStorageSliding2(8)"><img src="texture/maple.jpg"><span>밝은우드</span></div>
                <div onclick="setStorageSliding2(9)"><img src="texture/natural.jpg"><span>중간우드</span></div>
                <div onclick="setStorageSliding2(10)"><img src="texture/walnut.jpg"><span>월넛우드</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title">플랩도어</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setStorageFlap(0)">없음</div>
                <div onclick="setStorageFlap(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setStorageFlap(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
                <div onclick="setStorageFlap(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setStorageFlap(8)"><img src="texture/maple.jpg"><span>밝은우드</span></div>
                <div onclick="setStorageFlap(9)"><img src="texture/natural.jpg"><span>중간우드</span></div>
                <div onclick="setStorageFlap(10)"><img src="texture/walnut.jpg"><span>월넛우드</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">플랩스테이<br>도어</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setStorageFlapStay(0)">없음</div>
                <div onclick="setStorageFlapStay(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setStorageFlapStay(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
                <div onclick="setStorageFlapStay(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setStorageFlapStay(8)"><img src="texture/maple.jpg"><span>밝은우드</span></div>
                <div onclick="setStorageFlapStay(9)"><img src="texture/natural.jpg"><span>중간우드</span></div>
                <div onclick="setStorageFlapStay(10)"><img src="texture/walnut.jpg"><span>월넛우드</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">위</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">수납도어<br>위치조정</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="moveStorageUp()">위</div>
                <div onclick="moveStorageDown()">아래</div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">파티션<br>왼쪽높이</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setPartiVerLHeight(0)">없음</div>
                <div onclick="setPartiVerLHeight(480)">480</div>
                <div onclick="setPartiVerLHeight(800)">800</div>
                <div onclick="setPartiVerLHeight(1200)">1200</div>
                <div onclick="setPartiVerLHeight(1400)">1400</div>
                <div onclick="setPartiVerLHeight(1600)">1600</div>
                <div onclick="setPartiVerLHeight(1800)">1800</div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">그레이</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">파티션<br>왼쪽색상</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setPartiVerLColor(3)"><span>그레이</span></div>
                <div onclick="setPartiVerLColor(12)"><span>베이지</span></div>
                <div onclick="setPartiVerLColor(2)"><span>블랙</span></div>
                <div onclick="setPartiVerLColor(17)"><span>그린</span></div>
                <div onclick="setPartiVerLColor(14)"><span>오렌지</span></div>
                <div onclick="setPartiVerLColor(11)"><span>라이트그레이</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">파티션<br>오른쪽높이</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setPartiVerRHeight(0)">없음</div>
                <div onclick="setPartiVerRHeight(480)">480</div>
                <div onclick="setPartiVerRHeight(800)">800</div>
                <div onclick="setPartiVerRHeight(1200)">1200</div>
                <div onclick="setPartiVerRHeight(1400)">1400</div>
                <div onclick="setPartiVerRHeight(1600)">1600</div>
                <div onclick="setPartiVerRHeight(1800)">1800</div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">그레이</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">파티션<br>오른쪽색상</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setPartiVerRColor(3)"><span>그레이</span></div>
                <div onclick="setPartiVerRColor(12)"><span>베이지</span></div>
                <div onclick="setPartiVerRColor(2)"><span>블랙</span></div>
                <div onclick="setPartiVerRColor(17)"><span>그린</span></div>
                <div onclick="setPartiVerRColor(14)"><span>오렌지</span></div>
                <div onclick="setPartiVerRColor(11)"><span>라이트그레이</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">파티션<br>홀B넓이</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setPartiHolBWidth(0)">없음</div>
                <div onclick="setPartiHolBWidth(1200)">1200</div>
                <div onclick="setPartiHolBWidth(1400)">1400</div>
                <div onclick="setPartiHolBWidth(1600)">1600</div>
                <div onclick="setPartiHolBWidth(1800)">1800</div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">그레이</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">파티션<br>홀B색상</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setPartiHolBColor(3)"><span>그레이</span></div>
                <div onclick="setPartiHolBColor(12)"><span>베이지</span></div>
                <div onclick="setPartiHolBColor(2)"><span>블랙</span></div>
                <div onclick="setPartiHolBColor(17)"><span>그린</span></div>
                <div onclick="setPartiHolBColor(14)"><span>오렌지</span></div>
                <div onclick="setPartiHolBColor(11)"><span>라이트그레이</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">파티션<br>중첩위치높이</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setPartiVerMHeight(0)">없음</div>
                <div onclick="setPartiVerMHeight(460)">460</div>
                <div onclick="setPartiVerMHeight(800)">800</div>
                <div onclick="setPartiVerMHeight(1200)">1200</div>
                <div onclick="setPartiVerMHeight(1400)">1400</div>
                <div onclick="setPartiVerMHeight(1600)">1600</div>
                <div onclick="setPartiVerMHeight(1800)">1800</div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">파티션<br>중첩위치색상</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setPartiVerMColor(0)"><span>없음</span></div>
                <div onclick="setPartiVerMColor(1)"><span>화이트</span></div>
                <div onclick="setPartiVerMColor(2)"><span>블랙</span></div>
                <div onclick="setPartiVerMColor(3)"><span>그레이</span></div>
                <div onclick="setPartiVerMColor(4)"><span>다크그레이</span></div>
                <div onclick="setPartiVerMColor(5)"><span>베이지</span></div>
                <div onclick="setPartiVerMColor(6)"><span>브라운</span></div>
                <div onclick="setPartiVerMColor(7)"><span>오렌지</span></div>
                <div onclick="setPartiVerMColor(8)"><span>라이트그레이</span></div>
                <div onclick="setPartiVerMColor(10)"><span>그린</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide" id="parti-z-align-menu" style="visibility: hidden; height: 0; overflow: hidden;">
            <div class="menu_box">
              <p class="menu_sel_text">기본 위치</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">파티션<br>Z축 위치</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setPartiZAlignFront(0)">기본 위치</div>
                <div onclick="setPartiZAlignFront(1)">하부옵션 전면</div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">1</p>
              <div class="menu_title">책상 배열</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setDeskArray(1)">1</div>
                <div onclick="setDeskArray(2)">2</div>
                <div onclick="setDeskArray(3)">3</div>
                <div onclick="setDeskArray(4)">4</div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">복사 안함</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">책상<br>맞은편 배열</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setDeskOpposite(0)">복사 안함</div>
                <div onclick="setDeskOpposite(3600)">거리 3600</div>
                <div onclick="setDeskOpposite(-1030)">거리 -1030</div>
                <div onclick="setDeskOpposite(-2400)">거리 -2400</div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">유지</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">반대편<br>좌우설정</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setOppositeKeepSides(true)">유지</div>
                <div onclick="setOppositeKeepSides(false)">바꿈</div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
                <p class="menu_sel_text">Export</p>
              <div class="menu_title">3D 파일</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="exportOBJ()">OBJ</div>
                <div onclick="exportSTL()">STL</div>
              </div>
            </div>
          </div>
        </div>
        <div class="swiper-button-next">Next</div>
        <div class="swiper-button-prev">Prev</div>
      </div>
    </div>
    <div class="footer">
      <div class="ft_inner">
        <div style="width: 35.6%; border-left: 0;">
          <strong class="ft_title">상품코드</strong>
          <div style="position: relative; display: flex; align-items: center;">
            <input type="text" id="product_code_input" class="ft_prd_code" style="background: transparent; border: 1px solid rgba(255,255,255,0.3); color: #fff; font-size: 18px; letter-spacing: -0.5px; width: calc(100% - 80px); padding: 5px; box-sizing: border-box; font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, sans-serif; font-weight: 300;" value="14211-12345-00110" onchange="loadProductFromCode(this.value)" onkeypress="if(event.key==='Enter') loadProductFromCode(this.value)">
            <button id="copy_code_btn" onclick="copyProductCode()" style="background: transparent; border: none; color: #fff; cursor: pointer; padding: 5px 10px; margin-left: 5px; display: flex; align-items: center; justify-content: center; opacity: 0.7; transition: opacity 0.3s;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.7'" title="상품코드 복사">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
              </svg>
            </button>
            <button id="copy_url_btn" onclick="copyProductURL()" style="background: transparent; border: none; color: #fff; cursor: pointer; padding: 5px 10px; margin-left: 5px; display: flex; align-items: center; justify-content: center; opacity: 0.7; transition: opacity 0.3s;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.7'" title="URL 복사">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
                <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
              </svg>
            </button>
          </div>
        </div>
        <div style="width: 18.5%;">
          <div class="delivery_box">
            <strong class="ft_title">배송지역 설정</strong>
            <div class="delivery_info">
              <ul class="delivery_area_list">
                <li>서울</li>
                <li>경기</li>
              </ul>
              <span class="delivery_list_more">+</span>
            </div>
          </div>
          <div class="delivery_box">
            <strong class="ft_title">배송 가능 날짜</strong>
            <div class="delivery_info">2017년 12월 31일</div>
          </div>
        </div>
        <div style="width: 18.5%;">
          <div class="delivery_box">
            <strong class="ft_title">배송조립비</strong>
            <div class="delivery_info price">28,000 <span>원</span></div>
          </div>
          <div class="delivery_box">
            <strong class="ft_title">상품금액</strong>
            <div class="delivery_info price">283,000 <span>원</span></div>
          </div>
        </div>
        <div style="width: 27.4%; padding-top: 0;">
          <strong class="ft_total_title">총 결제금액</strong>
          <span class="ft_total_price" id="total_price_display">0<span>원</span></span>
        </div>
      </div>
      <!-- 옵션 명세 리스트 -->
      <div class="option_spec_container" id="option_spec_container">
        <div class="option_spec_header" onclick="toggleOptionSpec()">
          <span class="option_spec_title">적용된 옵션 명세</span>
          <span class="option_spec_toggle" id="option_spec_toggle">▼ 펼치기</span>
        </div>
        <div class="option_spec_list hidden" id="option_spec_list">
          <!-- 옵션 리스트가 여기에 동적으로 생성됩니다 -->
        </div>
      </div>
    </div>

    <div id="canvas">
    </div>
    
    <!-- 회전 정지/재개 버튼 -->
    <div id="rotation-control" style="position: fixed; left: 70px; bottom: 170px; z-index: 1000;">
      <button id="rotation-toggle-btn" onclick="toggleRotation()" style="
        width: 120px;
        height: 120px;
        padding: 0;
        background-color: rgba(0, 100, 0, 0.7);
        color: #fff;
        border: 2px solid #fff;
        border-radius: 50%;
        font-size: 16px;
        cursor: pointer;
        font-family: 'Montserrat', sans-serif;
        transition: all 0.3s;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        line-height: 1.3;
      ">회전시작</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/90/three.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.90.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.90.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="./OrbitControls.js"></script>
    <script src="./OBJExporter.js"></script>
    <script src="./STLExporter.js"></script>

    <script>
      // 현재 페이지의 base path 자동 감지
      // GitHub Pages 등 다양한 호스팅 환경에서 작동하도록 개선
      // 루트 배포 (username.github.io)와 서브디렉토리 배포 모두 지원
      function getBasePath() {
        var path = window.location.pathname;
        var fullUrl = window.location.href;
        var origin = window.location.origin;
        
        // GitHub Pages 루트 배포인 경우 (pathname이 '/' 또는 '/index.html')
        if (path === '/' || path === '/index.html') {
          console.log('🔍 Base Path 감지 (루트 배포):', {
            '전체 URL': fullUrl,
            'Origin': origin,
            'Pathname': path,
            '감지된 Base Path': '/',
            '예상 리소스 경로 예시': '/texture/natural.jpg',
            '배포 유형': 'GitHub Pages 루트'
          });
          return '/';
        }
        
        // index.html이 포함된 경우 그 앞까지가 base path
        var indexPos = path.lastIndexOf('index.html');
        if (indexPos >= 0) {
          var detectedPath = path.substring(0, indexPos);
          // 빈 문자열이면 루트
          if (detectedPath === '') {
            detectedPath = '/';
          }
          console.log('🔍 Base Path 감지 (index.html 포함):', {
            '전체 URL': fullUrl,
            'Origin': origin,
            'Pathname': path,
            '감지된 Base Path': detectedPath,
            '예상 리소스 경로 예시': detectedPath + 'texture/natural.jpg',
            '배포 유형': '서브디렉토리 또는 로컬'
          });
          return detectedPath;
        }
        
        // index.html이 없으면 마지막 / 앞까지
        var lastSlashPos = path.lastIndexOf('/');
        if (lastSlashPos >= 0) {
          var detectedPath = path.substring(0, lastSlashPos + 1);
          // 루트인 경우
          if (detectedPath === '/') {
            console.log('🔍 Base Path 감지 (루트):', {
              '전체 URL': fullUrl,
              'Origin': origin,
              'Pathname': path,
              '감지된 Base Path': '/',
              '예상 리소스 경로 예시': '/texture/natural.jpg',
              '배포 유형': '루트'
            });
            return '/';
          }
          console.log('🔍 Base Path 감지 (경로 분석):', {
            '전체 URL': fullUrl,
            'Origin': origin,
            'Pathname': path,
            '감지된 Base Path': detectedPath,
            '예상 리소스 경로 예시': detectedPath + 'texture/natural.jpg',
            '배포 유형': '서브디렉토리'
          });
          return detectedPath;
        }
        
        // 루트 경로인 경우 (기본값)
        console.log('🔍 Base Path 감지 (기본값):', {
          '전체 URL': fullUrl,
          'Origin': origin,
          'Pathname': path,
          '감지된 Base Path': '/',
          '예상 리소스 경로 예시': '/texture/natural.jpg',
          '배포 유형': '기본값 (루트)'
        });
        return '/';
      }
      
      var basePath = getBasePath();
      
      // 가격 데이터 전역 변수
      var priceData = null;
      var priceDataLoaded = false;
      
      // 가격 데이터 로드 함수
      function loadPriceData() {
        return fetch(getResourcePath('prices.json'))
          .then(function(response) {
            if (!response.ok) {
              throw new Error('가격 파일을 불러올 수 없습니다: ' + response.status);
            }
            return response.json();
          })
          .then(function(data) {
            priceData = data;
            priceDataLoaded = true;
            console.log('✅ 가격 데이터 로드 완료:', data.version || '버전 정보 없음');
            return data;
          })
          .catch(function(error) {
            console.error('❌ 가격 데이터 로드 실패:', error);
            console.warn('기본 가격 데이터를 사용합니다.');
            // 기본 가격 데이터 (fallback)
            priceData = {
              version: "fallback",
              prices: {
                board: {
                  table: [
                    [0, 0, 0, 0, 0, 0],
                    [109800, 129800, 141700, 159700, 193100, 0],
                    [118400, 139900, 159900, 198800, 214500, 0],
                    [151000, 169800, 189800, 217300, 241400, 0],
                    [0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0]
                  ]
                },
                delivery: { basic: 29800 },
                mium: { product: 69900, delivery: 29800 },
                shelf: {
                  product: [34000, 43000, 45000, 51000, 57000, 0],
                  delivery: [29800, 29800, 32800, 35800, 38800, 41800, 44800],
                  heightExtra: { "925": 11400, "1400": 16000, "1860": 21900 }
                },
                giyeok: { product: 94500 },
                deskMat: { product: 65000, delivery: 5000 },
                drawer: { product: 34400, delivery: 3000 },
                fence: {
                  product: [81700, 101700, 103400, 105000, 113900, 0],
                  delivery: 19800
                },
                moving2: { product: 88000, delivery: 19800 },
                moving3: { product: 121000, delivery: 19800 }
              }
            };
            priceDataLoaded = true;
            return priceData;
          });
      }
      
      // 경로 정보를 화면에 표시 (개발 모드)
      function showPathInfo() {
        var info = {
          '현재 전체 URL': window.location.href,
          'Origin': window.location.origin,
          'Pathname': window.location.pathname,
          '감지된 Base Path': basePath,
          '예상 리소스 경로': {
            '텍스처': basePath + 'texture/natural.jpg',
            '이미지': basePath + 'img/configurator.jpg',
            'GLB 모델': basePath + 'glb/attach1.glb'
          }
        };
        console.table(info);
        return info;
      }
      
      // F12 개발자 도구에서 showPathInfo() 함수를 호출하면 경로 정보 확인 가능
      window.showPathInfo = showPathInfo;
      
      // 화면에 경로 정보 표시 (개발/디버깅용)
      function showPathInfoOnScreen() {
        var infoDiv = document.getElementById('path-info-debug');
        if (!infoDiv) {
          infoDiv = document.createElement('div');
          infoDiv.id = 'path-info-debug';
          infoDiv.style.cssText = 'position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.9); color: #fff; padding: 15px; border-radius: 5px; font-family: monospace; font-size: 12px; z-index: 10000; max-width: 400px; max-height: 300px; overflow: auto;';
          document.body.appendChild(infoDiv);
        }
        
        var info = {
          '현재 URL': window.location.href,
          'Base Path': basePath,
          '예시 경로': {
            '텍스처': basePath + 'texture/natural.jpg',
            '이미지': basePath + 'img/configurator.jpg',
            'GLB': basePath + 'glb/attach1.glb'
          }
        };
        
        var html = '<div style="margin-bottom: 10px;"><strong style="color: #0f0;">📍 경로 정보</strong></div>';
        html += '<div style="margin-bottom: 5px;"><strong>현재 URL:</strong><br>' + info['현재 URL'] + '</div>';
        html += '<div style="margin-bottom: 5px;"><strong>Base Path:</strong><br><span style="color: #ff0;">' + info['Base Path'] + '</span></div>';
        html += '<div style="margin-bottom: 5px;"><strong>예시 경로:</strong><br>';
        html += '텍스처: <span style="color: #0ff;">' + info['예시 경로']['텍스처'] + '</span><br>';
        html += '이미지: <span style="color: #0ff;">' + info['예시 경로']['이미지'] + '</span><br>';
        html += 'GLB: <span style="color: #0ff;">' + info['예시 경로']['GLB'] + '</span></div>';
        html += '<div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #666; font-size: 10px; color: #999;">F12 → Console에서 showPathInfo() 실행 시 더 자세한 정보 확인</div>';
        html += '<button onclick="document.getElementById(\'path-info-debug\').style.display=\'none\'" style="margin-top: 10px; padding: 5px 10px; background: #f00; color: #fff; border: none; border-radius: 3px; cursor: pointer;">닫기</button>';
        
        infoDiv.innerHTML = html;
      }
      
      // 개발 모드: URL에 ?debug=1 파라미터가 있으면 경로 정보 표시
      var urlParams = new URLSearchParams(window.location.search);
      if (urlParams.get('debug') === '1') {
        setTimeout(function() {
          showPathInfoOnScreen();
        }, 1000);
      }
      
      // 상대 경로를 절대 경로로 변환하는 헬퍼 함수
      function getResourcePath(relativePath) {
        // 이미 절대 경로(http:// 또는 https://로 시작)인 경우 그대로 반환
        if (relativePath.indexOf('http://') === 0 || relativePath.indexOf('https://') === 0) {
          return relativePath;
        }
        
        // /로 시작하는 절대 경로인 경우 base path와 결합
        if (relativePath.indexOf('/') === 0) {
          // base path가 /가 아닌 경우 (예: /repo/) base path 제거하고 사용
          if (basePath !== '/') {
            return relativePath;
          }
          return relativePath;
        }
        
        // 상대 경로인 경우 base path 추가
        // base path가 /로 끝나지 않으면 / 추가
        var path = basePath;
        if (path !== '/' && path[path.length - 1] !== '/') {
          path += '/';
        }
        return path + relativePath;
      }

      var container;
      var camera, controls, scene, renderer;
      var geometry, geometry1, material;

      var width, height = 700;  // board width and height

      var white_color = 0xf8f9fb;
      var black_color = 0x21201e;
      var gray_color = 0x6f6f6f;
      var light_gray_color = 0xb0b0b0;
      var beige_color = 0xf5f5dc;
      var brown_color = 0x8b4513;
      var orange_color = 0xff8c00;
      var lemon_color = 0xfff700;
      var green_color = 0x228b22;

      var textureLoader = new THREE.TextureLoader();
      
      // 텍스처 설정 헬퍼 함수
      function configureTexture(texture) {
        if (!texture) return;
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        // 우드 텍스처를 더 크게 펼치기 위해 repeat 값 설정
        // repeat 값이 클수록 텍스처가 더 크게 보임 (예: 2는 2배 크게)
        texture.repeat.set(2, 2); // 가로 2배, 세로 2배로 펼침
        texture.flipY = false;
        texture.needsUpdate = true;
      }
      
      // 텍스처 로드 (콜백으로 로드 완료 후 설정)
      var texture_natural = textureLoader.load(getResourcePath('texture/natural.jpg'), function(texture) {
        configureTexture(texture);
        // 현재 선택된 색상이 이 텍스처를 사용하는 경우 업데이트
        if (board_color == 4 || board_color == 9) {
          board_material = getMaterial(board_color);
          updateScene();
          render();
        }
      }, undefined, function(error) {
        console.error('natural.jpg 로드 실패:', error);
      });
      
      var texture_pine = textureLoader.load(getResourcePath('texture/pine.jpg'), function(texture) {
        configureTexture(texture);
        if (board_color == 5) {
          board_material = getMaterial(board_color);
          updateScene();
          render();
        }
      }, undefined, function(error) {
        console.error('pine.jpg 로드 실패:', error);
      });
      
      var texture_concrete = textureLoader.load(getResourcePath('texture/concrete.jpg'), function(texture) {
        configureTexture(texture);
        if (board_color == 6) {
          board_material = getMaterial(board_color);
          updateScene();
          render();
        }
      }, undefined, function(error) {
        console.error('concrete.jpg 로드 실패:', error);
      });
      
      var texture_redpine = textureLoader.load(getResourcePath('texture/redpine.jpg'), function(texture) {
        configureTexture(texture);
        if (board_color == 7) {
          board_material = getMaterial(board_color);
          updateScene();
          render();
        }
      }, undefined, function(error) {
        console.error('redpine.jpg 로드 실패:', error);
      });
      
      var texture_maple = textureLoader.load(getResourcePath('texture/maple.jpg'), function(texture) {
        configureTexture(texture);
        if (board_color == 8) {
          board_material = getMaterial(board_color);
          updateScene();
          render();
        }
      }, undefined, function(error) {
        console.error('maple.jpg 로드 실패:', error);
      });
      
      var texture_walnut = textureLoader.load(getResourcePath('texture/walnut.jpg'), function(texture) {
        configureTexture(texture);
        if (board_color == 10) {
          board_material = getMaterial(board_color);
          updateScene();
          render();
        }
      }, undefined, function(error) {
        console.error('walnut.jpg 로드 실패:', error);
      });
      
      // 기본 필터 설정 (로드 전에도 적용)
      configureTexture(texture_natural);
      configureTexture(texture_pine);
      configureTexture(texture_concrete);
      configureTexture(texture_redpine);
      configureTexture(texture_maple);
      configureTexture(texture_walnut);

      var plane;
      var plane_size = 10000;
      var plane_material = new THREE.MeshPhongMaterial( {
          color: 0xEEEEEE,
          side: THREE.BackSide
        } );

      // ===== 1그룹: 구조/크기 =====
      // [1] 책상옵션 - 스타일
      var is_mium = 0;
      var mium_leg;

      // [32] 배열/수납 - 책상 배열 수
      var num_desk = 1;
      // [33] 배열/수납 - 맞은편 배열
      // 0: 복사 안함, 3600: z축 거리 3600, -1030: z축 거리 -1030 (전면파티션 복재 안함), -2400: z축 거리 -2400
      var opposite_desk_distance = 0; // 초기값: 미러링 비활성화

      var desk;

      var board;
      var giyeok_board;
      var board_thickness = 20;
      // [2] 책상옵션 - 치수(폭)
      var board_width = 1200;
      var board_width_idx = 1;
      // [3] 책상옵션 - 치수(깊이)
      var board_depth = 500;
      var board_depth_idx = 1;
      // [8] 책상옵션 - 상판 색상
      var board_color = 1;
      var board_material = new THREE.MeshPhongMaterial({ color: white_color });

      var frame;
      var frame_thickness = 40;
      var frame_thickness_under_board = 20;
      var frame_length = 700;
      var frame_margin = 2;       // between frame and board
      // [9] 책상옵션 - 프레임 색상
      var frame_color = 1;
      var frame_material = new THREE.MeshPhongMaterial({ color: white_color });

      var vertical;
      // [4] 책상옵션 - 수직부재 치수(높이)
      var vertical_length_idx = 0;
      var vertical_length = 0;
      var vertical_y;
      var vertical_y_offset = 0; // 수직부재 위치 오프셋 (93.5mm 단위)
      var storage_y_offset = 0; // 수납 도어 위치 오프셋 (93.5mm 단위)
      // [10] 책상옵션 - 수직부재 색상
      var vertical_color = 1;
      var vertical_material = new THREE.MeshPhongMaterial({ color: white_color });

      var shelf;
      // [6] 책상옵션 - 선반(깊이)
      var shelf_depth = 200;
      // [5] 책상옵션 - 선반(수)
      var shelf_num = 0;
      // [7] 책상옵션 - 선반 방향
      var shelf_direction = 0; // out - 0, in - 1
      // [11] 책상옵션 - 선반 상판 색상
      var shelf_board_color = 1;
      // [12] 책상옵션 - 선반 프레임 색상
      var shelf_frame_color = 1;
      var shelf_board_material = new THREE.MeshPhongMaterial({ color: white_color });
      var shelf_frame_material = new THREE.MeshPhongMaterial({ color: white_color });

      var leg_pad;
      var leg_pad_meterial = new THREE.MeshPhongMaterial({ color: white_color });

      // ===== 3그룹: 액세서리 =====
      // [13] 책상옵션 - ㄱ자 모듈
      var giyeok_position = 0;

      // [14] 상판옵션 - 데스크 매트
      var desk_mat_color = 0;
      var desk_mat;
      var desk_mat_material;

      // [15] 상판옵션 - 미니서랍
      var drawer_position = 0;
      var drawer_color = 0;
      var drawer_up;
      var drawer_down;
      var drawer_material = getMaterial(drawer_color);

      // [16] 하부옵션 - 하부가림판
      var fence_color = 0;
      var fence;
      var fence_material = new THREE.MeshPhongMaterial({ color: white_color });

      // [30] 하부옵션 - 2단 이동 서랍
      var moving2_color = 0;
      var moving2_position = 1;
      var moving2;
      var moving2_material = new THREE.MeshPhongMaterial({ color: white_color });
      var drawer1, drawer2, drawer3;
      var wheel;

      // [31] 하부옵션 - 3단 이동 서랍
      var moving3_color = 0;
      var moving3_position = 1;
      var moving3;
      var moving3_material = new THREE.MeshPhongMaterial({ color: white_color });

      // 새로운 옵션 변수들 (좌우 각각 1개씩만 설치 가능)
      // [17] 하부옵션 - 부착형 서랍 1단
      var attach1_left_color = 0;
      var attach1_right_color = 0;
      var attach1;
      var attach1_material = new THREE.MeshPhongMaterial({ color: white_color });
      var attach1_model = null; // GLB 모델

      // [18] 하부옵션 - 부착형 서랍 2단
      var attach2_left_color = 0;
      var attach2_right_color = 0;
      var attach2;
      var attach2_material = new THREE.MeshPhongMaterial({ color: white_color });
      var attach2_model = null; // GLB 모델

      // [19] 하부옵션 - 본체함
      var attach3_left_color = 0;
      var attach3_right_color = 0;
      var attach3;
      var attach3_material = new THREE.MeshPhongMaterial({ color: white_color });
      var attach3_model = null; // GLB 모델

      // [20] 상부옵션 - 수납_슬라이딩도어 1단
      var storage_sliding1_color = 0;
      var storage_sliding1;
      var storage_sliding1_material = new THREE.MeshPhongMaterial({ color: white_color });
      var storage_sliding1_models = {}; // 높이별 GLB 모델 저장

      // [21] 상부옵션 - 수납_슬라이딩도어 2단
      var storage_sliding2_color = 0;
      var storage_sliding2;
      var storage_sliding2_material = new THREE.MeshPhongMaterial({ color: white_color });
      var storage_sliding2_models = {}; // 높이별 GLB 모델 저장

      // [22] 상부옵션 - 수납_플랩도어
      var storage_flap_color = 0;
      var storage_flap;
      var storage_flap_material = new THREE.MeshPhongMaterial({ color: white_color });
      var storage_flap_models = {}; // 높이별 GLB 모델 저장
      var storage_flap_loader = null; // GLTFLoader는 나중에 초기화

      // [23] 상부옵션 - 수납_플랩스테이도어
      var storage_flapstay_color = 0;
      var storage_flapstay;
      var storage_flapstay_material = new THREE.MeshPhongMaterial({ color: white_color });
      var storage_flapstay_models = {}; // 높이별 GLB 모델 저장

      // ㄱ자 데스크 하부 서랍 변수들 (좌우 각각 독립적으로 선택 가능)
      var giyeok_attach1_left_color = 0;
      var giyeok_attach1_right_color = 0;
      var giyeok_attach1_material = new THREE.MeshPhongMaterial({ color: white_color });
      // attach1_model 사용 (일반 부착서랍과 동일)

      var giyeok_attach2_left_color = 0;
      var giyeok_attach2_right_color = 0;
      var giyeok_attach2_material = new THREE.MeshPhongMaterial({ color: white_color });
      // attach2_model 사용 (일반 부착서랍과 동일)

      var giyeok_attach3_left_color = 0;
      var giyeok_attach3_right_color = 0;
      var giyeok_attach3_material = new THREE.MeshPhongMaterial({ color: white_color });
      // attach3_model 사용 (일반 본체함과 동일)

      var giyeok_moving2_left_color = 0;
      var giyeok_moving2_right_color = 0;
      var giyeok_moving2_material = new THREE.MeshPhongMaterial({ color: white_color });
      var giyeok_moving2_model = null; // GLB 모델 (moving2 전용 또는 attach2 재사용)

      var giyeok_moving3_left_color = 0;
      var giyeok_moving3_right_color = 0;
      var giyeok_moving3_material = new THREE.MeshPhongMaterial({ color: white_color });
      var giyeok_moving3_model = null; // GLB 모델 (moving3 전용 또는 attach3 재사용)

      // ㄱ자 하부 서랍 타입 선택 변수 (1: 부착서랍1단, 2: 부착서랍2단, 3: 본체함, 4: 이동서랍2단, 5: 이동서랍3단)
      var giyeok_drawer_type_left = 0;
      var giyeok_drawer_type_right = 0;

      // [24] 파티션옵션 - 파티션_ver_L 높이
      var parti_ver_L_height = 0;
      // [25] 파티션옵션 - 파티션_ver_L 색상
      var parti_ver_L_color = 0;
      var parti_ver_L;
      var parti_ver_L_material = new THREE.MeshPhongMaterial({ color: gray_color });

      // [26] 파티션옵션 - 파티션_ver_R 높이
      var parti_ver_R_height = 0;
      // [27] 파티션옵션 - 파티션_ver_R 색상
      var parti_ver_R_color = 0;
      var parti_ver_R;
      var parti_ver_R_material = new THREE.MeshPhongMaterial({ color: gray_color });

      // [28] 파티션옵션 - 파티션_hol_B_넓이
      var parti_hol_B_width = 0;
      // [29] 파티션옵션 - 파티션_hol_B 색상
      var parti_hol_B_color = 0;
      var parti_hol_B;
      var parti_hol_B_material = new THREE.MeshPhongMaterial({ color: gray_color });

      var parti_ver_M_height = 0; // 중첩위치 파티션 높이 (책상과 책상 사이 중첩되는 위치)
      var parti_ver_M_color = 0;
      var parti_ver_M;
      var parti_ver_M_material = new THREE.MeshPhongMaterial({ color: gray_color });
      
      // [30] 파티션옵션 - 파티션 Z축 위치 정렬 (책상 깊이 1000 이상일 때만 활성화)
      // 0: 기본 위치 (Z=0), 1: 하부옵션 전면과 같은 라인 (Z = board_depth / 2 - 200)
      var parti_z_align_front = 0;

      var link = document.createElement( 'a' );
      link.style.display = 'none';
      document.body.appendChild( link );

      var product_code_string;
      
      // URL 업데이트 제어 플래그 (loadProductFromCode에서 호출 시 URL 업데이트 방지)
      var skipURLUpdate = false;
      
      // 씬 업데이트 제어 플래그 (loadProductFromCode에서 호출 시 각 setter의 updateScene/render 호출 방지)
      var skipSceneUpdate = false;

      // 아웃라인을 위한 변수 (중복 방지)
      var outlineMeshes = new Set();
      
      // 아웃라인을 위한 헬퍼 함수
      function addOutlineToMesh(mesh) {
        if (!mesh || !mesh.geometry || outlineMeshes.has(mesh)) return null;
        try {
          var edges = new THREE.EdgesGeometry(mesh.geometry);
          var outline = new THREE.LineSegments(
            edges,
            new THREE.LineBasicMaterial({ 
              color: 0x000000, 
              transparent: true,
              opacity: 0.9,
              depthTest: true,
              depthWrite: false
            })
          );
          // 메시와 함께 이동/회전/스케일되도록 메시를 부모로 설정
          mesh.add(outline);
          outlineMeshes.add(mesh);
          return outline;
        } catch(e) {
          console.warn('Failed to add outline:', e);
          return null;
        }
      }
      
      // 씬의 모든 메시에 아웃라인 추가
      function addOutlinesToScene() {
        // 기존 아웃라인 제거
        scene.traverse(function(object) {
          if (object instanceof THREE.LineSegments && object.material && object.material.color && object.material.color.getHex() === 0x000000) {
            if (object.parent) {
              object.parent.remove(object);
            }
          }
        });
        outlineMeshes.clear();
        
        // 모든 메시에 아웃라인 추가
        scene.traverse(function(object) {
          if (object instanceof THREE.Mesh && object.geometry && object.material) {
            // 특정 객체는 제외 (예: 평면, 이미 아웃라인이 있는 경우)
            if (object.userData && object.userData.skipOutline) return;
            // LineSegments는 제외
            if (object instanceof THREE.LineSegments) return;
            addOutlineToMesh(object);
          }
        });
      }

      // 가격 데이터 먼저 로드 후 초기화
      loadPriceData().then(function() {
        console.log('✅ 가격 데이터 로드 완료, 씬 초기화 시작');
        init();
        animate();
      }).catch(function(error) {
        console.error('❌ 가격 데이터 로드 실패, 기본값으로 진행:', error);
        // 실패해도 기본값으로 진행
        init();
        animate();
      });

      function init() {
        // HTML 이미지 경로도 base path 적용
        var configuratorImg = document.getElementById('configurator_img');
        if (configuratorImg) {
          configuratorImg.src = getResourcePath('img/configurator.jpg');
        }
        var logoImg = document.getElementById('logo_img');
        if (logoImg) {
          logoImg.src = getResourcePath('img/logo.png');
        }
        
        // 모든 texture 이미지 경로 업데이트
        var textureImages = document.querySelectorAll('img[src^="texture/"]');
        textureImages.forEach(function(img) {
          var originalSrc = img.getAttribute('src');
          if (originalSrc && originalSrc.indexOf('http') !== 0 && originalSrc.indexOf('/') !== 0) {
            img.src = getResourcePath(originalSrc);
          }
        });
        
        container = document.getElementById('canvas');
        width = window.innerWidth;
        height = window.innerHeight;

        camera = new THREE.PerspectiveCamera(20, width / height, 100, 50000);
        camera.position.x = 1000 * 2;
        camera.position.y = 1500 * 2;
        camera.position.z = 5000 * 2;

        // GLTFLoader 초기화
        var gltfLoader = null;
        var glbLoadTimer = null; // 디바운싱 타이머
        var pendingSceneUpdate = false; // 씬 업데이트 대기 중인지
        var glbLoadCount = 0; // 로드된 GLB 파일 수
        var totalGlbFiles = 3 + (5 * 4); // attach1-3 + Storage 파일들 (5개 높이 * 4종류)
        var initialLoadComplete = false; // 초기 로드 완료 여부
        
        // 디바운싱된 씬 업데이트 함수 (모바일에서 더 긴 대기 시간)
        var debounceTime = isMobile ? 800 : 300; // 모바일: 800ms, 데스크톱: 300ms (더 길게 조정)
        
        function debouncedSceneUpdate(skipDebounce) {
          // 초기 로드 완료 전에는 렌더링하지 않음 (깜빡임 방지)
          if (!initialLoadComplete && !skipDebounce) {
            pendingSceneUpdate = true;
            return; // 초기 로드 완료 전에는 업데이트하지 않음
          }
          
          pendingSceneUpdate = true;
          
          // 초기 로드 완료 후에는 디바운싱 적용
          if (glbLoadTimer) {
            clearTimeout(glbLoadTimer);
          }
          glbLoadTimer = setTimeout(function() {
            if (pendingSceneUpdate) {
              updateScene();
              render();
              pendingSceneUpdate = false;
            }
          }, debounceTime);
        }
        
        if (typeof THREE.GLTFLoader !== 'undefined') {
          gltfLoader = new THREE.GLTFLoader();
          
          // attach1, attach2, attach3 GLB 모델 로드
          var attach1Path = getResourcePath('glb/attach1.glb');
          console.log('📦 attach1.glb 로드 시도:', attach1Path);
          gltfLoader.load(attach1Path, function(gltf) {
            attach1_model = gltf.scene;
            attach1_model.traverse(function(child) {
              if (child instanceof THREE.Mesh) {
                child.castShadow = true;
                child.receiveShadow = true;
              }
            });
            console.log('✅ attach1.glb 로드 성공');
            glbLoadCount++;
            // 초기 로드 중에는 디바운싱, 이후에는 즉시 업데이트
            debouncedSceneUpdate(glbLoadCount >= totalGlbFiles);
            if (glbLoadCount >= totalGlbFiles && !initialLoadComplete) {
              initialLoadComplete = true;
              console.log('✅ 모든 GLB 파일 초기 로드 완료');
            }
          }, undefined, function(error) {
            console.error('❌ attach1.glb 로드 실패:', error);
            console.error('   경로:', attach1Path);
            console.error('   Base Path:', basePath);
            glbLoadCount++;
            debouncedSceneUpdate(glbLoadCount >= totalGlbFiles);
            if (glbLoadCount >= totalGlbFiles && !initialLoadComplete) {
              initialLoadComplete = true;
            }
          });
          
          var attach2Path = getResourcePath('glb/attach2.glb');
          console.log('📦 attach2.glb 로드 시도:', attach2Path);
          gltfLoader.load(attach2Path, function(gltf) {
            attach2_model = gltf.scene;
            attach2_model.traverse(function(child) {
              if (child instanceof THREE.Mesh) {
                child.castShadow = true;
                child.receiveShadow = true;
              }
            });
            console.log('✅ attach2.glb 로드 성공');
            glbLoadCount++;
            debouncedSceneUpdate(glbLoadCount >= totalGlbFiles);
            if (glbLoadCount >= totalGlbFiles && !initialLoadComplete) {
              initialLoadComplete = true;
              console.log('✅ 모든 GLB 파일 초기 로드 완료');
            }
          }, undefined, function(error) {
            console.error('❌ attach2.glb 로드 실패:', error);
            console.error('   경로:', attach2Path);
            glbLoadCount++;
            debouncedSceneUpdate(glbLoadCount >= totalGlbFiles);
            if (glbLoadCount >= totalGlbFiles && !initialLoadComplete) {
              initialLoadComplete = true;
            }
          });
          
          var attach3Path = getResourcePath('glb/attach3.glb');
          console.log('📦 attach3.glb 로드 시도:', attach3Path);
          gltfLoader.load(attach3Path, function(gltf) {
            attach3_model = gltf.scene;
            attach3_model.traverse(function(child) {
              if (child instanceof THREE.Mesh) {
                child.castShadow = true;
                child.receiveShadow = true;
              }
            });
            console.log('✅ attach3.glb 로드 성공');
            glbLoadCount++;
            debouncedSceneUpdate(glbLoadCount >= totalGlbFiles);
            if (glbLoadCount >= totalGlbFiles && !initialLoadComplete) {
              initialLoadComplete = true;
              console.log('✅ 모든 GLB 파일 초기 로드 완료');
            }
          }, undefined, function(error) {
            console.error('❌ attach3.glb 로드 실패:', error);
            console.error('   경로:', attach3Path);
            glbLoadCount++;
            debouncedSceneUpdate(glbLoadCount >= totalGlbFiles);
            if (glbLoadCount >= totalGlbFiles && !initialLoadComplete) {
              initialLoadComplete = true;
            }
          });
          
          // Storage_Sliding1 높이별 모델 로드
          var sliding1_heights = [1200, 1400, 1600, 1800, 2060];
          sliding1_heights.forEach(function(height) {
            gltfLoader.load(getResourcePath('glb/Storage_Sliding1 ' + height + '.glb'), function(gltf) {
              storage_sliding1_models[height] = gltf.scene;
              gltf.scene.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                  child.castShadow = true;
                  child.receiveShadow = true;
                }
              });
              glbLoadCount++;
              debouncedSceneUpdate(glbLoadCount >= totalGlbFiles);
              if (glbLoadCount >= totalGlbFiles && !initialLoadComplete) {
                initialLoadComplete = true;
                console.log('✅ 모든 GLB 파일 초기 로드 완료');
              }
            }, undefined, function(error) {
              console.error('Storage_Sliding1 ' + height + '.glb 로드 실패:', error);
              glbLoadCount++;
              if (glbLoadCount >= totalGlbFiles && !initialLoadComplete) {
                initialLoadComplete = true;
              }
            });
          });
          
          // Storage_Sliding2 높이별 모델 로드
          var sliding2_heights = [1200, 1400, 1600, 1800, 2060];
          sliding2_heights.forEach(function(height) {
            gltfLoader.load(getResourcePath('glb/Storage_Sliding2 ' + height + '.glb'), function(gltf) {
              storage_sliding2_models[height] = gltf.scene;
              gltf.scene.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                  child.castShadow = true;
                  child.receiveShadow = true;
                }
              });
              glbLoadCount++;
              debouncedSceneUpdate(glbLoadCount >= totalGlbFiles);
              if (glbLoadCount >= totalGlbFiles && !initialLoadComplete) {
                initialLoadComplete = true;
                console.log('✅ 모든 GLB 파일 초기 로드 완료');
              }
            }, undefined, function(error) {
              console.error('Storage_Sliding2 ' + height + '.glb 로드 실패:', error);
              glbLoadCount++;
              if (glbLoadCount >= totalGlbFiles && !initialLoadComplete) {
                initialLoadComplete = true;
              }
            });
          });
          
          // Storage_Flap 높이별 모델 로드
          var flap_heights = [1200, 1400, 1600, 1800, 2060];
          flap_heights.forEach(function(height) {
            gltfLoader.load(getResourcePath('glb/Storage_Flap ' + height + '.glb'), function(gltf) {
              storage_flap_models[height] = gltf.scene;
              gltf.scene.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                  child.castShadow = true;
                  child.receiveShadow = true;
                }
              });
              glbLoadCount++;
              debouncedSceneUpdate(glbLoadCount >= totalGlbFiles);
              if (glbLoadCount >= totalGlbFiles && !initialLoadComplete) {
                initialLoadComplete = true;
                console.log('✅ 모든 GLB 파일 초기 로드 완료');
              }
            }, undefined, function(error) {
              console.error('Storage_Flap ' + height + '.glb 로드 실패:', error);
              glbLoadCount++;
              if (glbLoadCount >= totalGlbFiles && !initialLoadComplete) {
                initialLoadComplete = true;
              }
            });
          });
          
          // Storage_FlapStay 높이별 모델 로드
          var flapstay_heights = [1200, 1400, 1600, 1800, 2060];
          flapstay_heights.forEach(function(height) {
            gltfLoader.load(getResourcePath('glb/Storage_FlapStay ' + height + '.glb'), function(gltf) {
              storage_flapstay_models[height] = gltf.scene;
              gltf.scene.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                  child.castShadow = true;
                  child.receiveShadow = true;
                }
              });
              glbLoadCount++;
              debouncedSceneUpdate(glbLoadCount >= totalGlbFiles);
              if (glbLoadCount >= totalGlbFiles && !initialLoadComplete) {
                initialLoadComplete = true;
                console.log('✅ 모든 GLB 파일 초기 로드 완료');
              }
            }, undefined, function(error) {
              console.error('Storage_FlapStay ' + height + '.glb 로드 실패:', error);
              glbLoadCount++;
              if (glbLoadCount >= totalGlbFiles && !initialLoadComplete) {
                initialLoadComplete = true;
              }
            });
          });
        }

        // 초기 씬 업데이트는 GLB 파일 로드 시작 후 약간 지연 (모바일에서 더 길게)
        // 모든 GLB 파일이 로드될 때까지 기다리지 않고, 일정 시간 후 초기 렌더링
        var initialRenderTimer = setTimeout(function() {
          if (!initialLoadComplete) {
            // 초기 로드가 완료되지 않았어도 기본 씬은 표시
            updateScene();
            render();
          }
        }, isMobile ? 2000 : 1000); // 모바일: 2초, 데스크톱: 1초 대기
        
        // 모든 GLB 파일 로드 완료 시 초기 렌더링 타이머 취소하고 최종 렌더링
        var checkInitialLoad = setInterval(function() {
          if (initialLoadComplete) {
            clearTimeout(initialRenderTimer);
            clearInterval(checkInitialLoad);
            // 최종 렌더링 (한 번만)
            updateScene();
            render();
            console.log('🎨 최종 씬 렌더링 완료');
          }
        }, 100);
        
        // 선반 방향 UI 초기화
        updateShelfDirectionUI();

        // renderer
        // 모바일 감지
        var isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;
        var isLowEndDevice = navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 4;
        
        // 모바일 최적화 설정
        var pixelRatio = isMobile ? Math.min(window.devicePixelRatio, 1.5) : window.devicePixelRatio; // 모바일에서 픽셀 비율 제한
        var antialias = !isMobile; // 모바일에서 안티앨리어싱 비활성화
        
        renderer = new THREE.WebGLRenderer({ antialias: antialias });
        renderer.shadowMap.enabled = !isLowEndDevice; // 저사양 기기에서 그림자 비활성화
        renderer.shadowMap.type = isMobile ? THREE.BasicShadowMap : THREE.PCFSoftShadowMap; // 모바일에서 기본 그림자 사용
        renderer.setClearColor(white_color);
        renderer.setPixelRatio(pixelRatio);
        renderer.setSize(width, height);
        
        console.log('📱 디바이스 정보:', {
          '모바일': isMobile,
          '저사양': isLowEndDevice,
          '픽셀 비율': pixelRatio,
          '안티앨리어싱': antialias,
          '그림자': renderer.shadowMap.enabled
        });

        container.appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.autoRotate = false; // 기본적으로 멈춰있게 설정
        controls.autoRotateSpeed *= 2.0;
        // 모바일에서 컨트롤 속도 조정
        controls.rotateSpeed = isMobile ? 2.5 : 5.0;
        controls.zoomSpeed = isMobile ? 0.8 : 1.2;
        controls.panSpeed = isMobile ? 1.0 : 1.8;
        controls.enableDamping = isMobile; // 모바일에서 댐핑 활성화 (부드러운 움직임)
        if (isMobile) {
          controls.dampingFactor = 0.05;
        }
        controls.target = new THREE.Vector3(0, 500, 0);

        // 모바일에서 터치 이벤트 최적화
        if (isMobile && controls.touches) {
          controls.touches = {
            ONE: THREE.TOUCH.ROTATE,
            TWO: THREE.TOUCH.DOLLY_PAN
          };
        }

        controls.addEventListener('change', render);
        
        // 회전 정지/재개 버튼 초기화
        updateRotationButton();
        
        // 책상 맞은편 미러링 메뉴 초기화
        opposite_desk_distance = 0;
        // UI 초기화는 updateScene()에서 처리됨
        
        // 파티션 Z축 위치 메뉴 초기화
        parti_z_align_front = 0;
        if (board_depth >= 1000) {
          $("#parti-z-align-menu").css({"visibility": "visible", "height": "auto", "overflow": "visible"});
        } else {
          $("#parti-z-align-menu").css({"visibility": "hidden", "height": "0", "overflow": "hidden"});
        }
        
        // Swiper 업데이트 (슬라이드 개수 재계산)
        setTimeout(function() {
          if (window.swiperInstance) {
            window.swiperInstance.update();
            window.swiperInstance.updateSlides();
          }
        }, 100);

        window.addEventListener('resize', onWindowResize, false);
        
        // 초기 씬 생성
        updateScene();
        render();
        
        // URL에서 코드 로드 (없으면 기본값 사용)
        // updateScene() 호출 후에 로드해야 모든 변수가 초기화됨
        if (!loadCodeFromURL()) {
          // URL에 코드가 없으면 기본 코드로 초기화
          var codeInput = document.getElementById('product_code_input');
          if (codeInput) {
            codeInput.value = generateProductCode();
            // 초기 로드 시에는 replaceState로 히스토리 교체
            updateURL(true);
          }
        }
        
        // 옵션 명세 리스트는 기본적으로 숨김 상태로 시작 (사용자가 펼칠 수 있도록)
        // updateScene()에서 이미 updateOptionSpecList()가 호출되므로 여기서는 호출하지 않음
      }

      function setMium(m) {
        is_mium = m;

        if (checkCollision()) {
          is_mium = 0;
          return;
        }

        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      function setWidth(w) {
        var prev = board_width;

        board_width = w;
        if (checkCollision()) {
          board_width = prev;
          return;
        }

        switch (board_width) {
        case 1200:
          board_width_idx = 1;
          break;
        case 1400:
          board_width_idx = 2;
          break;
        case 1600:
          board_width_idx = 3;
          break;
        case 1800:
          board_width_idx = 4;
          break;
        case 2060:
          board_width_idx = 5;
          break;
        case 2360: // Added based on CSV
          board_width_idx = 6;
          break;
        default:
          board_width_idx = 0;
        }

        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      function setDepth(d) {
        var prev = board_depth;

        board_depth = d;
        if (checkCollision()) {
          board_depth = prev;
          return;
        }

        switch (board_depth) {
        case 500:
          board_depth_idx = 1;
          break;
        case 600:
          board_depth_idx = 2;
          break;
        case 700:
          board_depth_idx = 3;
          break;
        case 800: // Added based on CSV
          board_depth_idx = 4;
          break;
        case 1000: // Added based on CSV
          board_depth_idx = 5;
          break;
        case 1200: // Added based on CSV
          board_depth_idx = 6;
          break;
        default:
          board_depth_idx = 0;
        }
        
        // 파티션 Z축 위치 메뉴 표시/숨김 (책상 깊이 1000 이상일 때만 표시)
        if (board_depth >= 1000) {
          $("#parti-z-align-menu").css({"visibility": "visible", "height": "auto", "overflow": "visible"});
        } else {
          $("#parti-z-align-menu").css({"visibility": "hidden", "height": "0", "overflow": "hidden"});
          parti_z_align_front = 0; // 깊이가 1000 미만이면 기본 위치로 리셋
        }
        
        // Swiper 업데이트 (슬라이드 개수 재계산)
        setTimeout(function() {
          if (window.swiperInstance) {
            window.swiperInstance.update();
            window.swiperInstance.updateSlides();
          }
        }, 50);

        updateScene();
        render();
      }

      function getMaterial(color_code) {
        var material;

        switch (color_code) {
          case 1: // W: 화이트
            material = new THREE.MeshPhongMaterial({ color: white_color });
            return material;
          case 2: // B: 블랙
            material = new THREE.MeshPhongMaterial({ color: black_color });
            return material;
          case 3: // G: 그레이
            material = new THREE.MeshPhongMaterial({ color: gray_color });
            return material;
          case 4: // 내추럴 (W2로도 사용 가능)
          case 9: // W2: 중간밝기 우드 (natural)
            // 텍스처가 로드되었는지 확인
            if (texture_natural && texture_natural.image && texture_natural.image.complete && texture_natural.image.width > 0) {
              configureTexture(texture_natural);
            material = new THREE.MeshPhongMaterial({ map: texture_natural });
            } else {
              // 텍스처가 아직 로드되지 않았으면 임시로 색상 사용
              material = new THREE.MeshPhongMaterial({ color: beige_color });
            }
            return material;
          case 5: // 파인
            if (texture_pine && texture_pine.image && texture_pine.image.complete && texture_pine.image.width > 0) {
              configureTexture(texture_pine);
            material = new THREE.MeshPhongMaterial({ map: texture_pine });
            } else {
              material = new THREE.MeshPhongMaterial({ color: beige_color });
            }
            return material;
          case 6: // 콘크리트
            if (texture_concrete && texture_concrete.image && texture_concrete.image.complete && texture_concrete.image.width > 0) {
              configureTexture(texture_concrete);
            material = new THREE.MeshPhongMaterial({ map: texture_concrete });
            } else {
              material = new THREE.MeshPhongMaterial({ color: gray_color });
            }
            return material;
          case 7: // 레드파인
            if (texture_redpine && texture_redpine.image && texture_redpine.image.complete && texture_redpine.image.width > 0) {
              configureTexture(texture_redpine);
            material = new THREE.MeshPhongMaterial({ map: texture_redpine });
            } else {
              material = new THREE.MeshPhongMaterial({ color: brown_color });
            }
            return material;
          case 8: // W1: 밝은 우드 (maple)
            if (texture_maple && texture_maple.image && texture_maple.image.complete && texture_maple.image.width > 0) {
              configureTexture(texture_maple);
              material = new THREE.MeshPhongMaterial({ map: texture_maple });
            } else {
              material = new THREE.MeshPhongMaterial({ color: beige_color });
            }
            return material;
          case 10: // W3: 월넛 우드 (walnut)
            if (texture_walnut && texture_walnut.image && texture_walnut.image.complete && texture_walnut.image.width > 0) {
              configureTexture(texture_walnut);
              material = new THREE.MeshPhongMaterial({ map: texture_walnut });
            } else {
              material = new THREE.MeshPhongMaterial({ color: brown_color });
            }
            return material;
          case 11: // LG: light grey
            material = new THREE.MeshPhongMaterial({ color: light_gray_color });
            return material;
          case 12: // BE: beige
            material = new THREE.MeshPhongMaterial({ color: beige_color });
            return material;
          case 13: // BR: brown
            material = new THREE.MeshPhongMaterial({ color: brown_color });
            return material;
          case 14: // O: orange
            material = new THREE.MeshPhongMaterial({ color: orange_color });
            return material;
          case 15: // OT: orange transparent (반투명)
            material = new THREE.MeshPhongMaterial({ color: orange_color, transparent: true, opacity: 0.7 });
            return material;
          case 16: // L: lemon
            material = new THREE.MeshPhongMaterial({ color: lemon_color });
            return material;
          case 17: // GN: green
            material = new THREE.MeshPhongMaterial({ color: green_color });
            return material;
          default:
            material = new THREE.MeshPhongMaterial({ color: white_color });
            return material;
        }
      }

      function setBoardColor(c) {
        board_color = c;
        
        // 텍스처가 필요한 색상인지 확인
        var needsTexture = (c == 4 || c == 5 || c == 6 || c == 7 || c == 8 || c == 9 || c == 10);
        var texture = null;
        var textureLoaded = false;
        
        if (c == 4 || c == 9) {
          texture = texture_natural;
        } else if (c == 5) {
          texture = texture_pine;
        } else if (c == 6) {
          texture = texture_concrete;
        } else if (c == 7) {
          texture = texture_redpine;
        } else if (c == 8) {
          texture = texture_maple;
        } else if (c == 10) {
          texture = texture_walnut;
        }
        
        // 텍스처 로드 상태 확인
        if (needsTexture && texture) {
          textureLoaded = (texture.image && texture.image.complete && texture.image.width > 0);
          
          if (textureLoaded) {
            // 텍스처가 이미 로드됨 - 즉시 material 생성
            configureTexture(texture);
            board_material = getMaterial(c);
          } else {
            // 텍스처가 아직 로드되지 않음 - 로드 완료 대기
            var onTextureLoad = function() {
              configureTexture(texture);
        board_material = getMaterial(c);
              updateScene();
              render();
            };
            
            if (texture.image && texture.image.complete) {
              // 이미지가 있지만 완료되지 않음
              texture.image.onload = onTextureLoad;
            } else {
              // 로드 이벤트 리스너 추가
              texture.addEventListener('load', onTextureLoad);
            }
            
            // 임시 material 생성
            board_material = getMaterial(c);
          }
        } else {
          // 텍스처가 필요 없는 색상
          board_material = getMaterial(c);
        }
        
        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      function setFrameColor(c) {
        frame_color = c;
        frame_material = getMaterial(c);

        if (c == 1)
          leg_pad_meterial = new THREE.MeshPhongMaterial({ color: white_color });
        else
          leg_pad_meterial = new THREE.MeshPhongMaterial({ color: black_color });

        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      function setVerticalColor(c) {
        vertical_color = c;
        vertical_material = getMaterial(c);
        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      function setShelfBoardColor(c) {
        shelf_board_color = c;
        shelf_board_material = getMaterial(c);
        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      function setShelfFrameColor(c) {
        shelf_frame_color = c;
        shelf_frame_material = getMaterial(c);
        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      function setVertical(c) {
        vertical_length_idx = c;
        vertical_y_offset = 0; // 수직부재 변경 시 오프셋 초기화
        storage_y_offset = 0; // 수납 도어 오프셋도 초기화
        
        // Updated based on CSV Logic
        switch (c) {
          case 0:
            vertical_length = 0;
            shelf_num = 0;
            break;
          case 1:
            vertical_length = 646; // Updated from 640
            vertical_y = -30;
            break;
          case 2:
            vertical_length = 925; // Updated from 920
            vertical_y = -30;
            break;
          case 3:
            vertical_length = 1400; // New height from CSV
            vertical_y = 240; // Approx positioning
            break;
          case 4:
            vertical_length = 1860;
            vertical_y = 360;
            break;
          default:
            vertical_length = 0;
            shelf_num = 0;
            break;
        }

        adjustShlefNum();

        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      function moveVerticalUp() {
        if (vertical_length == 0) return; // 수직부재가 없으면 동작 안함
        
        var max_up = 0; // 위로 이동 가능한 최대 칸 수
        var max_down = 0; // 아래로 이동 가능한 최대 칸 수
        
        switch (vertical_length_idx) {
          case 1: // 646
            max_up = 3;
            max_down = 3;
            break;
          case 2: // 925
            max_up = 3;
            max_down = 3;
            break;
          case 3: // 1400
            max_up = 3;
            max_down = 0; // 아래로 이동 불가
            break;
          case 4: // 1860
            max_up = 3;
            max_down = 0; // 아래로 이동 불가
            break;
          default:
            return;
        }
        
        // 위로 이동 가능한지 확인
        if (vertical_y_offset < max_up) {
          vertical_y_offset++;
          updateScene();
          render();
        }
      }

      function moveVerticalDown() {
        if (vertical_length == 0) return; // 수직부재가 없으면 동작 안함
        
        var max_up = 0; // 위로 이동 가능한 최대 칸 수
        var max_down = 0; // 아래로 이동 가능한 최대 칸 수
        
        switch (vertical_length_idx) {
          case 1: // 646
            max_up = 3;
            max_down = 3;
            break;
          case 2: // 925
            max_up = 3;
            max_down = 3;
            break;
          case 3: // 1400
            max_up = 3;
            max_down = 0; // 아래로 이동 불가
            break;
          case 4: // 1860
            max_up = 3;
            max_down = 0; // 아래로 이동 불가
            break;
          default:
            return;
        }
        
        // 아래로 이동 가능한지 확인
        if (vertical_y_offset > -max_down) {
          vertical_y_offset--;
          updateScene();
          render();
        }
      }

      function setShelfNum(n) {
        shelf_num = n;
        adjustShlefNum();

        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      function setShelfDirection(d) {
        // 선반 깊이가 360일 때는 바깥방향(0)만 선택 가능
        if (shelf_depth == 360 && d == 1) {
          // 안쪽 선택 시도 시 자동으로 바깥쪽으로 변경
          shelf_direction = 0;
        } else {
          shelf_direction = d;
        }
        // 선반 깊이가 200이고 방향을 안쪽으로 설정할 때는 상부 옵션 해제
        if (shelf_depth == 200 && d == 1) {
          storage_sliding1_color = 0;
          storage_sliding2_color = 0;
          storage_flap_color = 0;
          storage_flapstay_color = 0;
        }
        adjustShlefNum();
        updateShelfDirectionUI();

        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      // 선반 방향 UI 업데이트 함수
      function updateShelfDirectionUI() {
        // 선반 방향 버튼 찾기 (선반방향 메뉴의 버튼들)
        var shelfDirectionSlide = $(".swiper-slide").filter(function() {
          return $(this).find(".menu_title").text().trim() === "선반방향";
        });
        
        if (shelfDirectionSlide.length > 0) {
          var buttons = shelfDirectionSlide.find(".mal_buttons > div");
          var insideButton = buttons.eq(1); // 안쪽 버튼 (두 번째)
          
          // 선반 깊이가 360일 때 안쪽 버튼 비활성화
          if (shelf_depth == 360) {
            insideButton.css({
              "opacity": "0.5",
              "pointer-events": "none",
              "cursor": "not-allowed"
            });
            // 선반 방향 표시 업데이트
            shelfDirectionSlide.find(".menu_sel_text").text("바깥쪽");
          } else {
            // 선반 깊이가 200일 때는 안쪽 버튼 활성화
            insideButton.css({
              "opacity": "1",
              "pointer-events": "auto",
              "cursor": "pointer"
            });
            // 선반 방향 표시 업데이트
            var directionText = shelf_direction == 0 ? "바깥쪽" : "안쪽";
            shelfDirectionSlide.find(".menu_sel_text").text(directionText);
          }
        }
      }

      function setGiyeok(d) {
        var prev = giyeok_position;

        giyeok_position = d;
        if (checkCollision()) {
          giyeok_position = prev;
          return;
        }

        // d: 0=없음, 1=L, 2=R, 3=C, 4=L+R
        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      function setDeskMat(c) {
        var prev = desk_mat_color;

        desk_mat_color = c;
        if (checkCollision()) {
          desk_mat_color = prev;
          return;
        }

        switch (desk_mat_color) {
        case 0:
          break;
        case 1: // G: 그레이
          desk_mat_material = getMaterial(3);
          break;
        case 2: // B: 블랙
          desk_mat_material = getMaterial(2);
          break;
        case 3: // LG: light grey
          desk_mat_material = getMaterial(11);
          break;
        case 4: // BE: beige
          desk_mat_material = getMaterial(12);
          break;
        case 5: // BR: brown
          desk_mat_material = getMaterial(13);
          break;
        }
        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      function setDrawerColor(c) {
        drawer_color = c;
        if (drawer_color) {
          if (giyeok_position == 1)
            drawer_position = 2;
          else
            drawer_position = 1;

          if (checkCollision()) {
            drawer_color = 0;
            return;
          }

          // 색상 코드 매핑: 1=W, 2=B, 3=O, 4=OT
          var color_map = {1: 1, 2: 2, 3: 14, 4: 15};
          drawer_material = getMaterial(color_map[c] || c);
        }
        
        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      function setFence(c) {
        fence_color = c;
        if (fence_color)
          fence_material = getMaterial(c);

        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      function setMoving2(c) {
        moving2_color = c;
        if (moving2_color) {
          if (moving3_color && moving3_position == 1)
            moving2_position = 2;
          else
            moving2_position = 1;

          moving2_material = getMaterial(c);
          
          // 좌우 각각 부착형 서랍과 상호 배타
          if (moving2_position == 1) {
            // 좌측에 부착형 서랍이 있으면 취소
            attach1_left_color = 0;
            attach2_left_color = 0;
            attach3_left_color = 0;
          } else {
            // 우측에 부착형 서랍이 있으면 취소
            attach1_right_color = 0;
            attach2_right_color = 0;
            attach3_right_color = 0;
          }
        }

        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      function setMoving3(c) {
        moving3_color = c;

        if (checkCollision()) {
          moving3_color = 0;
          return;
        }

        if (moving3_color) {
          if (moving2_color && moving2_position == 1)
            moving3_position = 2;
          else
            moving3_position = 1;

          moving3_material = getMaterial(c);
          
          // 좌우 각각 부착형 서랍과 상호 배타
          if (moving3_position == 1) {
            // 좌측에 부착형 서랍이 있으면 취소
            attach1_left_color = 0;
            attach2_left_color = 0;
            attach3_left_color = 0;
          } else {
            // 우측에 부착형 서랍이 있으면 취소
            attach1_right_color = 0;
            attach2_right_color = 0;
            attach3_right_color = 0;
          }
        }

        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      function setDeskArray(n) {
        num_desk = n;

        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      function setDeskOpposite(distance) {
        opposite_desk_distance = distance;
        // UI 업데이트
        var menuText;
        if (distance == 0) {
          menuText = "복사 안함";
        } else if (distance == 3600) {
          menuText = "거리 3600";
        } else if (distance == -1030) {
          menuText = "거리 -1030";
        } else if (distance == -2400) {
          menuText = "거리 -2400";
        } else {
          menuText = "복사 안함";
        }
        $(".swiper-slide").filter(function() {
          return $(this).find(".menu_title").text().trim().includes("책상") && $(this).find(".menu_title").text().trim().includes("맞은편");
        }).find(".menu_sel_text").text(menuText);

        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      // ㄱ자 하부 서랍 타입 선택 - 좌측 (0: 없음, 1: 부착서랍1단, 2: 부착서랍2단, 3: 본체함, 4: 이동서랍2단, 5: 이동서랍3단)
      function setGiyeokDrawerTypeLeft(type) {
        giyeok_drawer_type_left = type;
        if (type == 0) {
          // 모든 좌측 서랍 해제
          giyeok_attach1_left_color = 0;
          giyeok_attach2_left_color = 0;
          giyeok_attach3_left_color = 0;
          giyeok_moving2_left_color = 0;
          giyeok_moving3_left_color = 0;
          $("#giyeok-drawer-color-left").hide();
          // 메뉴 텍스트 업데이트
          $(".swiper-slide").has("#giyeok-drawer-type-left").find(".menu_sel_text").text("없음");
        } else {
          // 색상 선택 메뉴 표시
          $("#giyeok-drawer-color-left").show();
          // 타입 선택 메뉴는 숨기지 않음 (같은 menu_all_list 안에 있으므로)
        }
        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      // ㄱ자 하부 서랍 색상 선택 - 좌측 (선택된 타입 하나만 표시)
      function setGiyeokDrawerColorLeft(c) {
        // 모든 좌측 서랍 초기화
        giyeok_attach1_left_color = 0;
        giyeok_attach2_left_color = 0;
        giyeok_attach3_left_color = 0;
        giyeok_moving2_left_color = 0;
        giyeok_moving3_left_color = 0;
        giyeok_attach1_material = null;
        giyeok_attach2_material = null;
        giyeok_attach3_material = null;
        giyeok_moving2_material = null;
        giyeok_moving3_material = null;
        
        var typeNames = ["", "부착서랍1단", "부착서랍2단", "본체함", "이동서랍2단", "이동서랍3단"];
        var colorNames = ["없음", "화이트", "블랙", "그레이", "", "", "", "", "밝은우드", "중간우드", "월넛우드", "라이트그레이", "", "", "오렌지", "", "레몬"];
        
        if (c == 0) {
          $(".swiper-slide").has("#giyeok-drawer-type-left").find(".menu_sel_text").text("없음");
        } else {
          // 선택된 타입에만 색상 설정
          var material = getMaterial(c);
          
          if (giyeok_drawer_type_left == 1) {
            giyeok_attach1_left_color = c;
            giyeok_attach1_material = material;
          } else if (giyeok_drawer_type_left == 2) {
            giyeok_attach2_left_color = c;
            giyeok_attach2_material = material;
          } else if (giyeok_drawer_type_left == 3) {
            giyeok_attach3_left_color = c;
            giyeok_attach3_material = material;
          } else if (giyeok_drawer_type_left == 4) {
            giyeok_moving2_left_color = c;
            giyeok_moving2_material = material;
          } else if (giyeok_drawer_type_left == 5) {
            giyeok_moving3_left_color = c;
            giyeok_moving3_material = material;
          }
          
          var colorName = colorNames[c] || "색상" + c;
          $(".swiper-slide").has("#giyeok-drawer-type-left").find(".menu_sel_text").text(typeNames[giyeok_drawer_type_left] + " " + colorName);
        }
        $(".swiper-slide").has("#giyeok-drawer-type-left").find(".menu_all_list").fadeOut();
        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      // ㄱ자 하부 서랍 타입 선택 - 우측
      function setGiyeokDrawerTypeRight(type) {
        giyeok_drawer_type_right = type;
        if (type == 0) {
          // 모든 우측 서랍 해제
          giyeok_attach1_right_color = 0;
          giyeok_attach2_right_color = 0;
          giyeok_attach3_right_color = 0;
          giyeok_moving2_right_color = 0;
          giyeok_moving3_right_color = 0;
          $("#giyeok-drawer-color-right").hide();
          // 메뉴 텍스트 업데이트
          $(".swiper-slide").has("#giyeok-drawer-type-right").find(".menu_sel_text").text("없음");
        } else {
          // 색상 선택 메뉴 표시
          $("#giyeok-drawer-color-right").show();
        }
        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      // ㄱ자 하부 서랍 색상 선택 - 우측 (선택된 타입 하나만 표시)
      function setGiyeokDrawerColorRight(c) {
        // 모든 우측 서랍 초기화
        giyeok_attach1_right_color = 0;
        giyeok_attach2_right_color = 0;
        giyeok_attach3_right_color = 0;
        giyeok_moving2_right_color = 0;
        giyeok_moving3_right_color = 0;
        giyeok_attach1_material = null;
        giyeok_attach2_material = null;
        giyeok_attach3_material = null;
        giyeok_moving2_material = null;
        giyeok_moving3_material = null;
        
        var typeNames = ["", "부착서랍1단", "부착서랍2단", "본체함", "이동서랍2단", "이동서랍3단"];
        var colorNames = ["없음", "화이트", "블랙", "그레이", "", "", "", "", "밝은우드", "중간우드", "월넛우드", "라이트그레이", "", "", "오렌지", "", "레몬"];
        
        if (c == 0) {
          $(".swiper-slide").has("#giyeok-drawer-type-right").find(".menu_sel_text").text("없음");
        } else {
          // 선택된 타입에만 색상 설정
          var material = getMaterial(c);
          
          if (giyeok_drawer_type_right == 1) {
            giyeok_attach1_right_color = c;
            giyeok_attach1_material = material;
          } else if (giyeok_drawer_type_right == 2) {
            giyeok_attach2_right_color = c;
            giyeok_attach2_material = material;
          } else if (giyeok_drawer_type_right == 3) {
            giyeok_attach3_right_color = c;
            giyeok_attach3_material = material;
          } else if (giyeok_drawer_type_right == 4) {
            giyeok_moving2_right_color = c;
            giyeok_moving2_material = material;
          } else if (giyeok_drawer_type_right == 5) {
            giyeok_moving3_right_color = c;
            giyeok_moving3_material = material;
          }
          
          var colorName = colorNames[c] || "색상" + c;
          $(".swiper-slide").has("#giyeok-drawer-type-right").find(".menu_sel_text").text(typeNames[giyeok_drawer_type_right] + " " + colorName);
        }
        $(".swiper-slide").has("#giyeok-drawer-type-right").find(".menu_all_list").fadeOut();
        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      function setOppositeKeepSides(keep) {
        opposite_keep_sides = keep;

        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      function setShelfDepth(d) {
        shelf_depth = d;
        // 선반 깊이를 360으로 변경할 때, 현재 방향이 안쪽(1)이면 자동으로 바깥쪽(0)으로 변경
        if (d == 360 && shelf_direction == 1) {
          shelf_direction = 0;
          // UI 업데이트: 선반 방향 표시를 "바깥쪽"으로 변경
          updateShelfDirectionUI();
        }
        // 선반 깊이를 200으로 설정하고 방향이 안쪽일 때는 상부 옵션 해제
        if (d == 200 && shelf_direction == 1) {
          storage_sliding1_color = 0;
          storage_sliding2_color = 0;
          storage_flap_color = 0;
          storage_flapstay_color = 0;
        }
        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      // 부착형 서랍 1단 - 좌측 (좌측에는 1단, 2단, 본체함, 이동서랍 2단, 3단 중 하나만 선택 가능)
      function setAttach1Left(c) {
        attach1_left_color = c;
        if (attach1_left_color) {
          // 좌측에서 다른 옵션들 자동 해제
          attach2_left_color = 0;
          attach3_left_color = 0;
          // 좌측에 이동서랍이 있으면 취소
          if (moving2_color && moving2_position == 1) {
            moving2_color = 0;
          }
          if (moving3_color && moving3_position == 1) {
            moving3_color = 0;
          }
          attach1_material = getMaterial(c);
        }
        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      // 부착형 서랍 1단 - 우측 (우측에는 1단, 2단, 본체함, 이동서랍 2단, 3단 중 하나만 선택 가능)
      function setAttach1Right(c) {
        attach1_right_color = c;
        if (attach1_right_color) {
          // 우측에서 다른 옵션들 자동 해제
          attach2_right_color = 0;
          attach3_right_color = 0;
          // 우측에 이동서랍이 있으면 취소
          if (moving2_color && moving2_position == 2) {
            moving2_color = 0;
          }
          if (moving3_color && moving3_position == 2) {
            moving3_color = 0;
          }
          attach1_material = getMaterial(c);
        }
        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      // 부착형 서랍 2단 - 좌측 (좌측에는 1단, 2단, 본체함, 이동서랍 2단, 3단 중 하나만 선택 가능)
      function setAttach2Left(c) {
        attach2_left_color = c;
        if (attach2_left_color) {
          // 좌측에서 다른 옵션들 자동 해제
          attach1_left_color = 0;
          attach3_left_color = 0;
          // 좌측에 이동서랍이 있으면 취소
          if (moving2_color && moving2_position == 1) {
            moving2_color = 0;
          }
          if (moving3_color && moving3_position == 1) {
            moving3_color = 0;
          }
          attach2_material = getMaterial(c);
        }
        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      // 부착형 서랍 2단 - 우측 (우측에는 1단, 2단, 본체함, 이동서랍 2단, 3단 중 하나만 선택 가능)
      function setAttach2Right(c) {
        attach2_right_color = c;
        if (attach2_right_color) {
          // 우측에서 다른 옵션들 자동 해제
          attach1_right_color = 0;
          attach3_right_color = 0;
          // 우측에 이동서랍이 있으면 취소
          if (moving2_color && moving2_position == 2) {
            moving2_color = 0;
          }
          if (moving3_color && moving3_position == 2) {
            moving3_color = 0;
          }
          attach2_material = getMaterial(c);
        }
        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      // 본체함 - 좌측 (좌측에는 1단, 2단, 본체함, 이동서랍 2단, 3단 중 하나만 선택 가능)
      function setAttach3Left(c) {
        attach3_left_color = c;
        if (attach3_left_color) {
          // 좌측에서 다른 옵션들 자동 해제
          attach1_left_color = 0;
          attach2_left_color = 0;
          // 좌측에 이동서랍이 있으면 취소
          if (moving2_color && moving2_position == 1) {
            moving2_color = 0;
          }
          if (moving3_color && moving3_position == 1) {
            moving3_color = 0;
          }
          attach3_material = getMaterial(c);
        }
        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      // 본체함 - 우측 (우측에는 1단, 2단, 본체함, 이동서랍 2단, 3단 중 하나만 선택 가능)
      function setAttach3Right(c) {
        attach3_right_color = c;
        if (attach3_right_color) {
          // 우측에서 다른 옵션들 자동 해제
          attach1_right_color = 0;
          attach2_right_color = 0;
          // 우측에 이동서랍이 있으면 취소
          if (moving2_color && moving2_position == 2) {
            moving2_color = 0;
          }
          if (moving3_color && moving3_position == 2) {
            moving3_color = 0;
          }
          attach3_material = getMaterial(c);
        }
        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      function setStorageSliding1(c) {
        // 선반 깊이 200이고 방향이 안쪽일 때는 상부 옵션 선택 불가
        if (c > 0 && shelf_depth == 200 && shelf_direction == 1) {
          storage_sliding1_color = 0;
          alert('선반 깊이 200이고 방향이 안쪽일 때는 상부 옵션을 선택할 수 없습니다.');
          updateScene();
          render();
          return;
        }
        storage_sliding1_color = c;
        if (storage_sliding1_color) {
          storage_sliding1_material = getMaterial(c);
          // 다른 수납 도어 선택 취소
          storage_sliding2_color = 0;
          storage_flap_color = 0;
          storage_flapstay_color = 0;
          // 수직부재가 1400 또는 1860이 아니면 수직 1860으로 변경
          if (vertical_length_idx != 3 && vertical_length_idx != 4) {
            setVertical(4); // 1860
            // UI 업데이트: 수직부재 메뉴 텍스트 업데이트
            $(".swiper-slide").filter(function() {
              return $(this).find(".menu_title").text().trim() === "수직부재";
            }).find(".menu_sel_text").text("1860");
          }
          // 선반 깊이를 360으로 변경 (항상)
          if (shelf_depth != 360) {
            setShelfDepth(360);
            // UI 업데이트: 선반깊이 메뉴 텍스트 업데이트
            $(".swiper-slide").filter(function() {
              return $(this).find(".menu_title").text().trim() === "선반깊이";
            }).find(".menu_sel_text").text("360");
          }
          // 선반 수를 3개로 변경 (항상)
          if (shelf_num != 3) {
            setShelfNum(3);
            // UI 업데이트: 선반갯수 메뉴 텍스트 업데이트
            $(".swiper-slide").filter(function() {
              return $(this).find(".menu_title").text().trim() === "선반갯수";
            }).find(".menu_sel_text").text("3");
          }
        }
        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      function setStorageSliding2(c) {
        // 선반 깊이 200이고 방향이 안쪽일 때는 상부 옵션 선택 불가
        if (c > 0 && shelf_depth == 200 && shelf_direction == 1) {
          storage_sliding2_color = 0;
          alert('선반 깊이 200이고 방향이 안쪽일 때는 상부 옵션을 선택할 수 없습니다.');
          updateScene();
          render();
          return;
        }
        storage_sliding2_color = c;
        if (storage_sliding2_color) {
          storage_sliding2_material = getMaterial(c);
          // 다른 수납 도어 선택 취소
          storage_sliding1_color = 0;
          storage_flap_color = 0;
          storage_flapstay_color = 0;
          // 수직부재가 1400 또는 1860이 아니면 수직 1860으로 변경
          if (vertical_length_idx != 3 && vertical_length_idx != 4) {
            setVertical(4); // 1860
            // UI 업데이트: 수직부재 메뉴 텍스트 업데이트
            $(".swiper-slide").filter(function() {
              return $(this).find(".menu_title").text().trim() === "수직부재";
            }).find(".menu_sel_text").text("1860");
          }
          // 선반 깊이를 360으로 변경 (항상)
          if (shelf_depth != 360) {
            setShelfDepth(360);
            // UI 업데이트: 선반깊이 메뉴 텍스트 업데이트
            $(".swiper-slide").filter(function() {
              return $(this).find(".menu_title").text().trim() === "선반깊이";
            }).find(".menu_sel_text").text("360");
          }
          // 선반 수를 3개로 변경 (항상)
          if (shelf_num != 3) {
            setShelfNum(3);
            // UI 업데이트: 선반갯수 메뉴 텍스트 업데이트
            $(".swiper-slide").filter(function() {
              return $(this).find(".menu_title").text().trim() === "선반갯수";
            }).find(".menu_sel_text").text("3");
          }
        }
        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      function setStorageFlap(c) {
        // 선반 깊이 200이고 방향이 안쪽일 때는 상부 옵션 선택 불가
        if (c > 0 && shelf_depth == 200 && shelf_direction == 1) {
          storage_flap_color = 0;
          alert('선반 깊이 200이고 방향이 안쪽일 때는 상부 옵션을 선택할 수 없습니다.');
          updateScene();
          render();
          return;
        }
        storage_flap_color = c;
        if (storage_flap_color) {
          storage_flap_material = getMaterial(c);
          // 다른 수납 도어 선택 취소
          storage_sliding1_color = 0;
          storage_sliding2_color = 0;
          storage_flapstay_color = 0;
          // 수직부재가 1400 또는 1860이 아니면 수직 1860으로 변경
          if (vertical_length_idx != 3 && vertical_length_idx != 4) {
            setVertical(4); // 1860
            // UI 업데이트: 수직부재 메뉴 텍스트 업데이트
            $(".swiper-slide").filter(function() {
              return $(this).find(".menu_title").text().trim() === "수직부재";
            }).find(".menu_sel_text").text("1860");
          }
          // 선반 깊이를 360으로 변경 (항상)
          if (shelf_depth != 360) {
            setShelfDepth(360);
            // UI 업데이트: 선반깊이 메뉴 텍스트 업데이트
            $(".swiper-slide").filter(function() {
              return $(this).find(".menu_title").text().trim() === "선반깊이";
            }).find(".menu_sel_text").text("360");
          }
          // 선반 수를 3개로 변경 (항상)
          if (shelf_num != 3) {
            setShelfNum(3);
            // UI 업데이트: 선반갯수 메뉴 텍스트 업데이트
            $(".swiper-slide").filter(function() {
              return $(this).find(".menu_title").text().trim() === "선반갯수";
            }).find(".menu_sel_text").text("3");
          }
        }
        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      function setStorageFlapStay(c) {
        // 선반 깊이 200이고 방향이 안쪽일 때는 상부 옵션 선택 불가
        if (c > 0 && shelf_depth == 200 && shelf_direction == 1) {
          storage_flapstay_color = 0;
          alert('선반 깊이 200이고 방향이 안쪽일 때는 상부 옵션을 선택할 수 없습니다.');
          updateScene();
          render();
          return;
        }
        storage_flapstay_color = c;
        if (storage_flapstay_color) {
          storage_flapstay_material = getMaterial(c);
          // 다른 수납 도어 선택 취소
          storage_sliding1_color = 0;
          storage_sliding2_color = 0;
          storage_flap_color = 0;
          // 수직부재가 1400 또는 1860이 아니면 수직 1860으로 변경
          if (vertical_length_idx != 3 && vertical_length_idx != 4) {
            setVertical(4); // 1860
            // UI 업데이트: 수직부재 메뉴 텍스트 업데이트
            $(".swiper-slide").filter(function() {
              return $(this).find(".menu_title").text().trim() === "수직부재";
            }).find(".menu_sel_text").text("1860");
          }
          // 선반 깊이를 360으로 변경 (항상)
          if (shelf_depth != 360) {
            setShelfDepth(360);
            // UI 업데이트: 선반깊이 메뉴 텍스트 업데이트
            $(".swiper-slide").filter(function() {
              return $(this).find(".menu_title").text().trim() === "선반깊이";
            }).find(".menu_sel_text").text("360");
          }
          // 선반 수를 3개로 변경 (항상)
          if (shelf_num != 3) {
            setShelfNum(3);
            // UI 업데이트: 선반갯수 메뉴 텍스트 업데이트
            $(".swiper-slide").filter(function() {
              return $(this).find(".menu_title").text().trim() === "선반갯수";
            }).find(".menu_sel_text").text("3");
          }
        }
        updateScene();
        render();
      }

      function moveStorageUp() {
        // 수납 도어가 선택되어 있고, 수직부재가 1400 또는 1860이어야 함
        if ((storage_sliding1_color == 0 && storage_sliding2_color == 0 && storage_flap_color == 0 && storage_flapstay_color == 0) || 
            (vertical_length_idx != 3 && vertical_length_idx != 4)) {
          return;
        }
        
        var max_up = 0;
        var max_down = 0;
        
        switch (vertical_length_idx) {
          case 3: // 1400
            max_up = 10;
            max_down = 10;
            break;
          case 4: // 1860
            max_up = 12;
            max_down = 12;
            break;
          default:
            return;
        }
        
        // 위로 이동 가능한지 확인
        if (storage_y_offset < max_up) {
          storage_y_offset++;
          updateScene();
          render();
        }
      }

      function moveStorageDown() {
        // 수납 도어가 선택되어 있고, 수직부재가 1400 또는 1860이어야 함
        if ((storage_sliding1_color == 0 && storage_sliding2_color == 0 && storage_flap_color == 0 && storage_flapstay_color == 0) || 
            (vertical_length_idx != 3 && vertical_length_idx != 4)) {
          return;
        }
        
        var max_up = 0;
        var max_down = 0;
        
        switch (vertical_length_idx) {
          case 3: // 1400
            max_up = 10;
            max_down = 10;
            break;
          case 4: // 1860
            max_up = 12;
            max_down = 12;
            break;
          default:
            return;
        }
        
        // 아래로 이동 가능한지 확인
        if (storage_y_offset > -max_down) {
          storage_y_offset--;
          updateScene();
          render();
        }
      }

      function setPartiVerLHeight(h) {
        parti_ver_L_height = h;
        // skipSceneUpdate가 true일 때는 자동 색상 설정을 하지 않음 (코드 로드 중일 때)
        if (!skipSceneUpdate && parti_ver_L_height > 0 && parti_ver_L_color == 0) {
          parti_ver_L_color = 3; // 기본값: 그레이
        }
        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      function setPartiVerLColor(c) {
        parti_ver_L_color = c;
        if (parti_ver_L_color > 0) {
          parti_ver_L_material = getMaterial(c);
        } else {
          parti_ver_L_material = null;
        }
        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      function setPartiVerRHeight(h) {
        parti_ver_R_height = h;
        // skipSceneUpdate가 true일 때는 자동 색상 설정을 하지 않음 (코드 로드 중일 때)
        if (!skipSceneUpdate && parti_ver_R_height > 0 && parti_ver_R_color == 0) {
          parti_ver_R_color = 3; // 기본값: 그레이
        }
        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      function setPartiVerRColor(c) {
        parti_ver_R_color = c;
        if (parti_ver_R_color > 0) {
          parti_ver_R_material = getMaterial(c);
        } else {
          parti_ver_R_material = null;
        }
        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      function setPartiHolBWidth(w) {
        parti_hol_B_width = w;
        // skipSceneUpdate가 true일 때는 자동 색상 설정을 하지 않음 (코드 로드 중일 때)
        if (!skipSceneUpdate && parti_hol_B_width > 0 && parti_hol_B_color == 0) {
          parti_hol_B_color = 3; // 기본값: 그레이
        }
        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      function setPartiHolBColor(c) {
        parti_hol_B_color = c;
        if (parti_hol_B_color > 0) {
          parti_hol_B_material = getMaterial(c);
        } else {
          parti_hol_B_material = null;
        }
        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      function setPartiVerMHeight(h) {
        parti_ver_M_height = h;
        // skipSceneUpdate가 true일 때는 자동 색상 설정을 하지 않음 (코드 로드 중일 때)
        if (!skipSceneUpdate && parti_ver_M_height > 0 && parti_ver_M_color == 0) {
          parti_ver_M_color = 3; // 기본값: 그레이
        }
        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }

      function setPartiVerMColor(c) {
        parti_ver_M_color = c;
        if (parti_ver_M_color > 0) {
          parti_ver_M_material = getMaterial(c);
        } else {
          parti_ver_M_material = null;
        }
        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }
      
      function setPartiZAlignFront(align) {
        parti_z_align_front = align;
        
        // 메뉴 UI 업데이트
        var menuText = align == 1 ? "하부옵션 전면" : "기본 위치";
        $("#parti-z-align-menu .menu_sel_text").text(menuText);
        
        if (!skipSceneUpdate) {
          updateScene();
          render();
        }
      }
      
      // URL 업데이트 디바운싱을 위한 타이머
      var urlUpdateTimer = null;
      
      // URL 쿼리 파라미터 업데이트 함수
      function updateURL(replaceState) {
        if (skipURLUpdate) return; // loadProductFromCode에서 호출된 경우 스킵
        
        // 디바운싱: 300ms 이내의 연속 호출은 마지막 호출만 실행
        if (urlUpdateTimer) {
          clearTimeout(urlUpdateTimer);
        }
        
        urlUpdateTimer = setTimeout(function() {
          var code = generateProductCode();
          var url = new URL(window.location.href);
          var currentCode = url.searchParams.get('code');
          
          // 코드가 실제로 변경된 경우에만 URL 업데이트
          if (currentCode !== code) {
            url.searchParams.set('code', code);
            // replaceState가 명시적으로 false가 아니면 히스토리 교체 (기본값: true)
            // 이렇게 하면 히스토리가 계속 쌓이지 않음
            if (replaceState === false) {
              window.history.pushState({code: code}, '', url.toString());
            } else {
              window.history.replaceState({code: code}, '', url.toString());
            }
          }
          
          urlUpdateTimer = null;
        }, 300); // 300ms 디바운싱
      }
      
      // URL에서 코드 읽기
      function loadCodeFromURL() {
        var urlParams = new URLSearchParams(window.location.search);
        var code = urlParams.get('code');
        if (code) {
          loadProductFromCode(code);
          return true;
        }
        return false;
      }
      
      // 브라우저 뒤로가기/앞으로가기 지원
      window.addEventListener('popstate', function(event) {
        // popstate 이벤트 발생 시 URL에서 코드 읽기
        skipURLUpdate = true; // URL 업데이트 방지 (이미 URL이 변경되었으므로)
        
        if (event.state && event.state.code) {
          // state에 코드가 있으면 사용
          loadProductFromCode(event.state.code);
        } else {
          // state가 없으면 URL에서 직접 읽기
          var urlParams = new URLSearchParams(window.location.search);
          var code = urlParams.get('code');
          if (code) {
            loadProductFromCode(code);
          }
        }
        
        skipURLUpdate = false;
      });
      
      // 상품코드 복사 함수
      function copyProductCode() {
        var productCodeInput = document.getElementById("product_code_input");
        if (productCodeInput) {
          productCodeInput.select();
          productCodeInput.setSelectionRange(0, 99999); // 모바일에서도 작동하도록
          
          try {
            document.execCommand('copy');
            // 복사 성공 피드백
            var copyBtn = document.getElementById("copy_code_btn");
            if (copyBtn) {
              var originalTitle = copyBtn.getAttribute('title');
              copyBtn.setAttribute('title', '복사되었습니다!');
              setTimeout(function() {
                copyBtn.setAttribute('title', originalTitle || '상품코드 복사');
              }, 2000);
            }
          } catch (err) {
            // Clipboard API 사용 (최신 브라우저)
            if (navigator.clipboard && navigator.clipboard.writeText) {
              navigator.clipboard.writeText(productCodeInput.value).then(function() {
                var copyBtn = document.getElementById("copy_code_btn");
                if (copyBtn) {
                  var originalTitle = copyBtn.getAttribute('title');
                  copyBtn.setAttribute('title', '복사되었습니다!');
                  setTimeout(function() {
                    copyBtn.setAttribute('title', originalTitle || '상품코드 복사');
                  }, 2000);
                }
              }).catch(function(err) {
                console.error('복사 실패:', err);
                alert('상품코드 복사에 실패했습니다.');
              });
            } else {
              alert('상품코드를 복사할 수 없습니다. 브라우저를 업데이트해주세요.');
            }
          }
        }
      }
      
      // URL 복사 함수
      function copyProductURL() {
        var url = window.location.href;
        
        try {
          // Clipboard API 사용 (최신 브라우저)
          if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(url).then(function() {
              var copyUrlBtn = document.getElementById("copy_url_btn");
              if (copyUrlBtn) {
                var originalTitle = copyUrlBtn.getAttribute('title');
                copyUrlBtn.setAttribute('title', 'URL이 복사되었습니다!');
                setTimeout(function() {
                  copyUrlBtn.setAttribute('title', originalTitle || 'URL 복사');
                }, 2000);
              }
            }).catch(function(err) {
              console.error('URL 복사 실패:', err);
              // fallback: execCommand 사용
              fallbackCopyURL(url);
            });
          } else {
            // fallback: execCommand 사용
            fallbackCopyURL(url);
          }
        } catch (err) {
          fallbackCopyURL(url);
        }
      }
      
      // URL 복사 fallback 함수
      function fallbackCopyURL(url) {
        var textarea = document.createElement('textarea');
        textarea.value = url;
        textarea.style.position = 'fixed';
        textarea.style.opacity = '0';
        document.body.appendChild(textarea);
        textarea.select();
        textarea.setSelectionRange(0, 99999);
        
        try {
          document.execCommand('copy');
          var copyUrlBtn = document.getElementById("copy_url_btn");
          if (copyUrlBtn) {
            var originalTitle = copyUrlBtn.getAttribute('title');
            copyUrlBtn.setAttribute('title', 'URL이 복사되었습니다!');
            setTimeout(function() {
              copyUrlBtn.setAttribute('title', originalTitle || 'URL 복사');
            }, 2000);
          }
        } catch (err) {
          alert('URL 복사에 실패했습니다. 브라우저를 업데이트해주세요.');
        } finally {
          document.body.removeChild(textarea);
        }
      }

      // ㄱ자 하부 서랍 생성 헬퍼 함수
      // targetGroup이 제공되면 그룹에 추가하고, 그렇지 않으면 씬에 직접 추가
      function createGiyeokDrawer(drawerType, drawerColor, side, deskOffsetX, giyeokAttachTopY, giyeokInnerX, giyeokInnerZ, rotationY, targetGroup) {
        if (!drawerColor) return null;
        
        var model = null;
        var geometry = null;
        var height = 0;
        
        // 타입별 모델과 크기 설정
        if (drawerType == 1) {
          model = attach1_model;
          geometry = new THREE.BoxBufferGeometry(300, 160, 400);
          height = 160;
        } else if (drawerType == 2) {
          model = attach2_model;
          geometry = new THREE.BoxBufferGeometry(300, 500, 400);
          height = 500;
        } else if (drawerType == 3) {
          model = attach3_model;
          geometry = new THREE.BoxBufferGeometry(300, 500, 400);
          height = 500;
        } else if (drawerType == 4) {
          model = attach2_model; // moving2는 attach2 재사용
          geometry = new THREE.BoxBufferGeometry(300, 585, 400);
          height = 585;
        } else if (drawerType == 5) {
          model = attach3_model; // moving3는 attach3 재사용
          geometry = new THREE.BoxBufferGeometry(400, 585, 580);
          height = 585;
        }
        
        if (!model && !geometry) return null;
        
        var drawer;
        if (model) {
          drawer = model.clone();
          drawer.traverse(function(child) {
            if (child instanceof THREE.Mesh) {
              child.material = getMaterial(drawerColor);
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });
        } else {
          var material = getMaterial(drawerColor);
          drawer = new THREE.Mesh(geometry, material);
          drawer.castShadow = true;
        }
        
        var yPos = (drawerType == 4 || drawerType == 5) ? height / 2 : giyeokAttachTopY - height / 2;
        drawer.position.set(giyeokInnerX, yPos, giyeokInnerZ);
        drawer.rotation.y = rotationY;
        
        // 그룹이 제공되면 그룹에 추가, 그렇지 않으면 씬에 직접 추가
        if (targetGroup) {
          targetGroup.add(drawer);
        } else {
          scene.add(drawer);
        }
        return drawer;
      }
      
      // 부착형 서랍 생성 헬퍼 함수
      function createAttachDrawer(attachType, attachColor, side, deskOffsetX, attachTopY, legInnerX, zPos) {
        if (!attachColor) return null;
        
        var model = null;
        var geometry = null;
        var height = 0;
        
        if (attachType == 1) {
          model = attach1_model;
          geometry = new THREE.BoxBufferGeometry(300, 160, 400);
          height = 160;
        } else if (attachType == 2) {
          model = attach2_model;
          geometry = new THREE.BoxBufferGeometry(300, 500, 400);
          height = 500;
        } else if (attachType == 3) {
          model = attach3_model;
          geometry = new THREE.BoxBufferGeometry(300, 500, 400);
          height = 500;
        }
        
        if (!model && !geometry) return null;
        
        var attach;
        if (model) {
          attach = model.clone();
          attach.traverse(function(child) {
            if (child instanceof THREE.Mesh) {
              child.material = getMaterial(attachColor);
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });
        } else {
          var material = getMaterial(attachColor);
          attach = new THREE.Mesh(geometry, material);
          attach.castShadow = true;
        }
        
        attach.position.set(deskOffsetX + legInnerX, attachTopY - height / 2, zPos);
        scene.add(attach);
        return attach;
      }
      
      // 반대편 ㄱ자 하부 서랍 생성 헬퍼 함수 (그룹용 - 상대 위치 반환)
      // 그룹에 scale.z = -1이 적용되므로, 원래 위치를 그대로 사용하면 자동으로 미러링됨
      function createOppositeGiyeokDrawer(drawerType, drawerColor, oppositeDeskX, giyeokAttachTopY, oppositeDeskZ, isLeft, targetGroup) {
        if (!drawerColor) return null;
        
        // 그룹 내 상대 위치로 계산 (그룹의 위치는 opposite_desk_offset_x, 0, opposite_desk_z)
        // 원래 책상의 위치 계산과 동일하게 하되, 그룹 중심(0, 0, 0) 기준으로 계산
        // 원래: giyeok_inner_x = desk_offset_x - (board_width - 600) / 2 + 300 - 200 (왼쪽)
        // 그룹 기준: giyeok_inner_x = - (board_width - 600) / 2 + 300 - 200 (왼쪽)
        var giyeok_inner_x = isLeft ? 
          - (board_width - 600) / 2 + 300 - 200 : // 좌측 ㄱ자 우측 끝 -200 (그룹 중심 기준)
          (board_width - 600) / 2 - 300 + 200; // 우측 ㄱ자 좌측 끝 +200 (그룹 중심 기준)
        
        // 원래 위치: giyeok_inner_z = (board_depth + 800) / 2 - 200 + 400
        // 그룹에 scale.z = -1이 적용되므로, 원래 위치를 그대로 사용하면 자동으로 반전됨
        var giyeok_inner_z = (board_depth + 800) / 2 - 200 + 400; // 원래 위치 그대로 사용 (그룹 중심 기준)
        var rotationY = isLeft ? Math.PI / 2 : -Math.PI / 2;
        
        return createGiyeokDrawer(drawerType, drawerColor, isLeft ? 'left' : 'right', 0, giyeokAttachTopY, giyeok_inner_x, giyeok_inner_z, rotationY, targetGroup);
      }
      
      // 반대편 부착형 서랍 생성 헬퍼 함수 (그룹용 - 상대 위치 반환)
      function createOppositeAttachDrawerForGroup(attachType, attachColor, leg_inner_x, attach_top_y, attach_z) {
        if (!attachColor) return null;
        
        var model = null;
        var geometry = null;
        var height = 0;
        
        if (attachType == 1) {
          model = attach1_model;
          geometry = new THREE.BoxBufferGeometry(300, 160, 400);
          height = 160;
        } else if (attachType == 2) {
          model = attach2_model;
          geometry = new THREE.BoxBufferGeometry(300, 500, 400);
          height = 500;
        } else if (attachType == 3) {
          model = attach3_model;
          geometry = new THREE.BoxBufferGeometry(300, 500, 400);
          height = 500;
        }
        
        if (!model && !geometry) return null;
        
        var attach;
        if (model) {
          attach = model.clone();
          attach.traverse(function(child) {
            if (child instanceof THREE.Mesh) {
              child.material = getMaterial(attachColor);
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });
        } else {
          var material = getMaterial(attachColor);
          attach = new THREE.Mesh(geometry, material);
          attach.castShadow = true;
        }
        
        // 상대 위치로 설정 (그룹 내에서의 위치)
        attach.position.set(leg_inner_x, attach_top_y - height / 2, attach_z);
        return attach;
      }
      
      // 반대편 부착형 서랍 생성 헬퍼 함수
      // 거울 반사: isLeft가 true면 우측에, false면 좌측에 배치 (원래와 반대)
      function createOppositeAttachDrawer(attachType, attachColor, oppositeDeskOffsetX, oppositeDeskZ, isLeft) {
        if (!attachColor) return null;
        
        var attach_top_y = frame_length + board_thickness - 60;
        var leg_inner_x;
        // 거울 반사: isLeft가 true면 원래 좌측이었으므로 반대편에서는 우측에 배치
        if (isLeft) {
          leg_inner_x = (board_width - frame_thickness) / 2 - frame_thickness / 2 - 155; // 우측
        } else {
          leg_inner_x = - (board_width - frame_thickness) / 2 + frame_thickness / 2 + 155; // 좌측
        }
        
        var model = null;
        var geometry = null;
        var height = 0;
        
        if (attachType == 1) {
          model = attach1_model;
          geometry = new THREE.BoxBufferGeometry(300, 160, 400);
          height = 160;
        } else if (attachType == 2) {
          model = attach2_model;
          geometry = new THREE.BoxBufferGeometry(300, 500, 400);
          height = 500;
        } else if (attachType == 3) {
          model = attach3_model;
          geometry = new THREE.BoxBufferGeometry(300, 500, 400);
          height = 500;
        }
        
        if (!model && !geometry) return null;
        
        var attach;
        if (model) {
          attach = model.clone();
          attach.traverse(function(child) {
            if (child instanceof THREE.Mesh) {
              child.material = getMaterial(attachColor);
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });
        } else {
          var material = getMaterial(attachColor);
          attach = new THREE.Mesh(geometry, material);
          attach.castShadow = true;
        }
        
        // 반대편 앞뒤 반전: Z 위치를 반대로 계산 (수직부재 쪽 기준)
        attach.position.set(oppositeDeskOffsetX + leg_inner_x, attach_top_y - height / 2, oppositeDeskZ + (board_depth / 2 - 200));
        scene.add(attach);
        return attach;
      }

      function checkCollision() {
        // Rule: L-module and Mini-drawer collision
        if (giyeok_position && drawer_color && (giyeok_position == drawer_position)) {
          alert("ㄱ자 모듈과 미니서랍이 겹칩니다.");
          return true;
        }

        // Rule: Width < 2000 implies collision between L-module and Mat
        if (giyeok_position && desk_mat_color && (board_width < 2000)) {
          alert("폭이 2000 미만일 경우 데스크매트와 ㄱ자 모듈이 겹칩니다.");
          return true;
        }

        // Rule: Width < 1500 implies collision between Mat and Mini-drawer
        if (desk_mat_color && drawer_color && (board_width < 1500)) {
          alert("데스크매트와 미니서랍이 겹칩니다.");
          return true;
        }

        // Rule: Fence and 3-drawer collision
        if (fence_color && moving3_color) {
          alert("하부가림막과 3단 서랍이 겹칩니다.");
          return true;
        }

        // Rule: Square leg allowed only at depth 600
        if (board_depth != 600 && is_mium) {
          alert("ㅁ다리는 상판깊이가 600일 때만 가능합니다.");
          return true;
        }

        return false;
      }

      function adjustShlefNum() {
        var max_shelf_num = 0;

        // Rule 5: Shelf number constraints based on vertical height
        switch (vertical_length) {
          case 0:
            shelf_num = 0;
            return;
          case 646:
            max_shelf_num = 3;
            break;
          case 925:
            max_shelf_num = 4; // Updated from 5 to 4 based on CSV Rule 5
            break;
          case 1400:
            max_shelf_num = 5; // New rule for 1400 height
            break;
          case 1860:
            max_shelf_num = 7;
            break;
          default:
            max_shelf_num = 0;
            break;
        }

        if (max_shelf_num < shelf_num)
          shelf_num = max_shelf_num;

        if ((vertical_length > 0) && (shelf_num == 0))
          shelf_num = 1;
      }

      // 숫자를 한 글자 문자로 변환 (0-9는 숫자, 10-35는 알파벳)
      // 0-9: '0'-'9', 10-35: 'a'-'z'
      function numberToSingleChar(n) {
        if (n === undefined || n === null) n = 0;
        if (n < 10) {
          return n.toString();
        } else if (n < 36) {
          return String.fromCharCode(97 + (n - 10)); // 'a' = 97
        } else {
          return '0'; // 범위 초과 시 기본값
        }
      }

      // 한 글자 문자를 숫자로 변환 ('0'-'9'는 0-9, 'a'-'z'는 10-35)
      function singleCharToNumber(c) {
        if (!c) return 0;
        var charCode = c.charCodeAt(0);
        if (charCode >= 48 && charCode <= 57) { // '0'-'9'
          return charCode - 48;
        } else if (charCode >= 97 && charCode <= 122) { // 'a'-'z'
          return 10 + (charCode - 97);
        } else if (charCode >= 65 && charCode <= 90) { // 'A'-'Z' (대문자도 지원)
          return 10 + (charCode - 65);
        } else {
          return 0; // 알 수 없는 문자는 0
        }
      }

      function generateProductCode() {
        var ret;
        var sub_str;

        if (is_mium)
          ret = "2";
        else
          ret = "1";
        
        sub_str = board_width_idx.toString();
        ret += sub_str;

        sub_str = board_depth_idx.toString();
        ret += sub_str;

        sub_str = vertical_length_idx.toString();
        ret += sub_str;

        if (vertical_length) {
          sub_str = shelf_num.toString();
          ret += sub_str;
        }
        else
          ret += "0";

        // delimiter
        ret += "-";

        if (shelf_direction)
          ret += "2";
        else
          ret += "1";
          
        // 색상 값은 10 이상일 수 있으므로 알파벳으로 변환
        ret += numberToSingleChar(board_color || 0);

        ret += numberToSingleChar(frame_color || 0);

        ret += numberToSingleChar(vertical_color || 0);

        ret += numberToSingleChar(shelf_board_color || 0);

        // delimiter
        ret += "-";

        ret += numberToSingleChar(shelf_frame_color || 0);

        ret += numberToSingleChar(giyeok_position || 0);

        ret += numberToSingleChar(desk_mat_color || 0);

        ret += numberToSingleChar(drawer_color || 0);

        ret += numberToSingleChar(fence_color || 0);

        // delimiter
        ret += "-";

        // 색상 값은 10 이상일 수 있으므로 알파벳으로 변환
        ret += numberToSingleChar(moving2_color || 0);

        ret += numberToSingleChar(moving3_color || 0);

        sub_str = (num_desk || 1).toString();
        ret += sub_str;

        // 맞은편 배열 거리: 0=복사 안함, 3600=거리 3600, -1030=거리 -1030, -2400=거리 -2400
        // 코드 저장: 0=1, 3600=2, -1030=3, -2400=4
        if (opposite_desk_distance == 0)
          ret += "1";
        else if (opposite_desk_distance == 3600)
          ret += "2";
        else if (opposite_desk_distance == -1030)
          ret += "3";
        else if (opposite_desk_distance == -2400)
          ret += "4";
        else
          ret += "1";

        // 새로운 옵션들 추가 (좌우 각각) - part4에 모두 포함
        // 색상 값은 10 이상일 수 있으므로 알파벳으로 변환
        ret += numberToSingleChar(attach1_left_color || 0);
        ret += numberToSingleChar(attach1_right_color || 0);

        ret += numberToSingleChar(attach2_left_color || 0);
        ret += numberToSingleChar(attach2_right_color || 0);

        ret += numberToSingleChar(attach3_left_color || 0);
        ret += numberToSingleChar(attach3_right_color || 0);

        ret += numberToSingleChar(storage_sliding1_color || 0);

        ret += numberToSingleChar(storage_sliding2_color || 0);

        ret += numberToSingleChar(storage_flap_color || 0);

        ret += numberToSingleChar(storage_flapstay_color || 0);

        // delimiter
        ret += "-";

        // 파티션 옵션들 (높이/넓이 값은 인덱스로 변환)
        // parti_ver_L_height: 0=없음, 1=480, 2=800, 3=1200, 4=1400, 5=1600, 6=1800
        var parti_ver_L_height_idx = 0;
        if (parti_ver_L_height == 480) parti_ver_L_height_idx = 1;
        else if (parti_ver_L_height == 800) parti_ver_L_height_idx = 2;
        else if (parti_ver_L_height == 1200) parti_ver_L_height_idx = 3;
        else if (parti_ver_L_height == 1400) parti_ver_L_height_idx = 4;
        else if (parti_ver_L_height == 1600) parti_ver_L_height_idx = 5;
        else if (parti_ver_L_height == 1800) parti_ver_L_height_idx = 6;
        ret += parti_ver_L_height_idx.toString();

        // 색상 값은 10 이상일 수 있으므로 알파벳으로 변환
        ret += numberToSingleChar(parti_ver_L_color || 0);

        // parti_ver_R_height: 0=없음, 1=480, 2=800, 3=1200, 4=1400, 5=1600, 6=1800
        var parti_ver_R_height_idx = 0;
        if (parti_ver_R_height == 480) parti_ver_R_height_idx = 1;
        else if (parti_ver_R_height == 800) parti_ver_R_height_idx = 2;
        else if (parti_ver_R_height == 1200) parti_ver_R_height_idx = 3;
        else if (parti_ver_R_height == 1400) parti_ver_R_height_idx = 4;
        else if (parti_ver_R_height == 1600) parti_ver_R_height_idx = 5;
        else if (parti_ver_R_height == 1800) parti_ver_R_height_idx = 6;
        ret += parti_ver_R_height_idx.toString();

        ret += numberToSingleChar(parti_ver_R_color || 0);

        // parti_ver_M_height: 0=없음, 1=460, 2=800, 3=1200, 4=1400, 5=1600, 6=1800
        var parti_ver_M_height_idx = 0;
        if (parti_ver_M_height == 460) parti_ver_M_height_idx = 1;
        else if (parti_ver_M_height == 800) parti_ver_M_height_idx = 2;
        else if (parti_ver_M_height == 1200) parti_ver_M_height_idx = 3;
        else if (parti_ver_M_height == 1400) parti_ver_M_height_idx = 4;
        else if (parti_ver_M_height == 1600) parti_ver_M_height_idx = 5;
        else if (parti_ver_M_height == 1800) parti_ver_M_height_idx = 6;
        ret += parti_ver_M_height_idx.toString();

        ret += numberToSingleChar(parti_ver_M_color || 0);

        // parti_hol_B_width: 0=없음, 1=1200, 2=1400, 3=1600, 4=1800
        var parti_hol_B_width_idx = 0;
        if (parti_hol_B_width == 1200) parti_hol_B_width_idx = 1;
        else if (parti_hol_B_width == 1400) parti_hol_B_width_idx = 2;
        else if (parti_hol_B_width == 1600) parti_hol_B_width_idx = 3;
        else if (parti_hol_B_width == 1800) parti_hol_B_width_idx = 4;
        ret += parti_hol_B_width_idx.toString();

        ret += numberToSingleChar(parti_hol_B_color || 0);
        
        // 파티션 Z축 위치 정렬 (책상 깊이 1000 이상일 때만 사용)
        ret += numberToSingleChar(parti_z_align_front || 0);

        // delimiter
        ret += "-";

        // ㄱ자 하부 서랍 옵션들
        ret += numberToSingleChar(giyeok_drawer_type_left || 0);
        
        // 좌측 색상: 타입에 따라 해당 색상 값 사용
        var giyeok_left_color_val = 0;
        if (giyeok_drawer_type_left == 1) {
          giyeok_left_color_val = giyeok_attach1_left_color || 0;
        } else if (giyeok_drawer_type_left == 2) {
          giyeok_left_color_val = giyeok_attach2_left_color || 0;
        } else if (giyeok_drawer_type_left == 3) {
          giyeok_left_color_val = giyeok_attach3_left_color || 0;
        } else if (giyeok_drawer_type_left == 4) {
          giyeok_left_color_val = giyeok_moving2_left_color || 0;
        } else if (giyeok_drawer_type_left == 5) {
          giyeok_left_color_val = giyeok_moving3_left_color || 0;
        }
        ret += numberToSingleChar(giyeok_left_color_val);

        ret += numberToSingleChar(giyeok_drawer_type_right || 0);
        
        // 우측 색상: 타입에 따라 해당 색상 값 사용
        var giyeok_right_color_val = 0;
        if (giyeok_drawer_type_right == 1) {
          giyeok_right_color_val = giyeok_attach1_right_color || 0;
        } else if (giyeok_drawer_type_right == 2) {
          giyeok_right_color_val = giyeok_attach2_right_color || 0;
        } else if (giyeok_drawer_type_right == 3) {
          giyeok_right_color_val = giyeok_attach3_right_color || 0;
        } else if (giyeok_drawer_type_right == 4) {
          giyeok_right_color_val = giyeok_moving2_right_color || 0;
        } else if (giyeok_drawer_type_right == 5) {
          giyeok_right_color_val = giyeok_moving3_right_color || 0;
        }
        ret += numberToSingleChar(giyeok_right_color_val);

        // 선반 깊이 (part6의 마지막)
        if (shelf_depth == 200)
          ret += "1";
        else if (shelf_depth == 360)
          ret += "2";
        else
          ret += "0";

        return ret;
      }

      // 코드에서 제품 생성 함수
      function loadProductFromCode(code) {
        if (!code || code.trim() === '') {
          alert('상품코드를 입력해주세요.');
          return;
        }
        
        // URL 업데이트 방지 플래그 설정
        skipURLUpdate = true;
        // 씬 업데이트 방지 플래그 설정 (각 setter에서 updateScene/render 호출 방지)
        skipSceneUpdate = true;
        
        try {
          var parts = code.split('-');
          if (parts.length < 6) {
            alert('상품코드 형식이 올바르지 않습니다.');
            return;
          }
          
          var part1 = parts[0]; // 구조 정보
          var part2 = parts[1]; // 색상 정보 (기본)
          var part3 = parts[2]; // 색상 정보 (추가)
          var part4 = parts[3]; // 옵션 정보
          var part5 = parts[4]; // 파티션 및 선반 깊이
          var part6 = parts[5]; // ㄱ자 하부 서랍 옵션
          
          // part1 파싱: is_mium(1) + board_width_idx(1) + board_depth_idx(1) + vertical_length_idx(1) + shelf_num(1)
          if (part1.length >= 5) {
            var is_mium_val = parseInt(part1[0]);
            var board_width_idx_val = parseInt(part1[1]);
            var board_depth_idx_val = parseInt(part1[2]);
            var vertical_length_idx_val = parseInt(part1[3]);
            var shelf_num_val = parseInt(part1[4]);
            
            // is_mium 설정
            if (is_mium_val == 2) {
              setMium(1);
            } else {
              setMium(0);
            }
            
            // board_width 설정
            var width_values = [0, 1200, 1400, 1600, 1800, 2060, 2360];
            if (board_width_idx_val > 0 && board_width_idx_val < width_values.length) {
              setWidth(width_values[board_width_idx_val]);
            }
            
            // board_depth 설정
            var depth_values = [0, 500, 600, 700, 800, 1000, 1200];
            if (board_depth_idx_val > 0 && board_depth_idx_val < depth_values.length) {
              setDepth(depth_values[board_depth_idx_val]);
            }
            
            // vertical_length 설정
            setVertical(vertical_length_idx_val);
            
            // shelf_num 설정
            if (shelf_num_val > 0) {
              setShelfNum(shelf_num_val);
            }
          }
          
          // part2 파싱: shelf_direction(1) + board_color(1) + frame_color(1) + vertical_color(1) + shelf_board_color(1)
          // 색상 값은 알파벳일 수 있으므로 singleCharToNumber 사용
          if (part2.length >= 5) {
            var shelf_direction_val = parseInt(part2[0]) || 1;
            var board_color_val = singleCharToNumber(part2[1]);
            var frame_color_val = singleCharToNumber(part2[2]);
            var vertical_color_val = singleCharToNumber(part2[3]);
            var shelf_board_color_val = singleCharToNumber(part2[4]);
            
            setShelfDirection(shelf_direction_val == 2 ? 1 : 0);
            setBoardColor(board_color_val);
            setFrameColor(frame_color_val);
            setVerticalColor(vertical_color_val);
            setShelfBoardColor(shelf_board_color_val);
          }
          
          // part3 파싱: shelf_frame_color(1) + giyeok_position(1) + desk_mat_color(1) + drawer_color(1) + fence_color(1)
          // 색상 값은 알파벳일 수 있으므로 singleCharToNumber 사용
          if (part3.length >= 5) {
            var shelf_frame_color_val = singleCharToNumber(part3[0]);
            var giyeok_position_val = singleCharToNumber(part3[1]);
            var desk_mat_color_val = singleCharToNumber(part3[2]);
            var drawer_color_val = singleCharToNumber(part3[3]);
            var fence_color_val = singleCharToNumber(part3[4]);
            
            setShelfFrameColor(shelf_frame_color_val);
            setGiyeok(giyeok_position_val);
            setDeskMat(desk_mat_color_val);
            setDrawerColor(drawer_color_val);
            setFence(fence_color_val);
          }
          
          // part4 파싱: moving2_color(1) + moving3_color(1) + num_desk(1) + is_desk_duplicated(1) + attach1_left(1) + attach1_right(1) + attach2_left(1) + attach2_right(1) + attach3_left(1) + attach3_right(1) + storage_sliding1(1) + storage_sliding2(1) + storage_flap(1) + storage_flapstay(1)
          // 색상 값은 알파벳일 수 있으므로 singleCharToNumber 사용
          if (part4.length >= 14) {
            var moving2_color_val = singleCharToNumber(part4[0]);
            var moving3_color_val = singleCharToNumber(part4[1]);
            var num_desk_val = parseInt(part4[2]) || 1; // 최소 1 (숫자만)
            var is_desk_duplicated_val = parseInt(part4[3]) || 1; // 기본값: 복사 안함 (숫자만)
            var attach1_left_val = singleCharToNumber(part4[4]);
            var attach1_right_val = singleCharToNumber(part4[5]);
            var attach2_left_val = singleCharToNumber(part4[6]);
            var attach2_right_val = singleCharToNumber(part4[7]);
            var attach3_left_val = singleCharToNumber(part4[8]);
            var attach3_right_val = singleCharToNumber(part4[9]);
            var storage_sliding1_val = singleCharToNumber(part4[10]);
            var storage_sliding2_val = singleCharToNumber(part4[11]);
            var storage_flap_val = singleCharToNumber(part4[12]);
            var storage_flapstay_val = singleCharToNumber(part4[13]);
            
            setMoving2(moving2_color_val);
            setMoving3(moving3_color_val);
            setDeskArray(num_desk_val);
            // 맞은편 배열: 1=복사 안함, 2=거리 3600, 3=거리 -1030, 4=거리 -2400
            if (is_desk_duplicated_val == 1) {
              setDeskOpposite(0);
            } else if (is_desk_duplicated_val == 2) {
              setDeskOpposite(3600);
            } else if (is_desk_duplicated_val == 3) {
              setDeskOpposite(-1030);
            } else if (is_desk_duplicated_val == 4) {
              setDeskOpposite(-2400);
            } else {
              setDeskOpposite(0);
            }
            
            // 부착형 서랍 설정 (setter 함수 사용)
            setAttach1Left(attach1_left_val);
            setAttach1Right(attach1_right_val);
            setAttach2Left(attach2_left_val);
            setAttach2Right(attach2_right_val);
            setAttach3Left(attach3_left_val);
            setAttach3Right(attach3_right_val);
            
            // 수납 도어 설정
            if (storage_sliding1_val > 0) {
              setStorageSliding1(storage_sliding1_val);
            } else {
              storage_sliding1_color = 0;
            }
            if (storage_sliding2_val > 0) {
              setStorageSliding2(storage_sliding2_val);
            } else {
              storage_sliding2_color = 0;
            }
            if (storage_flap_val > 0) {
              setStorageFlap(storage_flap_val);
            } else {
              storage_flap_color = 0;
            }
            if (storage_flapstay_val > 0) {
              setStorageFlapStay(storage_flapstay_val);
            } else {
              storage_flapstay_color = 0;
            }
          }
          
          // part5 파싱: parti_ver_L_height_idx + parti_ver_L_color + parti_ver_R_height_idx + parti_ver_R_color + parti_ver_M_height_idx + parti_ver_M_color + parti_hol_B_width_idx + parti_hol_B_color + parti_z_align_front
          // 색상 값은 알파벳일 수 있으므로 singleCharToNumber 사용
          if (part5.length >= 8) {
            var parti_ver_L_height_idx = parseInt(part5[0]) || 0;
            var parti_ver_L_color_val = singleCharToNumber(part5[1]);
            var parti_ver_R_height_idx = parseInt(part5[2]) || 0;
            var parti_ver_R_color_val = singleCharToNumber(part5[3]);
            var parti_ver_M_height_idx = parseInt(part5[4]) || 0;
            var parti_ver_M_color_val = singleCharToNumber(part5[5]);
            var parti_hol_B_width_idx = parseInt(part5[6]) || 0;
            var parti_hol_B_color_val = singleCharToNumber(part5[7]);
            var parti_z_align_front_val = part5.length >= 9 ? parseInt(part5[8]) || 0 : 0;
            
            // 파티션 높이/넓이 값 설정 (인덱스로 저장됨)
            // skipSceneUpdate가 true이므로 높이 설정 시 자동 색상 설정이 작동하지 않음
            var height_values_LR = [0, 480, 800, 1200, 1400, 1600, 1800];
            if (parti_ver_L_height_idx >= 0 && parti_ver_L_height_idx < height_values_LR.length) {
              setPartiVerLHeight(height_values_LR[parti_ver_L_height_idx]);
            } else {
              setPartiVerLHeight(0);
            }
            // 색상 설정 (높이 설정 후)
            setPartiVerLColor(parti_ver_L_color_val);
            
            if (parti_ver_R_height_idx >= 0 && parti_ver_R_height_idx < height_values_LR.length) {
              setPartiVerRHeight(height_values_LR[parti_ver_R_height_idx]);
            } else {
              setPartiVerRHeight(0);
            }
            // 색상 설정 (높이 설정 후)
            setPartiVerRColor(parti_ver_R_color_val);
            
            var height_values_M = [0, 460, 800, 1200, 1400, 1600, 1800];
            if (parti_ver_M_height_idx >= 0 && parti_ver_M_height_idx < height_values_M.length) {
              setPartiVerMHeight(height_values_M[parti_ver_M_height_idx]);
            } else {
              setPartiVerMHeight(0);
            }
            // 색상 설정 (높이 설정 후)
            setPartiVerMColor(parti_ver_M_color_val);
            
            var width_values_parti = [0, 1200, 1400, 1600, 1800];
            if (parti_hol_B_width_idx >= 0 && parti_hol_B_width_idx < width_values_parti.length) {
              setPartiHolBWidth(width_values_parti[parti_hol_B_width_idx]);
            } else {
              setPartiHolBWidth(0);
            }
            // 색상 설정 (너비 설정 후)
            setPartiHolBColor(parti_hol_B_color_val);
            
            // 파티션 Z축 위치 정렬 설정
            if (parti_z_align_front_val == 1) {
              setPartiZAlignFront(1);
            } else {
              setPartiZAlignFront(0);
            }
          }
          
          // part6 파싱: giyeok_drawer_type_left + giyeok_left_color + giyeok_drawer_type_right + giyeok_right_color + shelf_depth
          // 색상 값은 알파벳일 수 있으므로 singleCharToNumber 사용
          if (part6 && part6.length >= 5) {
            var giyeok_drawer_type_left_val = parseInt(part6[0]) || 0;
            var giyeok_left_color_val = singleCharToNumber(part6[1]);
            var giyeok_drawer_type_right_val = parseInt(part6[2]) || 0;
            var giyeok_right_color_val = singleCharToNumber(part6[3]);
            var shelf_depth_val = parseInt(part6[4]) || 0;
            
            // ㄱ자 하부 서랍 설정
            setGiyeokDrawerTypeLeft(giyeok_drawer_type_left_val);
            // 색상이 0이어도 명시적으로 설정 (색상 정보 보존)
            setGiyeokDrawerColorLeft(giyeok_left_color_val);
            
            setGiyeokDrawerTypeRight(giyeok_drawer_type_right_val);
            // 색상이 0이어도 명시적으로 설정 (색상 정보 보존)
            setGiyeokDrawerColorRight(giyeok_right_color_val);
            
            // shelf_depth 설정
            if (shelf_depth_val == 1) {
              setShelfDepth(200);
            } else if (shelf_depth_val == 2) {
              setShelfDepth(360);
            } else {
              setShelfDepth(200);
            }
          } else if (part5.length >= 9) {
            // 이전 형식 호환: part5에 shelf_depth가 포함된 경우
            var shelf_depth_val = parseInt(part5[8]);
            if (shelf_depth_val == 1) {
              setShelfDepth(200);
            } else if (shelf_depth_val == 2) {
              setShelfDepth(360);
            } else {
              setShelfDepth(200);
            }
          }
          
          // 플래그 해제 (모든 설정 완료 후)
          skipSceneUpdate = false;
          
          // 모든 설정이 완료된 후 씬 업데이트 (한 번만 호출)
          updateScene();
          render();
          
          // 코드 입력창 업데이트
          var codeInput = document.getElementById('product_code_input');
          if (codeInput) {
            codeInput.value = generateProductCode();
          }
          
          // URL 업데이트 (히스토리 교체 - 이미 로드 중이므로 replaceState 사용)
          // skipURLUpdate 플래그를 해제하기 전에 업데이트해야 함
          var finalCode = generateProductCode();
          var url = new URL(window.location.href);
          url.searchParams.set('code', finalCode);
          window.history.replaceState({code: finalCode}, '', url.toString());
          
        } catch (error) {
          console.error('코드 파싱 오류:', error);
          alert('상품코드를 읽는 중 오류가 발생했습니다: ' + error.message);
        } finally {
          // 플래그 해제
          skipURLUpdate = false;
          skipSceneUpdate = false;
        }
      }

      function calculatePrice() {
        var delivery_price = 0;
        var product_price = 0;
        var ret_price = new Array(2);

        // 가격 데이터가 로드되지 않았으면 기본값 사용
        if (!priceData || !priceDataLoaded) {
          console.warn('가격 데이터가 아직 로드되지 않았습니다. 기본값을 사용합니다.');
        }

        // 가격 데이터에서 가져오기 (없으면 기본값 사용)
        var prices = priceData && priceData.prices ? priceData.prices : null;
        
        // 책상 본체 가격
        var board_price_table = prices && prices.board && prices.board.table ? 
          prices.board.table.flat() : // 2D 배열을 1D로 변환
          [0, 0, 0, 0, 0, 0,
           109800, 129800, 141700, 159700, 193100, 0,
           118400, 139900, 159900, 198800, 214500, 0,
           151000, 169800, 189800, 217300, 241400, 0,
           0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0];

        var shelf_product_price_table = prices && prices.shelf && prices.shelf.product ? 
          prices.shelf.product : [34000, 43000, 45000, 51000, 57000, 0];
        var shelf_delivery_price_table = prices && prices.shelf && prices.shelf.delivery ? 
          prices.shelf.delivery : [29800, 29800, 32800, 35800, 38800, 41800, 44800];
        var fence_price_table = prices && prices.fence && prices.fence.product ? 
          prices.fence.product : [81700, 101700, 103400, 105000, 113900, 0];

        // Updated Table Index Logic for 6x6 grid (Width Max 6)
        var table_index = (board_width_idx - 1) + (board_depth_idx - 1) * 6; 
        
        if (board_price_table[table_index] !== undefined && board_price_table[table_index] > 0) {
             product_price += board_price_table[table_index];
        }
        
        // 기본 배송비
        var basic_delivery = prices && prices.delivery && prices.delivery.basic ? 
          prices.delivery.basic : 29800;
        delivery_price += basic_delivery;

        // ㅁ다리
        if (is_mium) {
          var mium_product = prices && prices.mium && prices.mium.product ? 
            prices.mium.product : 69900;
          var mium_delivery = prices && prices.mium && prices.mium.delivery ? 
            prices.mium.delivery : 29800;
          product_price += mium_product;
          delivery_price += mium_delivery;
        }

        // 선반
        if (vertical_length_idx) {
          if (shelf_product_price_table[board_width_idx - 1]) {
             product_price += shelf_product_price_table[board_width_idx - 1] * shelf_num;
          }
          if (shelf_delivery_price_table[shelf_num - 1]) {
            delivery_price += shelf_delivery_price_table[shelf_num - 1];
          }

          // 높이 추가 비용
          var heightExtra = prices && prices.shelf && prices.shelf.heightExtra ? 
            prices.shelf.heightExtra : { "925": 11400, "1400": 16000, "1860": 21900 };
          
          if (vertical_length_idx == 2 && heightExtra["925"])
            product_price += heightExtra["925"];
          else if (vertical_length_idx == 3 && heightExtra["1400"])
            product_price += heightExtra["1400"];
          else if (vertical_length_idx == 4 && heightExtra["1860"])
            product_price += heightExtra["1860"];
        }

        // ㄱ자 모듈
        if (giyeok_position) {
          var giyeok_price = prices && prices.giyeok && prices.giyeok.product ? 
            prices.giyeok.product : 94500;
          product_price += giyeok_price;
        }

        // 데스크 매트
        if (desk_mat_color) {
          var deskMat_product = prices && prices.deskMat && prices.deskMat.product ? 
            prices.deskMat.product : 65000;
          var deskMat_delivery = prices && prices.deskMat && prices.deskMat.delivery ? 
            prices.deskMat.delivery : 5000;
          product_price += deskMat_product;
          delivery_price += deskMat_delivery;
        }

        // 미니서랍
        if (drawer_color) {
          var drawer_product = prices && prices.drawer && prices.drawer.product ? 
            prices.drawer.product : 34400;
          var drawer_delivery = prices && prices.drawer && prices.drawer.delivery ? 
            prices.drawer.delivery : 3000;
          product_price += drawer_product;
          delivery_price += drawer_delivery;
        }

        // 하부가림막
        if (fence_color) {
          if (fence_price_table[board_width_idx - 1]) {
             product_price += fence_price_table[board_width_idx - 1];
          }
          var fence_delivery = prices && prices.fence && prices.fence.delivery ? 
            prices.fence.delivery : 19800;
          delivery_price += fence_delivery;
        }

        // 2단 이동 서랍
        if (moving2_color) {
          var moving2_product = prices && prices.moving2 && prices.moving2.product ? 
            prices.moving2.product : 88000;
          var moving2_delivery = prices && prices.moving2 && prices.moving2.delivery ? 
            prices.moving2.delivery : 19800;
          product_price += moving2_product;
          delivery_price += moving2_delivery;
        }

        // 3단 이동 서랍
        if (moving3_color) {
          var moving3_product = prices && prices.moving3 && prices.moving3.product ? 
            prices.moving3.product : 121000;
          var moving3_delivery = prices && prices.moving3 && prices.moving3.delivery ? 
            prices.moving3.delivery : 19800;
          product_price += moving3_product;
          delivery_price += moving3_delivery;
        }

        // 책상 배열 배수
        if (num_desk > 1) {
          product_price *= num_desk;
          delivery_price *= num_desk;
        }

        // 반대편 책상 배수
        if (opposite_desk_distance != 0) {
          product_price *= 2;
          delivery_price *= 2;
        }
        
        // return
        ret_price[0] = delivery_price;
        ret_price[1] = product_price;

        return ret_price;
      }
      
      // 옵션 명세 리스트 생성 함수
      function generateOptionSpecList() {
        var specList = [];
        
        // 가격 데이터에서 가져오기 (없으면 기본값 사용)
        var prices = priceData && priceData.prices ? priceData.prices : null;
        
        var board_price_table = prices && prices.board && prices.board.table ? 
          prices.board.table.flat() : // 2D 배열을 1D로 변환
          [0, 0, 0, 0, 0, 0,
           109800, 129800, 141700, 159700, 193100, 0,
           118400, 139900, 159900, 198800, 214500, 0,
           151000, 169800, 189800, 217300, 241400, 0,
           0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0];
        var shelf_product_price_table = prices && prices.shelf && prices.shelf.product ? 
          prices.shelf.product : [34000, 43000, 45000, 51000, 57000, 0];
        var shelf_delivery_price_table = prices && prices.shelf && prices.shelf.delivery ? 
          prices.shelf.delivery : [29800, 29800, 32800, 35800, 38800, 41800, 44800];
        var fence_price_table = prices && prices.fence && prices.fence.product ? 
          prices.fence.product : [81700, 101700, 103400, 105000, 113900, 0];
        
        var width_names = ["", "1200", "1400", "1600", "1800", "2060", "2360"];
        var depth_names = ["", "500", "600", "700", "800", "1000", "1200"];
        var vertical_names = ["", "646", "925", "1400", "1860"];
        
        var table_index = (board_width_idx - 1) + (board_depth_idx - 1) * 6;
        var board_price = board_price_table[table_index] || 0;
        var desk_multiplier = num_desk > 1 ? num_desk : 1;
        var opposite_multiplier = opposite_desk_distance != 0 ? 2 : 1;
        var total_multiplier = desk_multiplier * opposite_multiplier;
        
        // 책상 본체
        if (board_price > 0) {
          specList.push({
            name: "책상 본체 (" + width_names[board_width_idx] + " x " + depth_names[board_depth_idx] + ")",
            qty: total_multiplier,
            unitPrice: board_price,
            totalPrice: board_price * total_multiplier
          });
        }
        
        // 배송비
        var basic_delivery = prices && prices.delivery && prices.delivery.basic ? 
          prices.delivery.basic : 29800;
        specList.push({
          name: "기본 배송비",
          qty: total_multiplier,
          unitPrice: basic_delivery,
          totalPrice: basic_delivery * total_multiplier
        });
        
        // ㅁ다리
        if (is_mium) {
          var mium_product = prices && prices.mium && prices.mium.product ? 
            prices.mium.product : 69900;
          specList.push({
            name: "ㅁ다리",
            qty: total_multiplier,
            unitPrice: mium_product,
            totalPrice: mium_product * total_multiplier
          });
          var mium_delivery = prices && prices.mium && prices.mium.delivery ? 
            prices.mium.delivery : 29800;
          specList.push({
            name: "ㅁ다리 배송비",
            qty: total_multiplier,
            unitPrice: mium_delivery,
            totalPrice: mium_delivery * total_multiplier
          });
        }
        
        // 선반
        if (vertical_length_idx > 0) {
          var shelf_price = shelf_product_price_table[board_width_idx - 1] || 0;
          if (shelf_price > 0 && shelf_num > 0) {
            specList.push({
              name: "선반 (" + width_names[board_width_idx] + " x " + shelf_num + "개)",
              qty: total_multiplier,
              unitPrice: shelf_price * shelf_num,
              totalPrice: shelf_price * shelf_num * total_multiplier
            });
          }
          
          if (shelf_num > 0) {
            var shelf_delivery = shelf_delivery_price_table[shelf_num - 1] || 0;
            if (shelf_delivery > 0) {
              specList.push({
                name: "선반 배송비",
                qty: total_multiplier,
                unitPrice: shelf_delivery,
                totalPrice: shelf_delivery * total_multiplier
              });
            }
          }
          
          // 수직부재 높이 추가 비용
          var heightExtra = prices && prices.shelf && prices.shelf.heightExtra ? 
            prices.shelf.heightExtra : { "925": 11400, "1400": 16000, "1860": 21900 };
          
          if (vertical_length_idx == 2 && heightExtra["925"]) {
            specList.push({
              name: "수직부재 높이 추가 (925mm)",
              qty: total_multiplier,
              unitPrice: heightExtra["925"],
              totalPrice: heightExtra["925"] * total_multiplier
            });
          } else if (vertical_length_idx == 3 && heightExtra["1400"]) {
            specList.push({
              name: "수직부재 높이 추가 (1400mm)",
              qty: total_multiplier,
              unitPrice: heightExtra["1400"],
              totalPrice: heightExtra["1400"] * total_multiplier
            });
          } else if (vertical_length_idx == 4 && heightExtra["1860"]) {
            specList.push({
              name: "수직부재 높이 추가 (1860mm)",
              qty: total_multiplier,
              unitPrice: heightExtra["1860"],
              totalPrice: heightExtra["1860"] * total_multiplier
            });
          }
        }
        
        // ㄱ자 모듈
        if (giyeok_position) {
          var giyeok_price = prices && prices.giyeok && prices.giyeok.product ? 
            prices.giyeok.product : 94500;
          specList.push({
            name: "ㄱ자 모듈",
            qty: total_multiplier,
            unitPrice: giyeok_price,
            totalPrice: giyeok_price * total_multiplier
          });
        }
        
        // 데스크 매트
        if (desk_mat_color) {
          var deskMat_product = prices && prices.deskMat && prices.deskMat.product ? 
            prices.deskMat.product : 65000;
          var deskMat_delivery = prices && prices.deskMat && prices.deskMat.delivery ? 
            prices.deskMat.delivery : 5000;
          specList.push({
            name: "데스크 매트",
            qty: total_multiplier,
            unitPrice: deskMat_product,
            totalPrice: deskMat_product * total_multiplier
          });
          specList.push({
            name: "데스크 매트 배송비",
            qty: total_multiplier,
            unitPrice: deskMat_delivery,
            totalPrice: deskMat_delivery * total_multiplier
          });
        }
        
        // 미니서랍
        if (drawer_color) {
          var drawer_product = prices && prices.drawer && prices.drawer.product ? 
            prices.drawer.product : 34400;
          var drawer_delivery = prices && prices.drawer && prices.drawer.delivery ? 
            prices.drawer.delivery : 3000;
          specList.push({
            name: "미니서랍",
            qty: total_multiplier,
            unitPrice: drawer_product,
            totalPrice: drawer_product * total_multiplier
          });
          specList.push({
            name: "미니서랍 배송비",
            qty: total_multiplier,
            unitPrice: drawer_delivery,
            totalPrice: drawer_delivery * total_multiplier
          });
        }
        
        // 하부가림막
        if (fence_color) {
          var fence_price = fence_price_table[board_width_idx - 1] || 0;
          if (fence_price > 0) {
            specList.push({
              name: "하부가림막 (" + width_names[board_width_idx] + ")",
              qty: total_multiplier,
              unitPrice: fence_price,
              totalPrice: fence_price * total_multiplier
            });
          }
          var fence_delivery = prices && prices.fence && prices.fence.delivery ? 
            prices.fence.delivery : 19800;
          specList.push({
            name: "하부가림막 배송비",
            qty: total_multiplier,
            unitPrice: fence_delivery,
            totalPrice: fence_delivery * total_multiplier
          });
        }
        
        // 2단 이동 서랍
        if (moving2_color) {
          var moving2_product = prices && prices.moving2 && prices.moving2.product ? 
            prices.moving2.product : 88000;
          var moving2_delivery = prices && prices.moving2 && prices.moving2.delivery ? 
            prices.moving2.delivery : 19800;
          specList.push({
            name: "2단 이동 서랍",
            qty: total_multiplier,
            unitPrice: moving2_product,
            totalPrice: moving2_product * total_multiplier
          });
          specList.push({
            name: "2단 이동 서랍 배송비",
            qty: total_multiplier,
            unitPrice: moving2_delivery,
            totalPrice: moving2_delivery * total_multiplier
          });
        }
        
        // 3단 이동 서랍
        if (moving3_color) {
          var moving3_product = prices && prices.moving3 && prices.moving3.product ? 
            prices.moving3.product : 121000;
          var moving3_delivery = prices && prices.moving3 && prices.moving3.delivery ? 
            prices.moving3.delivery : 19800;
          specList.push({
            name: "3단 이동 서랍",
            qty: total_multiplier,
            unitPrice: moving3_product,
            totalPrice: moving3_product * total_multiplier
          });
          specList.push({
            name: "3단 이동 서랍 배송비",
            qty: total_multiplier,
            unitPrice: moving3_delivery,
            totalPrice: moving3_delivery * total_multiplier
          });
        }
        
        return specList;
      }
      
      // 옵션 명세 리스트 업데이트
      function updateOptionSpecList() {
        try {
          var specList = generateOptionSpecList();
          var specListContainer = document.getElementById('option_spec_list');
          if (!specListContainer) return;
        
        specListContainer.innerHTML = '';
        
        // 헤더 추가
        var header = document.createElement('div');
        header.className = 'option_spec_item header';
        header.innerHTML = '<div class="option_spec_name">옵션명</div><div class="option_spec_qty">수량</div><div class="option_spec_unit">단가</div><div class="option_spec_total">금액</div>';
        specListContainer.appendChild(header);
        
        // 옵션 리스트 추가
        var totalProductPrice = 0;
        var totalDeliveryPrice = 0;
        
        specList.forEach(function(item) {
          var row = document.createElement('div');
          row.className = 'option_spec_item';
          
          var unitPriceStr = item.unitPrice.toLocaleString('ko-KR');
          var totalPriceStr = item.totalPrice.toLocaleString('ko-KR');
          
          row.innerHTML = 
            '<div class="option_spec_name">' + item.name + '</div>' +
            '<div class="option_spec_qty">' + item.qty + '</div>' +
            '<div class="option_spec_unit">' + unitPriceStr + '원</div>' +
            '<div class="option_spec_total">' + totalPriceStr + '원</div>';
          
          specListContainer.appendChild(row);
          
          // 배송비와 상품가격 분리
          if (item.name.indexOf('배송비') !== -1) {
            totalDeliveryPrice += item.totalPrice;
          } else {
            totalProductPrice += item.totalPrice;
          }
        });
        
        // 합계 행 추가
        var totalRow = document.createElement('div');
        totalRow.className = 'option_spec_item header';
        totalRow.style.marginTop = '10px';
        totalRow.innerHTML = 
          '<div class="option_spec_name">합계</div>' +
          '<div class="option_spec_qty"></div>' +
          '<div class="option_spec_unit">상품: ' + totalProductPrice.toLocaleString('ko-KR') + '원<br>배송: ' + totalDeliveryPrice.toLocaleString('ko-KR') + '원</div>' +
          '<div class="option_spec_total">' + (totalProductPrice + totalDeliveryPrice).toLocaleString('ko-KR') + '원</div>';
        specListContainer.appendChild(totalRow);
        
        // 가격 표시 업데이트
        var priceArr = calculatePrice();
        var totalPrice = priceArr[0] + priceArr[1];
        var totalPriceDisplay = document.getElementById('total_price_display');
        if (totalPriceDisplay) {
          totalPriceDisplay.innerHTML = totalPrice.toLocaleString('ko-KR') + '<span>원</span>';
        }
        
        // 배송조립비와 상품금액 업데이트
        var deliveryPriceEl = document.querySelector('.delivery_box:has(.ft_title:contains("배송조립비")) .delivery_info.price');
        var productPriceEl = document.querySelector('.delivery_box:has(.ft_title:contains("상품금액")) .delivery_info.price');
        
        // 더 정확한 선택자 사용
        var deliveryBoxes = document.querySelectorAll('.delivery_box');
        deliveryBoxes.forEach(function(box) {
          var title = box.querySelector('.ft_title');
          if (title && title.textContent === '배송조립비') {
            var priceEl = box.querySelector('.delivery_info.price');
            if (priceEl) {
              priceEl.innerHTML = priceArr[0].toLocaleString('ko-KR') + ' <span>원</span>';
            }
          }
          if (title && title.textContent === '상품금액') {
            var priceEl = box.querySelector('.delivery_info.price');
            if (priceEl) {
              priceEl.innerHTML = priceArr[1].toLocaleString('ko-KR') + ' <span>원</span>';
            }
          }
        });
        } catch (error) {
          console.error('옵션 명세 리스트 업데이트 오류:', error);
        }
      }
      
      // 옵션 명세 리스트 토글
      function toggleOptionSpec() {
        var listContainer = document.getElementById('option_spec_list');
        var toggle = document.getElementById('option_spec_toggle');
        if (!listContainer || !toggle) return;
        
        if (listContainer.classList.contains('hidden')) {
          listContainer.classList.remove('hidden');
          toggle.textContent = '▲ 접기';
        } else {
          listContainer.classList.add('hidden');
          toggle.textContent = '▼ 펼치기';
        }
      }

      // 상세 좌표축 생성 함수
      function createDetailedAxes(length, majorTickInterval, minorTickInterval, majorTickSize, minorTickSize) {
        var axesGroup = new THREE.Group();
        
        // 축 색상
        var xColor = 0xff0000; // 빨강
        var yColor = 0x00ff00; // 초록
        var zColor = 0x0000ff; // 파랑
        
        // 텍스트 스프라이트 생성 함수
        function createTextSprite(text, color, position, isSmall) {
          var canvas = document.createElement('canvas');
          var context = canvas.getContext('2d');
          var width = isSmall ? 140 : 160;
          var height = isSmall ? 60 : 80;
          canvas.width = width;
          canvas.height = height;
          
          context.fillStyle = 'rgba(255, 255, 255, 0.9)';
          context.fillRect(0, 0, canvas.width, canvas.height);
          
          context.fillStyle = color === 'red' ? '#ff0000' : color === 'green' ? '#00ff00' : '#0000ff';
          var fontSize = isSmall ? 24 : 28;
          context.font = 'Bold ' + fontSize + 'px Arial';
          context.textAlign = 'center';
          context.textBaseline = 'middle';
          context.fillText(text, canvas.width / 2, canvas.height / 2);
          
          var texture = new THREE.CanvasTexture(canvas);
          texture.needsUpdate = true;
          var spriteMaterial = new THREE.SpriteMaterial({ 
            map: texture,
            transparent: true,
            opacity: 0.9
          });
          var sprite = new THREE.Sprite(spriteMaterial);
          var scale = isSmall ? 250 : 300;
          sprite.scale.set(scale, scale * 0.5, 1);
          sprite.position.copy(position);
          return sprite;
        }
        
        // X축 (빨강) - 양수 방향
        var xAxisPosGeometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(length, 0, 0)
        ]);
        var xAxisPosMaterial = new THREE.LineBasicMaterial({ color: xColor, linewidth: 3 });
        var xAxisPos = new THREE.Line(xAxisPosGeometry, xAxisPosMaterial);
        axesGroup.add(xAxisPos);
        
        // X축 (빨강) - 음수 방향
        var xAxisNegGeometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(-length, 0, 0)
        ]);
        var xAxisNegMaterial = new THREE.LineBasicMaterial({ color: xColor, linewidth: 3, opacity: 0.5 });
        xAxisNegMaterial.transparent = true;
        var xAxisNeg = new THREE.Line(xAxisNegGeometry, xAxisNegMaterial);
        axesGroup.add(xAxisNeg);
        
        // X축 주 눈금선과 레이블
        for (var x = -length; x <= length; x += majorTickInterval) {
          if (x === 0) continue; // 원점은 제외
          
          // 주 눈금선
          var tickGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(x, -majorTickSize, 0),
            new THREE.Vector3(x, majorTickSize, 0)
          ]);
          var tickMaterial = new THREE.LineBasicMaterial({ color: xColor, linewidth: 2 });
          var tick = new THREE.Line(tickGeometry, tickMaterial);
          axesGroup.add(tick);
          
          // 레이블 (X축명 병기)
          var labelText = 'X' + (x > 0 ? '+' : '') + x;
          var label = createTextSprite(labelText, 'red', new THREE.Vector3(x, majorTickSize + 100, 0), true);
          axesGroup.add(label);
        }
        
        // X축 보조 눈금선
        for (var x = -length; x <= length; x += minorTickInterval) {
          if (x === 0 || x % majorTickInterval === 0) continue; // 원점과 주 눈금은 제외
          
          var tickGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(x, -minorTickSize, 0),
            new THREE.Vector3(x, minorTickSize, 0)
          ]);
          var tickMaterial = new THREE.LineBasicMaterial({ color: xColor, opacity: 0.6 });
          tickMaterial.transparent = true;
          var tick = new THREE.Line(tickGeometry, tickMaterial);
          axesGroup.add(tick);
        }
        
        // Y축 (초록) - 양수 방향
        var yAxisPosGeometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(0, length, 0)
        ]);
        var yAxisPosMaterial = new THREE.LineBasicMaterial({ color: yColor, linewidth: 3 });
        var yAxisPos = new THREE.Line(yAxisPosGeometry, yAxisPosMaterial);
        axesGroup.add(yAxisPos);
        
        // Y축 (초록) - 음수 방향
        var yAxisNegGeometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(0, -length, 0)
        ]);
        var yAxisNegMaterial = new THREE.LineBasicMaterial({ color: yColor, linewidth: 3, opacity: 0.5 });
        yAxisNegMaterial.transparent = true;
        var yAxisNeg = new THREE.Line(yAxisNegGeometry, yAxisNegMaterial);
        axesGroup.add(yAxisNeg);
        
        // Y축 주 눈금선과 레이블
        for (var y = -length; y <= length; y += majorTickInterval) {
          if (y === 0) continue; // 원점은 제외
          
          // 주 눈금선
          var tickGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(-majorTickSize, y, 0),
            new THREE.Vector3(majorTickSize, y, 0)
          ]);
          var tickMaterial = new THREE.LineBasicMaterial({ color: yColor, linewidth: 2 });
          var tick = new THREE.Line(tickGeometry, tickMaterial);
          axesGroup.add(tick);
          
          // 레이블 (Y축명 병기)
          var labelText = 'Y' + (y > 0 ? '+' : '') + y;
          var label = createTextSprite(labelText, 'green', new THREE.Vector3(majorTickSize + 100, y, 0), true);
          axesGroup.add(label);
        }
        
        // Y축 보조 눈금선
        for (var y = -length; y <= length; y += minorTickInterval) {
          if (y === 0 || y % majorTickInterval === 0) continue; // 원점과 주 눈금은 제외
          
          var tickGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(-minorTickSize, y, 0),
            new THREE.Vector3(minorTickSize, y, 0)
          ]);
          var tickMaterial = new THREE.LineBasicMaterial({ color: yColor, opacity: 0.6 });
          tickMaterial.transparent = true;
          var tick = new THREE.Line(tickGeometry, tickMaterial);
          axesGroup.add(tick);
        }
        
        // Z축 (파랑) - 양수 방향
        var zAxisPosGeometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(0, 0, length)
        ]);
        var zAxisPosMaterial = new THREE.LineBasicMaterial({ color: zColor, linewidth: 3 });
        var zAxisPos = new THREE.Line(zAxisPosGeometry, zAxisPosMaterial);
        axesGroup.add(zAxisPos);
        
        // Z축 (파랑) - 음수 방향
        var zAxisNegGeometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(0, 0, -length)
        ]);
        var zAxisNegMaterial = new THREE.LineBasicMaterial({ color: zColor, linewidth: 3, opacity: 0.5 });
        zAxisNegMaterial.transparent = true;
        var zAxisNeg = new THREE.Line(zAxisNegGeometry, zAxisNegMaterial);
        axesGroup.add(zAxisNeg);
        
        // Z축 주 눈금선과 레이블
        for (var z = -length; z <= length; z += majorTickInterval) {
          if (z === 0) continue; // 원점은 제외
          
          // 주 눈금선
          var tickGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, -majorTickSize, z),
            new THREE.Vector3(0, majorTickSize, z)
          ]);
          var tickMaterial = new THREE.LineBasicMaterial({ color: zColor, linewidth: 2 });
          var tick = new THREE.Line(tickGeometry, tickMaterial);
          axesGroup.add(tick);
          
          // 레이블 (Z축명 병기)
          var labelText = 'Z' + (z > 0 ? '+' : '') + z;
          var label = createTextSprite(labelText, 'blue', new THREE.Vector3(0, majorTickSize + 100, z), true);
          axesGroup.add(label);
        }
        
        // Z축 보조 눈금선
        for (var z = -length; z <= length; z += minorTickInterval) {
          if (z === 0 || z % majorTickInterval === 0) continue; // 원점과 주 눈금은 제외
          
          var tickGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, -minorTickSize, z),
            new THREE.Vector3(0, minorTickSize, z)
          ]);
          var tickMaterial = new THREE.LineBasicMaterial({ color: zColor, opacity: 0.6 });
          tickMaterial.transparent = true;
          var tick = new THREE.Line(tickGeometry, tickMaterial);
          axesGroup.add(tick);
        }
        
        // 축 레이블 (X, Y, Z) - 작은 크기로
        var xLabel = createTextSprite('X', 'red', new THREE.Vector3(length + 300, 0, 0), true);
        var yLabel = createTextSprite('Y', 'green', new THREE.Vector3(0, length + 300, 0), true);
        var zLabel = createTextSprite('Z', 'blue', new THREE.Vector3(0, 0, length + 300), true);
        axesGroup.add(xLabel);
        axesGroup.add(yLabel);
        axesGroup.add(zLabel);
        
        // 원점 레이블
        var originLabel = createTextSprite('O(0,0,0)', 'black', new THREE.Vector3(0, 100, 0), true);
        axesGroup.add(originLabel);
        
        return axesGroup;
      }

      function updateScene() {
        // world
        scene = new THREE.Scene();

        // X, Y, Z 축 표시 (절대좌표) - 상세 버전
        // 길이: 5000mm, 주 눈금 간격: 500mm, 보조 눈금 간격: 100mm, 주 눈금 크기: 80mm, 보조 눈금 크기: 40mm
        var detailedAxes = createDetailedAxes(5000, 500, 100, 80, 40);
        scene.add(detailedAxes);

        // plane
        geometry = new THREE.PlaneGeometry(plane_size, plane_size);
        plane = new THREE.Mesh(geometry, plane_material);
        plane.rotation.x = 0.5 * Math.PI;
        plane.receiveShadow = true;
        scene.add(plane);

        // desk (empty parent)
        geometry = new THREE.BoxBufferGeometry(0, 0, 0);
        desk = new THREE.Mesh(geometry, board_material);

        // board
        geometry = new THREE.BoxBufferGeometry(board_width, board_thickness, board_depth);
        board = new THREE.Mesh(geometry, board_material);
        board.position.y = frame_length + board_thickness;
        board.castShadow = true;
        desk.add(board);

        // desk mat
        if (desk_mat_color) {
          geometry = new THREE.BoxBufferGeometry(700, board_thickness, 420);
          desk_mat = new THREE.Mesh(geometry, desk_mat_material);
          desk_mat.position.y = 2;
          desk_mat.position.z = (board_depth - 420) / 2 + 2;
          board.add(desk_mat);
        }

        // drawer
        if (drawer_color) {
          geometry = new THREE.BoxBufferGeometry(309, 30, 150);
          drawer_down = new THREE.Mesh(geometry, drawer_material);
          if (drawer_position == 1)
            drawer_down.position.x = -(board_width - 309 - 90) / 2;
          else
            drawer_down.position.x = (board_width - 309 - 90) / 2;
          drawer_down.position.y = -32;
          drawer_down.position.z = (board_depth - 150) / 2 + 2;
          board.add(drawer_down);

          geometry1 = new THREE.BoxBufferGeometry(309, 25, 40);
          drawer_up = new THREE.Mesh(geometry1, drawer_material);
          drawer_up.position.y = 32;
          drawer_up.position.z = 56;
          drawer_down.add(drawer_up);
        }

        // moving2와 moving3는 각 책상마다 생성되므로 여기서는 생성하지 않음 (desk_idx 루프에서 생성)

        // frame (leg)
        geometry = new THREE.BoxBufferGeometry(frame_thickness, frame_length, frame_thickness);
        frame = new THREE.Mesh(geometry, frame_material);
        frame.position.x = - (board_width - frame_thickness) / 2;
        frame.position.y = - (frame_length + board_thickness) / 2 - frame_margin;
        frame.position.z = - (board_depth - frame_thickness) / 2;
        frame.castShadow = true;
        board.add(frame);

        // leg pad
        geometry1 = new THREE.CylinderBufferGeometry(frame_thickness / 1.8, frame_thickness / 1.8, 10);
        leg_pad = new THREE.Mesh(geometry1, leg_pad_meterial);
        leg_pad.position.y = - frame_length / 2 - 8;
        frame.add(leg_pad);

        var frame_dup = frame.clone();
        frame_dup.position.x = (board_width - frame_thickness) / 2;
        frame_dup.position.y = - (frame_length + board_thickness) / 2 - frame_margin;
        frame_dup.position.z = - (board_depth - frame_thickness) / 2;
        frame_dup.castShadow = true;
        board.add(frame_dup);

        frame_dup = frame.clone();
        frame_dup.position.x = - (board_width - frame_thickness) / 2;
        frame_dup.position.y = - (frame_length + board_thickness) / 2 - frame_margin;
        frame_dup.position.z = (board_depth - frame_thickness) / 2;
        frame_dup.castShadow = true;
        board.add(frame_dup);

        frame_dup = frame.clone();
        frame_dup.position.x = (board_width - frame_thickness) / 2;
        frame_dup.position.y = - (frame_length + board_thickness) / 2 - frame_margin;
        frame_dup.position.z = (board_depth - frame_thickness) / 2;
        frame_dup.castShadow = true;
        board.add(frame_dup);

        // frame under board
        geometry = new THREE.BoxBufferGeometry(frame_thickness, frame_thickness, board_depth);
        frame = new THREE.Mesh(geometry, frame_material);
        frame.position.x = (board_width - frame_thickness) / 2;
        frame.position.y = - (board_thickness + frame_thickness) / 2 - frame_margin;
        board.add(frame);

        frame = new THREE.Mesh(geometry, frame_material);
        frame.position.x = - (board_width - frame_thickness) / 2;
        frame.position.y = - (board_thickness + frame_thickness) / 2 - frame_margin;
        board.add(frame);

        // mium leg
        if (is_mium) {
          geometry = new THREE.BoxBufferGeometry(frame_thickness, frame_thickness, board_depth);
          mium_leg = new THREE.Mesh(geometry, frame_material);
          mium_leg.position.x = (board_width - frame_thickness) / 2;
          mium_leg.position.y = - frame_length + (frame_thickness - board_thickness) / 2 - frame_margin;
          mium_leg.castShadow = true;
          board.add(mium_leg);

          mium_leg = new THREE.Mesh(geometry, frame_material);
          mium_leg.position.x = - (board_width - frame_thickness) / 2;
          mium_leg.position.y = - frame_length + (frame_thickness - board_thickness) / 2 - frame_margin;
          mium_leg.castShadow = true;
          board.add(mium_leg);
        }

        // frame under board
        geometry = new THREE.BoxBufferGeometry(board_width - 2, frame_thickness, frame_thickness_under_board);
        frame = new THREE.Mesh(geometry, frame_material);
        frame.position.y = - (board_thickness + frame_thickness) / 2 - frame_margin;
        frame.position.z = board_depth / 4;
        board.add(frame);

        var frame_back = new THREE.Mesh(geometry, frame_material);
        frame_back.position.y = - (board_thickness + frame_thickness) / 2 - frame_margin;
        frame_back.position.z = - board_depth / 4;
        board.add(frame_back);

        // fence
        if (fence_color) {
          geometry = new THREE.BoxBufferGeometry(board_width - 5, 200, 18);
          fence = new THREE.Mesh(geometry, fence_material);
          fence.position.y = -100;
          fence.position.z = - frame_thickness_under_board;
          fence.castShadow = true;
          frame_back.add(fence);

          fence = new THREE.Mesh(geometry, fence_material);
          fence.position.y = -305;
          fence.position.z = - frame_thickness_under_board;
          fence.castShadow = true;
          frame_back.add(fence);
        }

        // vertical
        if (vertical_length > 0) {
          geometry = new THREE.BoxBufferGeometry(frame_thickness, vertical_length, frame_thickness);
          var vertical_y_current = vertical_y + (vertical_y_offset * 93.5); // 오프셋 적용
          vertical = new THREE.Mesh(geometry, vertical_material);
          vertical.position.x = - (board_width - frame_thickness) / 2;
          vertical.position.y = vertical_y_current;
          vertical.position.z = - (board_depth + frame_thickness + 5) / 2;
          vertical.castShadow = true;
          board.add(vertical);

          vertical = new THREE.Mesh(geometry, vertical_material);
          vertical.position.x = + (board_width - frame_thickness) / 2;
          vertical.position.y = vertical_y_current;
          vertical.position.z = - (board_depth + frame_thickness + 5) / 2;
          vertical.castShadow = true;
          board.add(vertical);

          // shelves
          // shelf frame (top)
          geometry = new THREE.BoxBufferGeometry(board_width + 8, frame_thickness, frame_thickness + 2);
          frame = new THREE.Mesh(geometry, shelf_frame_material);
          frame.position.x = - (board_width - frame_thickness) / 2;
          frame.position.y = (vertical_length + frame_thickness) / 2 - board_thickness;
          frame.castShadow = true;
          vertical.add(frame);

          // shelf board (top)
          // 선반깊이 360일 때: 기존 200 선반을 200에서 360으로 늘리고, Z축으로 160 이동
          var shelf_z_offset = 0; // 선반 위치 오프셋
          if (shelf_depth == 360) {
            shelf_z_offset = 160; // Z축으로 160 이동
          }
          
          geometry = new THREE.BoxBufferGeometry(board_width - 52, board_thickness, shelf_depth); // 양쪽 20mm씩 줄임 (총 40mm)
          shelf = new THREE.Mesh(geometry, shelf_board_material);
          shelf.position.y = (frame_thickness + board_thickness) / 2;
          if (shelf_direction)
            shelf.position.z = (shelf_depth - frame_thickness + 2) / 2 + shelf_z_offset;
          else 
            shelf.position.z = - (shelf_depth - frame_thickness + 2) / 2 + shelf_z_offset;
          shelf.castShadow = true;
          frame.add(shelf);    

          // shelf duplicate
          var i;
          for (i = 1; i < shelf_num; i++) {
            var frame_dup = frame.clone();
            frame_dup.position.x = - (board_width - frame_thickness) / 2;
            if (shelf_direction)
              frame_dup.position.y = - (vertical_length / 2 + vertical_y) * (i / (shelf_num - 1)) + vertical_length / 2;
            else
              frame_dup.position.y = vertical_length * (0.5 - i / (shelf_num - 1));
            frame_dup.castShadow = true;
            vertical.add(frame_dup);
          }

          // safety leg
          // 선반깊이 360일 때: safety leg도 같은 오프셋 적용
          // 360 선반일 때도 기존 200 선반일 때와 같은 형상 유지
          var safety_leg_z_offset = 0;
          var safety_leg_depth = shelf_depth; // safety leg의 깊이
          if (shelf_depth == 360) {
            safety_leg_z_offset = 0; // Z축 원점으로 이동
            safety_leg_depth = 200; // 360 선반일 때도 200 선반과 같은 형상 유지
          }
          
          geometry = new THREE.BoxBufferGeometry(frame_thickness, frame_thickness, safety_leg_depth);
          frame = new THREE.Mesh(geometry, frame_material);
          frame.position.x = - (board_width - frame_thickness) / 2;
          frame.position.y = - frame_length + (frame_thickness - board_thickness) / 2;
          if (shelf_direction)
            frame.position.z = - (board_depth - safety_leg_depth) / 2 + safety_leg_z_offset;
          else
            frame.position.z = - (board_depth + safety_leg_depth) / 2 + safety_leg_z_offset;
          frame.castShadow = true;
          board.add(frame);

          // safety leg pad
          // 선반 360일 때도 선반 200 바깥방향일 때와 똑같은 형태 유지
          leg_pad = new THREE.Mesh(geometry1, leg_pad_meterial);
          leg_pad.position.y = - frame_thickness / 2 - 8;
          if (shelf_depth == 360) {
            // 선반 360일 때: 선반 200 바깥방향일 때와 동일한 위치 (Z축 원점)
            leg_pad.position.z = - (200 - frame_thickness) / 2;
          } else {
            // 선반 200일 때: 기존 로직 유지
          if (shelf_direction)
              leg_pad.position.z = (safety_leg_depth - frame_thickness) / 2 + safety_leg_z_offset;
          else
              leg_pad.position.z = - (safety_leg_depth - frame_thickness) / 2 + safety_leg_z_offset;
          }
          frame.add(leg_pad);

          // safety leg duplicate
          frame_dup = frame.clone();
          frame_dup.position.x = + (board_width - frame_thickness) / 2;
          frame_dup.position.y = - frame_length + (frame_thickness - board_thickness) / 2;
          if (shelf_direction)
            frame_dup.position.z = - (board_depth - safety_leg_depth) / 2 + safety_leg_z_offset;
          else
            frame_dup.position.z = - (board_depth + safety_leg_depth) / 2 + safety_leg_z_offset;
          frame_dup.castShadow = true;
          board.add(frame_dup);
        }

        // Gieok module
        if (giyeok_position) {
          // 양쪽(4)인 경우 좌우 각각 생성
          var giyeok_positions = [];
          if (giyeok_position == 4) {
            giyeok_positions = [1, 2]; // 왼쪽, 오른쪽
          } else {
            giyeok_positions = [giyeok_position];
          }
          
          for (var g_idx = 0; g_idx < giyeok_positions.length; g_idx++) {
            var g_pos = giyeok_positions[g_idx];
          geometry = new THREE.BoxBufferGeometry(600, board_thickness, 800);
          giyeok_board = new THREE.Mesh(geometry, board_material);
            if (g_pos == 1)
            giyeok_board.position.x = - (board_width - 600) / 2;
            else if (g_pos == 2)
            giyeok_board.position.x = (board_width - 600) / 2;
            else if (g_pos == 3)
              giyeok_board.position.x = 0; // 중앙
          giyeok_board.position.z = (board_depth + 800) / 2;
          giyeok_board.castShadow = true;
            giyeok_board.userData = { isGiyeokBoard: true, giyeokSide: g_pos }; // 반대편에서 찾을 수 있도록 표시
          board.add(giyeok_board);

          // frame (leg)
          geometry = new THREE.BoxBufferGeometry(frame_thickness, frame_length, frame_thickness);
          frame = new THREE.Mesh(geometry, frame_material);
          frame.position.x = - (600 - frame_thickness) / 2;
          frame.position.y = - (frame_length + board_thickness) / 2 - frame_margin;
          frame.position.z = (800 - frame_thickness) / 2;
          frame.castShadow = true;
          giyeok_board.add(frame);

          // leg pad
          leg_pad = new THREE.Mesh(geometry1, leg_pad_meterial);
          leg_pad.position.y = - frame_length / 2 - 8;
          frame.add(leg_pad);

          frame_dup = frame.clone();
          frame_dup.position.x = (600 - frame_thickness) / 2;
          frame_dup.position.y = - (frame_length + board_thickness) / 2 - frame_margin;
          frame_dup.position.z = (800 - frame_thickness) / 2;
          frame_dup.castShadow = true;
          giyeok_board.add(frame_dup);

          // frame under board
          geometry = new THREE.BoxBufferGeometry(600, frame_thickness, frame_thickness);
          frame = new THREE.Mesh(geometry, frame_material);           
          frame.position.y = - (board_thickness + frame_thickness) / 2 - frame_margin;
          frame.position.z = (800 - frame_thickness) / 2;
          giyeok_board.add(frame);

          geometry = new THREE.BoxBufferGeometry(frame_thickness_under_board, frame_thickness, 800 + board_depth / 4);
          frame = new THREE.Mesh(geometry, frame_material);
          frame.position.y = - (board_thickness + frame_thickness) / 2 - frame_margin;
          frame.position.z = - board_depth / 8;
          giyeok_board.add(frame);

            // ㄱ자 하부 서랍은 desk_idx 루프 안에서 각 책상마다 생성됨 (아래 참조)
          }
        }

        // desk array
        for (var i = 1; i < num_desk; i++) {
          var board_dup = board.clone();
          board_dup.position.set((board_width + 10) * i, frame_length + board_thickness, 0);
          desk.add(board_dup);
          // ㄱ자 하부 서랍은 desk_idx 루프에서 생성됨 (아래 참조)
        }

        // desk array in opposite side
        if (opposite_desk_distance != 0) {
          // 기존 선반 끝 위치 계산
          var original_shelf_end_z = board_depth + 10;
          if (vertical_length > 0) {
            if (shelf_direction) { // in
              original_shelf_end_z += frame_thickness * 2;
            } else { // out
              // 선반 360일 때도 200 선반 바깥방향일 때와 같은 거리 유지
              if (shelf_depth == 360) {
                original_shelf_end_z += 200 * 2; // 200 선반 바깥방향일 때와 동일한 거리
              } else {
                original_shelf_end_z += shelf_depth * 2;
              }
            }
          }
          
          // 반대편 선반 끝 위치 계산 (반대편 책상의 앞쪽 끝에서 선반 깊이만큼)
          var opposite_shelf_end_z;
          if (vertical_length > 0) {
            if (shelf_direction) { // in
              opposite_shelf_end_z = -frame_thickness * 2; // 반대편 책상 앞쪽에서 선반 깊이만큼
            } else { // out
              if (shelf_depth == 360) {
                opposite_shelf_end_z = -200 * 2; // 반대편 책상 앞쪽에서 선반 깊이만큼
              } else {
                opposite_shelf_end_z = -shelf_depth * 2; // 반대편 책상 앞쪽에서 선반 깊이만큼
              }
            }
          } else {
            opposite_shelf_end_z = 0; // 선반이 없으면 반대편 책상 앞쪽 끝
          }
          
          // 반대편 책상의 Z 위치: 선택한 거리만큼 이동
          // 거리 값이 양수면 원래 책상의 Z 위치에서 +거리, 음수면 -거리
          // 원래 책상의 Z 위치는 0이므로, 거리 값 그대로 사용
          // 책상 깊이에 따른 추가 Z축 오프셋 적용
          var depth_z_offset = 0;
          if (board_depth == 700) {
            depth_z_offset = -100;
          } else if (board_depth == 800) {
            depth_z_offset = -200;
          } else if (board_depth == 1000) {
            depth_z_offset = -400;
          } else if (board_depth == 1200) {
            depth_z_offset = -600;
          }
          var opposite_desk_z_position = opposite_desk_distance + depth_z_offset;
          
          for (var i = 0; i < num_desk; i++) {
            var board_dup = board.clone();
            
            // 반대편 책상의 X 위치: 원래 책상과 동일한 상대 위치 사용
            // 첫 번째 책상은 0, 두 번째부터는 (board_width + 10) * i
            var opposite_board_x;
            if (i == 0) {
              opposite_board_x = 0; // 첫 번째 책상은 원점
            } else {
              opposite_board_x = (board_width + 10) * i; // 나머지는 원래와 동일한 상대 위치
            }
            
            // 거울 반사: Y축 기준으로 반전 (scale.z = -1)
            // Y축 기준 미러링은 Z축을 반전시키는 것
            board_dup.scale.z = -1;
            
            // 반대편 책상 위치: 기존 선반 끝과 새 선반 끝이 만나는 위치에서 -20 이동
            board_dup.position.set(opposite_board_x, frame_length + board_thickness, opposite_desk_z_position);
            
            desk.add(board_dup);    
            
            // 반대편 책상의 offset 계산 (desk_idx와 동일한 인덱스 사용)
            var opposite_desk_offset_x = (board_width + 10) * (i - 0.5 * (num_desk - 1));
            // 반대편 책상 Z 위치: 계산된 위치 사용
            var opposite_desk_z = opposite_desk_z_position;
            
            // Y축 기준 미러링: board_dup에 scale.z = -1이 적용되어 있으므로
            // ㄱ자 모듈과 하부 서랍은 board_dup의 자식이므로 자동으로 앞뒤 반전됨
            // 별도로 추가하는 부착형 서랍도 Y축 기준 미러링에 맞게 조정 필요
            
            // 반대편 부착형 서랍은 하부옵션 그룹에 포함됨 (아래 참조)
            
            // 반대편 수납 슬라이딩도어 1단
            if (storage_sliding1_color && vertical_length > 0) {
              var storage_sliding1_width = board_width - 80;
              var storage_sliding1_depth = 360;
              var storage_sliding1_height = 400;
              var vertical_y_current = vertical_y + (vertical_y_offset * 93.5);
              var vertical_bottom_y = vertical_y_current - vertical_length / 2;
              var storage_height_position = 0;
              if (vertical_length_idx == 3) {
                storage_height_position = 1200;
              } else if (vertical_length_idx == 4) {
                storage_height_position = 1400;
              }
              var storage_center_y = vertical_bottom_y + storage_height_position + storage_sliding1_height / 2 + (storage_y_offset * 93.5);
              // 선반 깊이 200이고 방향이 바깥쪽일 때도 선반 360과 동일한 위치
              var shelf_z_offset = 0;
              if (shelf_depth == 360 || (shelf_depth == 200 && shelf_direction == 0)) {
                shelf_z_offset = 160;
              }
              var shelf_z_relative = shelf_direction == 0 ? - (shelf_depth - frame_thickness + 2) / 2 : (shelf_depth - frame_thickness + 2) / 2;
              var vertical_z = - (board_depth + frame_thickness + 5) / 2;
              var shelf_z_absolute = vertical_z + shelf_z_relative + shelf_z_offset;
              geometry = new THREE.BoxBufferGeometry(storage_sliding1_width, storage_sliding1_height, storage_sliding1_depth);
              var storage_sliding1_opposite = new THREE.Mesh(geometry, storage_sliding1_material);
              // 반대편 앞뒤 반전: 수직부재는 반대편 책상의 앞쪽에 위치하므로 Z 좌표 반전
              storage_sliding1_opposite.position.set(opposite_desk_offset_x, storage_center_y, opposite_desk_z - shelf_z_absolute);
              storage_sliding1_opposite.castShadow = true;
              scene.add(storage_sliding1_opposite);
            }
            
            // 반대편 수납 슬라이딩도어 2단
            if (storage_sliding2_color && vertical_length > 0) {
              var storage_sliding2_width = board_width - 80;
              var storage_sliding2_depth = 360;
              var storage_sliding2_height = 800;
              var vertical_y_current = vertical_y + (vertical_y_offset * 93.5);
              var vertical_bottom_y = vertical_y_current - vertical_length / 2;
              var storage_height_position = 0;
              if (vertical_length_idx == 3) {
                storage_height_position = 1200;
              } else if (vertical_length_idx == 4) {
                storage_height_position = 1400;
              }
              var storage_center_y = vertical_bottom_y + storage_height_position + storage_sliding2_height / 2 + (storage_y_offset * 93.5);
              // 선반 깊이 200이고 방향이 바깥쪽일 때도 선반 360과 동일한 위치
              var shelf_z_offset = 0;
              if (shelf_depth == 360 || (shelf_depth == 200 && shelf_direction == 0)) {
                shelf_z_offset = 160;
              }
              var shelf_z_relative = shelf_direction == 0 ? - (shelf_depth - frame_thickness + 2) / 2 : (shelf_depth - frame_thickness + 2) / 2;
              var vertical_z = - (board_depth + frame_thickness + 5) / 2;
              var shelf_z_absolute = vertical_z + shelf_z_relative + shelf_z_offset;
              geometry = new THREE.BoxBufferGeometry(storage_sliding2_width, storage_sliding2_height, storage_sliding2_depth);
              var storage_sliding2_opposite = new THREE.Mesh(geometry, storage_sliding2_material);
              // 반대편 앞뒤 반전: 수직부재는 반대편 책상의 앞쪽에 위치하므로 Z 좌표 반전
              storage_sliding2_opposite.position.set(opposite_desk_offset_x, storage_center_y, opposite_desk_z - shelf_z_absolute);
              storage_sliding2_opposite.castShadow = true;
              scene.add(storage_sliding2_opposite);
            }
            
            // 반대편 수납 플랩도어
            if (storage_flap_color && vertical_length > 0) {
              var storage_flap_width = board_width - 80;
              var storage_flap_depth = 360;
              var storage_flap_height = 400;
              var vertical_y_current = vertical_y + (vertical_y_offset * 93.5);
              var vertical_bottom_y = vertical_y_current - vertical_length / 2;
              var storage_height_position = 0;
              var model_height = 1400; // 기본 모델 높이
              if (vertical_length_idx == 3) {
                storage_height_position = 1200;
                model_height = 1400;
              } else if (vertical_length_idx == 4) {
                storage_height_position = 1400;
                model_height = 1800; // 1860에 가장 가까운 모델
              }
              var storage_center_y = vertical_bottom_y + storage_height_position + storage_flap_height / 2 + (storage_y_offset * 93.5);
              // 선반 깊이 200이고 방향이 바깥쪽일 때도 선반 360과 동일한 위치
              var shelf_z_offset = 0;
              if (shelf_depth == 360 || (shelf_depth == 200 && shelf_direction == 0)) {
                shelf_z_offset = 160;
              }
              var shelf_z_relative = shelf_direction == 0 ? - (shelf_depth - frame_thickness + 2) / 2 : (shelf_depth - frame_thickness + 2) / 2;
              var vertical_z = - (board_depth + frame_thickness + 5) / 2;
              var shelf_z_absolute = vertical_z + shelf_z_relative + shelf_z_offset;
              
              if (storage_flap_models[model_height]) {
                var storage_flap_opposite = storage_flap_models[model_height].clone();
                storage_flap_opposite.traverse(function(child) {
                  if (child instanceof THREE.Mesh) {
                    child.material = storage_flap_material;
                    child.castShadow = true;
                    child.receiveShadow = true;
                  }
                });
                // 반대편 앞뒤 반전: 수직부재는 반대편 책상의 앞쪽에 위치하므로 Z 좌표 반전
                storage_flap_opposite.position.set(opposite_desk_offset_x, storage_center_y, opposite_desk_z - shelf_z_absolute);
                scene.add(storage_flap_opposite);
              } else {
                geometry = new THREE.BoxBufferGeometry(storage_flap_width, storage_flap_height, storage_flap_depth);
                var storage_flap_opposite = new THREE.Mesh(geometry, storage_flap_material);
                // 반대편 앞뒤 반전: 수직부재는 반대편 책상의 앞쪽에 위치하므로 Z 좌표 반전
                storage_flap_opposite.position.set(opposite_desk_offset_x, storage_center_y, opposite_desk_z - shelf_z_absolute);
                storage_flap_opposite.castShadow = true;
                scene.add(storage_flap_opposite);
              }
            }
            
            // 반대편 수납 플랩스테이도어
            if (storage_flapstay_color && vertical_length > 0) {
              var storage_flapstay_width = board_width - 80;
              var storage_flapstay_depth = 360;
              var storage_flapstay_height = 400;
              var vertical_y_current = vertical_y + (vertical_y_offset * 93.5);
              var vertical_bottom_y = vertical_y_current - vertical_length / 2;
              var storage_height_position = 0;
              if (vertical_length_idx == 3) {
                storage_height_position = 1200;
              } else if (vertical_length_idx == 4) {
                storage_height_position = 1400;
              }
              var storage_center_y = vertical_bottom_y + storage_height_position + storage_flapstay_height / 2 + (storage_y_offset * 93.5);
              // 선반 깊이 200이고 방향이 바깥쪽일 때도 선반 360과 동일한 위치
              var shelf_z_offset = 0;
              if (shelf_depth == 360 || (shelf_depth == 200 && shelf_direction == 0)) {
                shelf_z_offset = 160;
              }
              var shelf_z_relative = shelf_direction == 0 ? - (shelf_depth - frame_thickness + 2) / 2 : (shelf_depth - frame_thickness + 2) / 2;
              var vertical_z = - (board_depth + frame_thickness + 5) / 2;
              var shelf_z_absolute = vertical_z + shelf_z_relative + shelf_z_offset;
              
              // 모델 높이 결정
              var model_height = 1400; // 기본 모델 높이
              if (vertical_length_idx == 3) {
                model_height = 1400;
              } else if (vertical_length_idx == 4) {
                model_height = 2060; // 1860에 가장 가까운 모델
              }
              
              if (storage_flapstay_models[model_height]) {
                var storage_flapstay_opposite = storage_flapstay_models[model_height].clone();
                storage_flapstay_opposite.traverse(function(child) {
                  if (child instanceof THREE.Mesh) {
                    child.material = storage_flapstay_material;
                    child.castShadow = true;
                    child.receiveShadow = true;
                  }
                });
                // 반대편 앞뒤 반전: 수직부재는 반대편 책상의 앞쪽에 위치하므로 Z 좌표 반전
                storage_flapstay_opposite.position.set(opposite_desk_offset_x, storage_center_y, opposite_desk_z - shelf_z_absolute);
                scene.add(storage_flapstay_opposite);
              } else {
                // GLB 모델이 로드되지 않은 경우 기본 박스 사용
                geometry = new THREE.BoxBufferGeometry(storage_flapstay_width, storage_flapstay_height, storage_flapstay_depth);
                var storage_flapstay_opposite = new THREE.Mesh(geometry, storage_flapstay_material);
                // 반대편 앞뒤 반전: 수직부재는 반대편 책상의 앞쪽에 위치하므로 Z 좌표 반전
                storage_flapstay_opposite.position.set(opposite_desk_offset_x, storage_center_y, opposite_desk_z - shelf_z_absolute);
                storage_flapstay_opposite.castShadow = true;
                scene.add(storage_flapstay_opposite);
              }
            }
            
            // 반대편 하부옵션 복사 - 모든 하부옵션을 하나의 그룹으로 묶어서 미러링
            // 책상처럼 scale.z = -1로 미러링하여 일관되게 처리
            var oppositeBottomOptionsGroup = new THREE.Group();
            
            // [30] 하부옵션 - 2단 이동 서랍
            // 책상처럼 미러링: 좌우는 그대로 유지, scale.z = -1로 앞뒤만 반전
            if (moving2_color) {
              geometry = new THREE.BoxBufferGeometry(300, 585, 400);
              var moving2_opposite = new THREE.Mesh(geometry, moving2_material);
              moving2_opposite.position.y = 585 / 2 + 50;
              
              // 원본과 동일한 X 위치 (좌우 반전 없음)
              var moving2_x;
              if (moving2_position == 1) {
                moving2_x = - (board_width - 400) / 2; // 좌측
              } else {
                moving2_x = (board_width - 400) / 2; // 우측
              }
              moving2_opposite.position.x = moving2_x;
              moving2_opposite.position.z = (board_depth - 450) / 2;
              moving2_opposite.castShadow = true;
              oppositeBottomOptionsGroup.add(moving2_opposite);
              
              // drawer 1 and 2
              geometry = new THREE.BoxBufferGeometry(300, 275, 20);
              var drawer1_opposite = new THREE.Mesh(geometry, moving2_material);
              drawer1_opposite.position.y = (585 - 275) / 2;
              drawer1_opposite.position.z = 220;
              moving2_opposite.add(drawer1_opposite);
              
              var drawer2_opposite = new THREE.Mesh(geometry, moving2_material);
              drawer2_opposite.position.y = -(585 - 275) / 2;
              drawer2_opposite.position.z = 220;
              moving2_opposite.add(drawer2_opposite);
              
              // wheel
              geometry = new THREE.CylinderBufferGeometry(25, 25, 30);
              var wheel_opposite = new THREE.Mesh(geometry, leg_pad_meterial);
              wheel_opposite.position.set(-130, -320, 180);
              wheel_opposite.rotation.x = Math.PI / 2;
              moving2_opposite.add(wheel_opposite);
              
              wheel_opposite = new THREE.Mesh(geometry, leg_pad_meterial);
              wheel_opposite.position.set(130, -320, 180);
              wheel_opposite.rotation.x = Math.PI / 2;
              moving2_opposite.add(wheel_opposite);
              
              wheel_opposite = new THREE.Mesh(geometry, leg_pad_meterial);
              wheel_opposite.position.set(-130, -320, -180);
              wheel_opposite.rotation.x = Math.PI / 2;
              moving2_opposite.add(wheel_opposite);
              
              wheel_opposite = new THREE.Mesh(geometry, leg_pad_meterial);
              wheel_opposite.position.set(130, -320, -180);
              wheel_opposite.rotation.x = Math.PI / 2;
              moving2_opposite.add(wheel_opposite);
            }
            
            // [31] 하부옵션 - 3단 이동 서랍
            // 책상처럼 미러링: 좌우는 그대로 유지, scale.z = -1로 앞뒤만 반전
            if (moving3_color) {
              geometry = new THREE.BoxBufferGeometry(400, 585, 580);
              var moving3_opposite = new THREE.Mesh(geometry, moving3_material);
              moving3_opposite.position.y = 585 / 2 + 50;
              
              // 원본과 동일한 X 위치 (좌우 반전 없음)
              var moving3_x;
              if (moving3_position == 1) {
                moving3_x = - (board_width - 500) / 2; // 좌측
              } else {
                moving3_x = (board_width - 500) / 2; // 우측
              }
              moving3_opposite.position.x = moving3_x;
              moving3_opposite.position.z = (board_depth - 640) / 2;
              moving3_opposite.castShadow = true;
              oppositeBottomOptionsGroup.add(moving3_opposite);
              
              // drawer 1, 2, 3
              geometry = new THREE.BoxBufferGeometry(400, 190, 20);
              var drawer1_opposite = new THREE.Mesh(geometry, moving3_material);
              drawer1_opposite.position.y = (585 - 190) / 2;
              drawer1_opposite.position.z = 310;
              moving3_opposite.add(drawer1_opposite);
              
              var drawer2_opposite = new THREE.Mesh(geometry, moving3_material);
              drawer2_opposite.position.y = 0;
              drawer2_opposite.position.z = 310;
              moving3_opposite.add(drawer2_opposite);
              
              var drawer3_opposite = new THREE.Mesh(geometry, moving3_material);
              drawer3_opposite.position.y = - (585 - 190) / 2;
              drawer3_opposite.position.z = 310;
              moving3_opposite.add(drawer3_opposite);
              
              // wheel
              geometry = new THREE.CylinderBufferGeometry(25, 25, 30);
              var wheel_opposite = new THREE.Mesh(geometry, leg_pad_meterial);
              wheel_opposite.position.set(-180, -320, 280);
              wheel_opposite.rotation.x = Math.PI / 2;
              moving3_opposite.add(wheel_opposite);
              
              wheel_opposite = new THREE.Mesh(geometry, leg_pad_meterial);
              wheel_opposite.position.set(180, -320, 280);
              wheel_opposite.rotation.x = Math.PI / 2;
              moving3_opposite.add(wheel_opposite);
              
              wheel_opposite = new THREE.Mesh(geometry, leg_pad_meterial);
              wheel_opposite.position.set(-180, -320, -280);
              wheel_opposite.rotation.x = Math.PI / 2;
              moving3_opposite.add(wheel_opposite);
              
              wheel_opposite = new THREE.Mesh(geometry, leg_pad_meterial);
              wheel_opposite.position.set(180, -320, -280);
              wheel_opposite.rotation.x = Math.PI / 2;
              moving3_opposite.add(wheel_opposite);
            }
            
            // 부착형 서랍들도 그룹에 추가 (상대 위치로)
            if (attach1_left_color) {
              var attach_top_y = frame_length + board_thickness - 60;
              var left_leg_inner_x = - (board_width - frame_thickness) / 2 + frame_thickness / 2 + 155;
              var attach1_opposite = createOppositeAttachDrawerForGroup(1, attach1_left_color, left_leg_inner_x, attach_top_y, board_depth / 2 - 200);
              if (attach1_opposite) oppositeBottomOptionsGroup.add(attach1_opposite);
            }
            if (attach1_right_color) {
              var attach_top_y = frame_length + board_thickness - 60;
              var right_leg_inner_x = (board_width - frame_thickness) / 2 - frame_thickness / 2 - 155;
              var attach1_opposite = createOppositeAttachDrawerForGroup(1, attach1_right_color, right_leg_inner_x, attach_top_y, board_depth / 2 - 200);
              if (attach1_opposite) oppositeBottomOptionsGroup.add(attach1_opposite);
            }
            if (attach2_left_color) {
              var attach_top_y = frame_length + board_thickness - 60;
              var left_leg_inner_x = - (board_width - frame_thickness) / 2 + frame_thickness / 2 + 155;
              var attach2_opposite = createOppositeAttachDrawerForGroup(2, attach2_left_color, left_leg_inner_x, attach_top_y, board_depth / 2 - 200);
              if (attach2_opposite) oppositeBottomOptionsGroup.add(attach2_opposite);
            }
            if (attach2_right_color) {
              var attach_top_y = frame_length + board_thickness - 60;
              var right_leg_inner_x = (board_width - frame_thickness) / 2 - frame_thickness / 2 - 155;
              var attach2_opposite = createOppositeAttachDrawerForGroup(2, attach2_right_color, right_leg_inner_x, attach_top_y, board_depth / 2 - 200);
              if (attach2_opposite) oppositeBottomOptionsGroup.add(attach2_opposite);
            }
            if (attach3_left_color) {
              var attach_top_y = frame_length + board_thickness - 60;
              var left_leg_inner_x = - (board_width - frame_thickness) / 2 + frame_thickness / 2 + 155;
              var attach3_opposite = createOppositeAttachDrawerForGroup(3, attach3_left_color, left_leg_inner_x, attach_top_y, board_depth / 2 - 200);
              if (attach3_opposite) oppositeBottomOptionsGroup.add(attach3_opposite);
            }
            if (attach3_right_color) {
              var attach_top_y = frame_length + board_thickness - 60;
              var right_leg_inner_x = (board_width - frame_thickness) / 2 - frame_thickness / 2 - 155;
              var attach3_opposite = createOppositeAttachDrawerForGroup(3, attach3_right_color, right_leg_inner_x, attach_top_y, board_depth / 2 - 200);
              if (attach3_opposite) oppositeBottomOptionsGroup.add(attach3_opposite);
            }
            
            // 그룹에 미러링 적용 (책상처럼 scale.z = -1)
            oppositeBottomOptionsGroup.scale.z = -1;
            // 그룹 위치 설정 (반대편 책상 위치 기준)
            oppositeBottomOptionsGroup.position.set(opposite_desk_offset_x, 0, opposite_desk_z);
            // 익스포트에서 제외하기 위한 태그 추가
            oppositeBottomOptionsGroup.userData = { isOppositeGroup: true };
            scene.add(oppositeBottomOptionsGroup);
            
            // 반대편 파티션 옵션 복사
            // 파티션 ver_L: 반대편 첫 번째 책상의 왼쪽 파티션
            if (parti_ver_L_height > 0 && i == 0) {
              var board_top_y = frame_length + board_thickness;
              var parti_bottom_y;
              var parti_center_y;
              var parti_width = 800;
              
              switch (parti_ver_L_height) {
                case 460:
                  parti_bottom_y = board_top_y;
                  parti_center_y = parti_bottom_y + parti_ver_L_height / 2 + 15;
                  break;
                case 800:
                  parti_bottom_y = board_top_y - 300;
                  parti_center_y = parti_bottom_y + parti_ver_L_height / 2;
                  break;
                case 1200:
                case 1400:
                case 1600:
                case 1800:
                  parti_bottom_y = board_top_y - 700;
                  parti_center_y = parti_bottom_y + parti_ver_L_height / 2;
                  break;
                default:
                  parti_bottom_y = board_top_y;
                  parti_center_y = parti_bottom_y + parti_ver_L_height / 2;
              }
              
              var parti_x_position;
              if (vertical_length > 0 && shelf_num > 0) {
                var vertical_z = - (board_depth + frame_thickness + 5) / 2;
                var shelf_z_relative;
                if (shelf_direction == 0) {
                  shelf_z_relative = - (shelf_depth - frame_thickness + 2) / 2;
                } else {
                  shelf_z_relative = (shelf_depth - frame_thickness + 2) / 2;
                }
                var shelf_z_absolute = vertical_z + shelf_z_relative;
                parti_x_position = - board_width / 2 - 6;
              } else {
                parti_x_position = - board_width / 2;
              }
              
              geometry = new THREE.BoxBufferGeometry(12, parti_ver_L_height, parti_width);
              var parti_ver_L_opposite = new THREE.Mesh(geometry, parti_ver_L_material);
              // 반대편 위치: 그룹 내 상대 위치로 설정 (미러링 적용됨)
              // 파티션 Z 위치: 책상 깊이 1000 이상이고 하부옵션 전면 정렬 선택 시
              var parti_z_pos = 0;
              if (board_depth >= 1000 && parti_z_align_front == 1) {
                parti_z_pos = board_depth / 2 - 200; // 하부옵션 전면과 같은 라인 (그룹 중심 기준)
              }
              parti_ver_L_opposite.position.set(parti_x_position, parti_center_y, parti_z_pos);
              parti_ver_L_opposite.castShadow = true;
              oppositeBottomOptionsGroup.add(parti_ver_L_opposite);
            }
            
            // 파티션 ver_R: 반대편 마지막 책상의 오른쪽 파티션
            if (i == num_desk - 1 && parti_ver_R_height > 0) {
              var board_top_y = frame_length + board_thickness;
              var parti_bottom_y;
              var parti_center_y;
              var parti_width = 800;
              
              switch (parti_ver_R_height) {
                case 460:
                  parti_bottom_y = board_top_y;
                  parti_center_y = parti_bottom_y + parti_ver_R_height / 2 + 15;
                  break;
                case 800:
                  parti_bottom_y = board_top_y - 300;
                  parti_center_y = parti_bottom_y + parti_ver_R_height / 2;
                  break;
                case 1200:
                case 1400:
                case 1600:
                case 1800:
                  parti_bottom_y = board_top_y - 700;
                  parti_center_y = parti_bottom_y + parti_ver_R_height / 2;
                  break;
                default:
                  parti_bottom_y = board_top_y;
                  parti_center_y = parti_bottom_y + parti_ver_R_height / 2;
              }
              
              var parti_x_position;
              if (vertical_length > 0 && shelf_num > 0) {
                var vertical_z = - (board_depth + frame_thickness + 5) / 2;
                var shelf_z_relative;
                if (shelf_direction == 0) {
                  shelf_z_relative = - (shelf_depth - frame_thickness + 2) / 2;
                } else {
                  shelf_z_relative = (shelf_depth - frame_thickness + 2) / 2;
                }
                var shelf_z_absolute = vertical_z + shelf_z_relative;
                parti_x_position = board_width / 2 + 6;
              } else {
                parti_x_position = board_width / 2;
              }
              
              geometry = new THREE.BoxBufferGeometry(12, parti_ver_R_height, parti_width);
              var parti_ver_R_opposite = new THREE.Mesh(geometry, parti_ver_R_material);
              // 반대편 위치: 그룹 내 상대 위치로 설정 (미러링 적용됨)
              // 파티션 Z 위치: 책상 깊이 1000 이상이고 하부옵션 전면 정렬 선택 시
              var parti_z_pos = 0;
              if (board_depth >= 1000 && parti_z_align_front == 1) {
                parti_z_pos = board_depth / 2 - 200; // 하부옵션 전면과 같은 라인 (그룹 중심 기준)
              }
              parti_ver_R_opposite.position.set(parti_x_position, parti_center_y, parti_z_pos);
              parti_ver_R_opposite.castShadow = true;
              oppositeBottomOptionsGroup.add(parti_ver_R_opposite);
            }
            
            // 파티션 ver_M: 반대편 중첩 위치 파티션 (책상과 책상 사이)
            // 각 책상 사이에 중첩위치 파티션 생성
            if (parti_ver_M_height > 0 && num_desk > 1 && i < num_desk - 1) {
              var board_top_y = frame_length + board_thickness;
              var parti_bottom_y;
              var parti_center_y;
              var parti_width = 800;
              
              switch (parti_ver_M_height) {
                case 460:
                  parti_bottom_y = board_top_y;
                  parti_center_y = parti_bottom_y + parti_ver_M_height / 2 + 15;
                  break;
                case 800:
                  parti_bottom_y = board_top_y - 300;
                  parti_center_y = parti_bottom_y + parti_ver_M_height / 2;
                  break;
                case 1200:
                case 1400:
                case 1600:
                case 1800:
                  parti_bottom_y = board_top_y - 700;
                  parti_center_y = parti_bottom_y + parti_ver_M_height / 2;
                  break;
                default:
                  parti_bottom_y = board_top_y;
                  parti_center_y = parti_bottom_y + parti_ver_M_height / 2;
              }
              
              // 중첩 위치: 현재 책상(i)과 다음 책상(i+1) 사이
              // 그룹 내 상대 위치로 계산 (그룹 중심이 현재 책상 중심이므로)
              // 현재 책상의 그룹 내 상대 X 위치: 0 (그룹 중심이 현재 책상 중심)
              // 다음 책상의 그룹 내 상대 X 위치: (board_width + 10) (다음 책상까지의 거리)
              // 현재 책상의 오른쪽 끝: 0 + board_width / 2 = board_width / 2
              // 다음 책상의 왼쪽 끝: (board_width + 10) - board_width / 2 = board_width / 2 + 10
              // 중첩 위치는 이 두 위치의 중간: (board_width / 2 + board_width / 2 + 10) / 2 = board_width / 2 + 5
              var overlap_x = board_width / 2 + 5;
              
              // 파티션 X 위치 계산: 선반이 있을 경우 선반의 제일 바깥쪽으로
              var parti_x_position;
              if (vertical_length > 0 && shelf_num > 0) {
                parti_x_position = overlap_x + 6; // 중첩 위치에서 파티션 두께의 절반만큼 오른쪽
              } else {
                parti_x_position = overlap_x; // 중첩 위치에 정확히 배치
              }
              
              geometry = new THREE.BoxBufferGeometry(12, parti_ver_M_height, parti_width);
              var parti_ver_M_opposite = new THREE.Mesh(geometry, parti_ver_M_material);
              // 반대편 위치: 그룹 내 상대 위치로 설정 (미러링 적용됨)
              // 파티션 Z 위치: 책상 깊이 1000 이상이고 하부옵션 전면 정렬 선택 시
              var parti_z_pos = 0;
              if (board_depth >= 1000 && parti_z_align_front == 1) {
                parti_z_pos = board_depth / 2 - 200; // 하부옵션 전면과 같은 라인 (그룹 중심 기준)
              }
              parti_ver_M_opposite.position.set(parti_x_position, parti_center_y, parti_z_pos);
              parti_ver_M_opposite.castShadow = true;
              oppositeBottomOptionsGroup.add(parti_ver_M_opposite);
            }
            
            // 파티션 hol_B: 반대편 전면 파티션
            // 거리 -1030일 때는 전면파티션 복재 안함
            if (parti_hol_B_width > 0 && opposite_desk_distance != -1030) {
              var board_top_y = frame_length + board_thickness;
              var parti_hol_B_height = 800;
              var parti_bottom_y = board_top_y - 200;
              var parti_center_y = parti_bottom_y + parti_hol_B_height / 2 - 100;
              
              // 원래 전면파티션과 동일한 Z 위치 계산 로직 사용
              var parti_z_position;
              if (vertical_length == 0 || shelf_num == 0) {
                parti_z_position = -board_depth / 2 - 6;
              } else {
                var vertical_z = - (board_depth + frame_thickness + 5) / 2;
                var shelf_z_relative;
                if (shelf_direction == 0) {
                  shelf_z_relative = - (shelf_depth - frame_thickness + 2) / 2;
                } else {
                  shelf_z_relative = (shelf_depth - frame_thickness + 2) / 2;
                }
                var shelf_z_absolute = vertical_z + shelf_z_relative;
                var shelf_front_edge;
                var shelf_back_edge;
                
                if (shelf_direction == 0) {
                  shelf_back_edge = shelf_z_absolute + shelf_depth / 2;
                  shelf_front_edge = shelf_z_absolute - shelf_depth / 2;
                } else {
                  shelf_front_edge = shelf_z_absolute + shelf_depth / 2;
                  shelf_back_edge = shelf_z_absolute - shelf_depth / 2;
                }
                
                // 원래 전면파티션과 동일하게 뒤쪽 끝 사용
                var shelf_farthest_edge = shelf_back_edge;
                parti_z_position = shelf_farthest_edge - 6;
              }
              
              // 선반의 바깥방향(OUT) 선택 시 Z축으로 -200 이동 (원래와 동일)
              if (vertical_length > 0 && shelf_num > 0 && shelf_direction == 0) {
                parti_z_position -= 200;
              }
              
              geometry = new THREE.BoxBufferGeometry(parti_hol_B_width, parti_hol_B_height, 12);
              var parti_hol_B_opposite = new THREE.Mesh(geometry, parti_hol_B_material);
              // 반대편 위치: 그룹 내 상대 위치로 설정 (Z=0 기준, 그룹의 scale.z = -1로 미러링됨)
              // 원래 전면파티션의 Z 위치를 그대로 사용하면 그룹 미러링으로 올바르게 반전됨
              parti_hol_B_opposite.position.set(0, parti_center_y, parti_z_position);
              parti_hol_B_opposite.castShadow = true;
              oppositeBottomOptionsGroup.add(parti_hol_B_opposite);
            }
            
            // 반대편 ㄱ자 하부 서랍 (각 책상마다 생성) - 그룹에 추가하여 미러링
            if (giyeok_position) {
              var giyeok_positions = [];
              if (giyeok_position == 4) {
                giyeok_positions = [1, 2]; // 왼쪽, 오른쪽
              } else {
                giyeok_positions = [giyeok_position];
              }
              
              var giyeok_attach_top_y = frame_length + board_thickness - 60;
              
              for (var g_idx = 0; g_idx < giyeok_positions.length; g_idx++) {
                var g_pos = giyeok_positions[g_idx];
                
                // 왼쪽 ㄱ자 하부 서랍
                if (g_pos == 1 || g_pos == 4) {
                  if (giyeok_drawer_type_left == 1) {
                    createOppositeGiyeokDrawer(1, giyeok_attach1_left_color, opposite_desk_offset_x, giyeok_attach_top_y, opposite_desk_z, true, oppositeBottomOptionsGroup);
                  } else if (giyeok_drawer_type_left == 2) {
                    createOppositeGiyeokDrawer(2, giyeok_attach2_left_color, opposite_desk_offset_x, giyeok_attach_top_y, opposite_desk_z, true, oppositeBottomOptionsGroup);
                  } else if (giyeok_drawer_type_left == 3) {
                    createOppositeGiyeokDrawer(3, giyeok_attach3_left_color, opposite_desk_offset_x, giyeok_attach_top_y, opposite_desk_z, true, oppositeBottomOptionsGroup);
                  } else if (giyeok_drawer_type_left == 4) {
                    createOppositeGiyeokDrawer(4, giyeok_moving2_left_color, opposite_desk_offset_x, giyeok_attach_top_y, opposite_desk_z, true, oppositeBottomOptionsGroup);
                  } else if (giyeok_drawer_type_left == 5) {
                    createOppositeGiyeokDrawer(5, giyeok_moving3_left_color, opposite_desk_offset_x, giyeok_attach_top_y, opposite_desk_z, true, oppositeBottomOptionsGroup);
                  }
                }
                
                // 오른쪽 ㄱ자 하부 서랍
                if (g_pos == 2 || g_pos == 4) {
                  if (giyeok_drawer_type_right == 1) {
                    createOppositeGiyeokDrawer(1, giyeok_attach1_right_color, opposite_desk_offset_x, giyeok_attach_top_y, opposite_desk_z, false, oppositeBottomOptionsGroup);
                  } else if (giyeok_drawer_type_right == 2) {
                    createOppositeGiyeokDrawer(2, giyeok_attach2_right_color, opposite_desk_offset_x, giyeok_attach_top_y, opposite_desk_z, false, oppositeBottomOptionsGroup);
                  } else if (giyeok_drawer_type_right == 3) {
                    createOppositeGiyeokDrawer(3, giyeok_attach3_right_color, opposite_desk_offset_x, giyeok_attach_top_y, opposite_desk_z, false, oppositeBottomOptionsGroup);
                  } else if (giyeok_drawer_type_right == 4) {
                    createOppositeGiyeokDrawer(4, giyeok_moving2_right_color, opposite_desk_offset_x, giyeok_attach_top_y, opposite_desk_z, false, oppositeBottomOptionsGroup);
                  } else if (giyeok_drawer_type_right == 5) {
                    createOppositeGiyeokDrawer(5, giyeok_moving3_right_color, opposite_desk_offset_x, giyeok_attach_top_y, opposite_desk_z, false, oppositeBottomOptionsGroup);
                  }
                }
              }
            }
          }
        }

        // move desk array to center
        desk.position.set(-(board_width + 10) * 0.5 * (num_desk - 1), 0, 0);
        scene.add(desk);
        
        // 상품코드 및 URL 업데이트 (skipURLUpdate 플래그 확인)
        if (!skipURLUpdate) {
          var codeInput = document.getElementById('product_code_input');
          if (codeInput) {
            var newCode = generateProductCode();
            // 코드가 변경된 경우에만 입력 필드와 URL 업데이트
            if (codeInput.value !== newCode) {
              codeInput.value = newCode;
            }
          }
          // URL 업데이트는 디바운싱이 적용된 updateURL()에서 처리
          updateURL();
        }
        
        // 옵션 명세 리스트 업데이트
        updateOptionSpecList();

        // 모든 옵션들을 각 책상마다 복사
        // desk_offset_x는 책상이 중앙 정렬된 후의 실제 위치를 반영해야 함
        for (var desk_idx = 0; desk_idx < num_desk; desk_idx++) {
          // 책상의 실제 X 위치 = 책상 배열 루프에서 설정한 위치 (i * (board_width + 10)) - 중앙 정렬 오프셋
          var desk_offset_x = (board_width + 10) * (desk_idx - 0.5 * (num_desk - 1));
          
          // 부착형 서랍 1단 (좌우 각각 1개만 설치 가능)
          // 부착형 서랍 1단, 부착형 서랍 2단, 본체함은 좌 1개와 우 1개를 각 택 1하여 설치할 수 있다
          // 상판하부 보강바 아래 부착, 전면 상판 마감선 맞춤
          // 책상 넓이 1200이상 일 경우: 1개, 1800이상일 경우: 중앙 1개, 사이드 1개 또는 좌우 다리 안쪽으로 1개씩 2개까지 가능
          // ㄱ자 모듈 부착시에는 ㄱ자 모듈에 부착
          // 좌측 1개만 가능
          // 규격: width=300, depth=400, height=160
          // 위치 규칙: 최상부는 상판 하단부에서 60 아래 위치, 전면부는 상판 전면부부터 -200 뒤로 위치
          // 좌측에 설치시, 좌측면 책상 좌측다리 내측 +155
          // 우측에 설치시, 우측면 책상 우측다리 내측 -155
          if (attach1_left_color) {
            var attach_top_y = frame_length + board_thickness - 60;
            // 좌측 다리 내측 +155
            var left_leg_inner_x = - (board_width - frame_thickness) / 2 + frame_thickness / 2 + 155;
            
            if (attach1_model) {
              var attach1_left = attach1_model.clone();
              attach1_left.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                  child.material = getMaterial(attach1_left_color);
                  child.castShadow = true;
                  child.receiveShadow = true;
                }
              });
              // GLB 모델의 원점을 중심으로 조정 (모델이 이미 올바른 원점을 가지고 있다고 가정)
              attach1_left.position.set(desk_offset_x + left_leg_inner_x, attach_top_y - 160 / 2, board_depth / 2 - 200);
              scene.add(attach1_left);
            } else {
              // GLB 모델이 로드되지 않은 경우 기본 박스 사용
              console.warn('⚠️ attach1_model이 로드되지 않아 기본 박스를 사용합니다.');
              geometry = new THREE.BoxBufferGeometry(300, 160, 400);
              var attach1_left_material = getMaterial(attach1_left_color);
              var attach1_left = new THREE.Mesh(geometry, attach1_left_material);
              attach1_left.position.set(desk_offset_x + left_leg_inner_x, attach_top_y - 160 / 2, board_depth / 2 - 200);
              attach1_left.castShadow = true;
              scene.add(attach1_left);
            }
          }
          // 우측 1개만 가능
          // 규격: width=300, depth=400, height=160
          if (attach1_right_color) {
            var attach_top_y = frame_length + board_thickness - 60;
            // 우측 다리 내측 -155
            var right_leg_inner_x = (board_width - frame_thickness) / 2 - frame_thickness / 2 - 155;
            
            if (attach1_model) {
              var attach1_right = attach1_model.clone();
              attach1_right.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                  child.material = getMaterial(attach1_right_color);
                  child.castShadow = true;
                  child.receiveShadow = true;
                }
              });
              // GLB 모델의 원점을 중심으로 조정
              attach1_right.position.set(desk_offset_x + right_leg_inner_x, attach_top_y - 160 / 2, board_depth / 2 - 200);
              scene.add(attach1_right);
            } else {
              // GLB 모델이 로드되지 않은 경우 기본 박스 사용
              console.warn('⚠️ attach1_model이 로드되지 않아 기본 박스를 사용합니다.');
              geometry = new THREE.BoxBufferGeometry(300, 160, 400);
              var attach1_right_material = getMaterial(attach1_right_color);
              var attach1_right = new THREE.Mesh(geometry, attach1_right_material);
              attach1_right.position.set(desk_offset_x + right_leg_inner_x, attach_top_y - 160 / 2, board_depth / 2 - 200);
              attach1_right.castShadow = true;
              scene.add(attach1_right);
            }
          }

          // 부착형 서랍 2단 (좌우 각각 1개만 설치 가능)
          // 부착형 서랍 1단, 부착형 서랍 2단, 본체함은 좌 1개와 우 1개를 각 택 1하여 설치할 수 있다
          // 상판하부 보강바 아래 부착, 전면 상판 마감선 맞춤
          // 책상 넓이 1200이상 일 경우: 1개, 1800이상일 경우: 중앙 1개, 사이드 1개 또는 좌우 다리 안쪽으로 1개씩 총 2개까지 가능
          // ㄱ자 모듈 부착시에는 ㄱ자 모듈에 부착
          // 좌측 1개만 가능
          // 규격: width=300, depth=400, height=500
          // 위치 규칙: 최상부는 상판 하단부에서 60 아래 위치, 전면부는 상판 전면부부터 -200 뒤로 위치
          // 좌측에 설치시, 좌측면 책상 좌측다리 내측 +155
          if (attach2_left_color) {
            var attach_top_y = frame_length + board_thickness - 60;
            var left_leg_inner_x = - (board_width - frame_thickness) / 2 + frame_thickness / 2 + 155;
            
            if (attach2_model) {
              var attach2_left = attach2_model.clone();
              attach2_left.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                  child.material = getMaterial(attach2_left_color);
                  child.castShadow = true;
                  child.receiveShadow = true;
                }
              });
              attach2_left.position.set(desk_offset_x + left_leg_inner_x, attach_top_y - 500 / 2, board_depth / 2 - 200);
              scene.add(attach2_left);
            } else {
              // GLB 모델이 로드되지 않은 경우 기본 박스 사용
              geometry = new THREE.BoxBufferGeometry(300, 500, 400);
              var attach2_left_material = getMaterial(attach2_left_color);
              var attach2_left = new THREE.Mesh(geometry, attach2_left_material);
              attach2_left.position.set(desk_offset_x + left_leg_inner_x, attach_top_y - 500 / 2, board_depth / 2 - 200);
              attach2_left.castShadow = true;
              scene.add(attach2_left);
            }
          }
          // 우측 1개만 가능
          // 규격: width=300, depth=400, height=500
          // 우측에 설치시, 우측면 책상 우측다리 내측 -155
          if (attach2_right_color) {
            var attach_top_y = frame_length + board_thickness - 60;
            var right_leg_inner_x = (board_width - frame_thickness) / 2 - frame_thickness / 2 - 155;
            
            if (attach2_model) {
              var attach2_right = attach2_model.clone();
              attach2_right.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                  child.material = getMaterial(attach2_right_color);
                  child.castShadow = true;
                  child.receiveShadow = true;
                }
              });
              attach2_right.position.set(desk_offset_x + right_leg_inner_x, attach_top_y - 500 / 2, board_depth / 2 - 200);
              scene.add(attach2_right);
            } else {
              // GLB 모델이 로드되지 않은 경우 기본 박스 사용
              geometry = new THREE.BoxBufferGeometry(300, 500, 400);
              var attach2_right_material = getMaterial(attach2_right_color);
              var attach2_right = new THREE.Mesh(geometry, attach2_right_material);
              attach2_right.position.set(desk_offset_x + right_leg_inner_x, attach_top_y - 500 / 2, board_depth / 2 - 200);
              attach2_right.castShadow = true;
              scene.add(attach2_right);
            }
          }

          // 본체함 (좌우 각각 1개만 설치 가능)
          // 부착형 서랍 1단, 부착형 서랍 2단, 본체함은 좌 1개와 우 1개를 각 택 1하여 설치할 수 있다
          // 상판하부 보강바 아래 부착, 전면 상판 마감선 맞춤
          // 책상 넓이 1200이상 일 경우: 1개, 1800이상일 경우: 중앙 1개, 사이드 1개 또는 좌우 다리 안쪽으로 1개씩 총 2개까지 가능
          // ㄱ자 모듈 부착시에는 ㄱ자 모듈 상판 하부에 부착
          // 좌측 1개만 가능
          // 규격: width=300, depth=400, height=500
          // 위치 규칙: 최상부는 상판 하단부에서 60 아래 위치, 전면부는 상판 전면부부터 -200 뒤로 위치
          // 좌측에 설치시, 좌측면 책상 좌측다리 내측 +155
          if (attach3_left_color) {
            var attach_top_y = frame_length + board_thickness - 60;
            var left_leg_inner_x = - (board_width - frame_thickness) / 2 + frame_thickness / 2 + 155;
            
            if (attach3_model) {
              var attach3_left = attach3_model.clone();
              attach3_left.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                  child.material = getMaterial(attach3_left_color);
                  child.castShadow = true;
                  child.receiveShadow = true;
                }
              });
              attach3_left.position.set(desk_offset_x + left_leg_inner_x, attach_top_y - 500 / 2, board_depth / 2 - 200);
              scene.add(attach3_left);
            } else {
              // GLB 모델이 로드되지 않은 경우 기본 박스 사용
              geometry = new THREE.BoxBufferGeometry(300, 500, 400);
              var attach3_left_material = getMaterial(attach3_left_color);
              var attach3_left = new THREE.Mesh(geometry, attach3_left_material);
              attach3_left.position.set(desk_offset_x + left_leg_inner_x, attach_top_y - 500 / 2, board_depth / 2 - 200);
              attach3_left.castShadow = true;
              scene.add(attach3_left);
            }
          }
          // 우측 1개만 가능
          // 규격: width=300, depth=400, height=500
          // 우측에 설치시, 우측면 책상 우측다리 내측 -155
          if (attach3_right_color) {
            var attach_top_y = frame_length + board_thickness - 60;
            var right_leg_inner_x = (board_width - frame_thickness) / 2 - frame_thickness / 2 - 155;
            
            if (attach3_model) {
              var attach3_right = attach3_model.clone();
              attach3_right.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                  child.material = getMaterial(attach3_right_color);
                  child.castShadow = true;
                  child.receiveShadow = true;
                }
              });
              attach3_right.position.set(desk_offset_x + right_leg_inner_x, attach_top_y - 500 / 2, board_depth / 2 - 200);
              scene.add(attach3_right);
            } else {
              // GLB 모델이 로드되지 않은 경우 기본 박스 사용
              geometry = new THREE.BoxBufferGeometry(300, 500, 400);
              var attach3_right_material = getMaterial(attach3_right_color);
              var attach3_right = new THREE.Mesh(geometry, attach3_right_material);
              attach3_right.position.set(desk_offset_x + right_leg_inner_x, attach_top_y - 500 / 2, board_depth / 2 - 200);
              attach3_right.castShadow = true;
              scene.add(attach3_right);
            }
          }

          // 이동 서랍 2단 (moving2)
          if (moving2_color) {
            geometry = new THREE.BoxBufferGeometry(300, 585, 400);
            var moving2_dup = new THREE.Mesh(geometry, moving2_material);
            // 이동서랍의 중심 Y 위치: 땅(y=0)에서 이동서랍 높이의 절반만큼 위 + 50
            moving2_dup.position.y = 585 / 2 + 50;
            
            // 기존 위치 유지 (ㄱ자 선택과 관계없이 독립적으로 작동)
            var moving2_x;
            if (moving2_position == 1)
              moving2_x = desk_offset_x - (board_width - 400) / 2;
            else
              moving2_x = desk_offset_x + (board_width - 400) / 2;
            moving2_dup.position.x = moving2_x;
            moving2_dup.position.z = (board_depth - 450) / 2;
            moving2_dup.castShadow = true;
            scene.add(moving2_dup);

            // drawer 1 and 2
            geometry = new THREE.BoxBufferGeometry(300, 275, 20);
            var drawer1_dup = new THREE.Mesh(geometry, moving2_material);
            drawer1_dup.position.y = (585 - 275) / 2;
            drawer1_dup.position.z = 220;
            moving2_dup.add(drawer1_dup);

            var drawer2_dup = new THREE.Mesh(geometry, moving2_material);
            drawer2_dup.position.y = -(585 - 275) / 2;
            drawer2_dup.position.z = 220;
            moving2_dup.add(drawer2_dup);

            // wheel
            geometry = new THREE.CylinderBufferGeometry(25, 25, 30);
            var wheel_dup = new THREE.Mesh(geometry, leg_pad_meterial);
            wheel_dup.position.set(-130, -320, 180);
            wheel_dup.rotation.x = Math.PI / 2;
            moving2_dup.add(wheel_dup);

            wheel_dup = new THREE.Mesh(geometry, leg_pad_meterial);
            wheel_dup.position.set(130, -320, 180);
            wheel_dup.rotation.x = Math.PI / 2;
            moving2_dup.add(wheel_dup);

            wheel_dup = new THREE.Mesh(geometry, leg_pad_meterial);
            wheel_dup.position.set(-130, -320, -180);
            wheel_dup.rotation.x = Math.PI / 2;
            moving2_dup.add(wheel_dup);

            wheel_dup = new THREE.Mesh(geometry, leg_pad_meterial);
            wheel_dup.position.set(130, -320, -180);
            wheel_dup.rotation.x = Math.PI / 2;
            moving2_dup.add(wheel_dup);
          }

          // 이동 서랍 3단 (moving3)
          if (moving3_color) {
            geometry = new THREE.BoxBufferGeometry(400, 585, 580);
            var moving3_dup = new THREE.Mesh(geometry, moving3_material);
            // 이동서랍의 중심 Y 위치: 땅(y=0)에서 이동서랍 높이의 절반만큼 위 + 50
            moving3_dup.position.y = 585 / 2 + 50;
            
            // 기존 위치 유지 (ㄱ자 선택과 관계없이 독립적으로 작동)
            var moving3_x;
            if (moving3_position == 1)
              moving3_x = desk_offset_x - (board_width - 500) / 2;
            else
              moving3_x = desk_offset_x + (board_width - 500) / 2;
            moving3_dup.position.x = moving3_x;
            moving3_dup.position.z = (board_depth - 640) / 2;
            moving3_dup.castShadow = true;
            scene.add(moving3_dup);

            // drawer 1, 2, 3
            geometry = new THREE.BoxBufferGeometry(400, 190, 20);
            var drawer1_dup = new THREE.Mesh(geometry, moving3_material);
            drawer1_dup.position.y = (585 - 190) / 2;
            drawer1_dup.position.z = 310;
            moving3_dup.add(drawer1_dup);

            var drawer2_dup = new THREE.Mesh(geometry, moving3_material);
            drawer2_dup.position.y = 0;
            drawer2_dup.position.z = 310;
            moving3_dup.add(drawer2_dup);

            var drawer3_dup = new THREE.Mesh(geometry, moving3_material);
            drawer3_dup.position.y = - (585 - 190) / 2;
            drawer3_dup.position.z = 310;
            moving3_dup.add(drawer3_dup);

            // wheel
            geometry = new THREE.CylinderBufferGeometry(25, 25, 30);
            var wheel_dup = new THREE.Mesh(geometry, leg_pad_meterial);
            wheel_dup.position.set(-180, -320, 280);
            wheel_dup.rotation.x = Math.PI / 2;
            moving3_dup.add(wheel_dup);

            wheel_dup = new THREE.Mesh(geometry, leg_pad_meterial);
            wheel_dup.position.set(180, -320, 280);
            wheel_dup.rotation.x = Math.PI / 2;
            moving3_dup.add(wheel_dup);

            wheel_dup = new THREE.Mesh(geometry, leg_pad_meterial);
            wheel_dup.position.set(-180, -320, -280);
            wheel_dup.rotation.x = Math.PI / 2;
            moving3_dup.add(wheel_dup);

            wheel_dup = new THREE.Mesh(geometry, leg_pad_meterial);
            wheel_dup.position.set(180, -320, -280);
            wheel_dup.rotation.x = Math.PI / 2;
            moving3_dup.add(wheel_dup);
          }

          // ㄱ자 하부 서랍 (desk_idx 루프 내에서 각 책상마다 생성)
          if (giyeok_position) {
            var giyeok_positions = [];
            if (giyeok_position == 4) {
              giyeok_positions = [1, 2]; // 왼쪽, 오른쪽
            } else {
              giyeok_positions = [giyeok_position];
            }
            
            var giyeok_attach_top_y = frame_length + board_thickness - 60;
            
            for (var g_idx = 0; g_idx < giyeok_positions.length; g_idx++) {
              var g_pos = giyeok_positions[g_idx];
              
              // 왼쪽 ㄱ자 하부 서랍
              if (g_pos == 1 || g_pos == 4) {
                // 좌측 ㄱ자 보드의 우측 끝 위치: desk_offset_x - (board_width - 600) / 2 + 300
                var giyeok_board_right_edge = desk_offset_x - (board_width - 600) / 2 + 300;
                var giyeok_inner_x = giyeok_board_right_edge - 200; // ㄱ자 옵션 우측 끝 -200까지 이동
                var giyeok_inner_z = (board_depth + 800) / 2 - 200 + 400; // Z축 +400 이동
                
                // 타입별 서랍 생성
                if (giyeok_drawer_type_left == 1) {
                  createGiyeokDrawer(1, giyeok_attach1_left_color, 'left', desk_offset_x, giyeok_attach_top_y, giyeok_inner_x, giyeok_inner_z, Math.PI / 2);
                } else if (giyeok_drawer_type_left == 2) {
                  createGiyeokDrawer(2, giyeok_attach2_left_color, 'left', desk_offset_x, giyeok_attach_top_y, giyeok_inner_x, giyeok_inner_z, Math.PI / 2);
                } else if (giyeok_drawer_type_left == 3) {
                  createGiyeokDrawer(3, giyeok_attach3_left_color, 'left', desk_offset_x, giyeok_attach_top_y, giyeok_inner_x, giyeok_inner_z, Math.PI / 2);
                } else if (giyeok_drawer_type_left == 4) {
                  createGiyeokDrawer(4, giyeok_moving2_left_color, 'left', desk_offset_x, giyeok_attach_top_y, giyeok_inner_x, giyeok_inner_z, Math.PI / 2);
                } else if (giyeok_drawer_type_left == 5) {
                  createGiyeokDrawer(5, giyeok_moving3_left_color, 'left', desk_offset_x, giyeok_attach_top_y, giyeok_inner_x, giyeok_inner_z, Math.PI / 2);
                }
              }
              
              // 오른쪽 ㄱ자 하부 서랍
              if (g_pos == 2 || g_pos == 4) {
                // 우측 ㄱ자 보드의 좌측 끝 위치: desk_offset_x + (board_width - 600) / 2 - 300
                var giyeok_board_left_edge = desk_offset_x + (board_width - 600) / 2 - 300;
                var giyeok_inner_x = giyeok_board_left_edge + 200; // ㄱ자 옵션 좌측 끝 +200까지 이동
                var giyeok_inner_z = (board_depth + 800) / 2 - 200 + 400; // Z축 +400 이동
                
                // 타입별 서랍 생성
                if (giyeok_drawer_type_right == 1) {
                  createGiyeokDrawer(1, giyeok_attach1_right_color, 'right', desk_offset_x, giyeok_attach_top_y, giyeok_inner_x, giyeok_inner_z, -Math.PI / 2);
                } else if (giyeok_drawer_type_right == 2) {
                  createGiyeokDrawer(2, giyeok_attach2_right_color, 'right', desk_offset_x, giyeok_attach_top_y, giyeok_inner_x, giyeok_inner_z, -Math.PI / 2);
                } else if (giyeok_drawer_type_right == 3) {
                  createGiyeokDrawer(3, giyeok_attach3_right_color, 'right', desk_offset_x, giyeok_attach_top_y, giyeok_inner_x, giyeok_inner_z, -Math.PI / 2);
                } else if (giyeok_drawer_type_right == 4) {
                  createGiyeokDrawer(4, giyeok_moving2_right_color, 'right', desk_offset_x, giyeok_attach_top_y, giyeok_inner_x, giyeok_inner_z, -Math.PI / 2);
                } else if (giyeok_drawer_type_right == 5) {
                  createGiyeokDrawer(5, giyeok_moving3_right_color, 'right', desk_offset_x, giyeok_attach_top_y, giyeok_inner_x, giyeok_inner_z, -Math.PI / 2);
                }
              }
            }
          }

          // 수납 슬라이딩도어 1단 (Storage_Sliding1_color)
          // 기준 규격은 기존 선반 360 깊이와 폭에 따름(도어 별도/높이 400 개별지정)
          // 수직부재 1400,1860 최상단에만 조합가능
          // 수납_슬라이딩도어 1단은 선반 2개와 대체
          // 1~6단 높이 모두 구성가능(최상단과 최하단 구성가능)
          // 규격: width=board_width - 80, depth=360, height=400
          // 위치 규칙: X축 기준 수직부재의 중앙에 위치, Y축 기준위치(센터) 수직부재의 센터와 일치, 옵션모듈의 높이는 선택한 수직부재의 규격이 1400일 경우 1200 높이에 위치, 선택한 수직부재의 규격이 1860인 경우 1400 높이에 위치, 선반360 최상단 위치와 평면위치 동일
          if (storage_sliding1_color && vertical_length > 0) {
            var storage_sliding1_width = board_width - 80; // width=board_width - 80
            var storage_sliding1_depth = 360; // depth=360
            var storage_sliding1_height = 400; // 높이 400
            // 수직부재 위치 계산
            var vertical_y_current = vertical_y + (vertical_y_offset * 93.5);
            var vertical_bottom_y = vertical_y_current - vertical_length / 2; // 수직부재 하단
            // 옵션모듈의 높이 위치 계산: 수직부재 하단에서 지정된 높이에 위치
            var storage_height_position = 0;
            var model_height = 1400; // 기본 모델 높이
            if (vertical_length_idx == 3) { // 1400
              storage_height_position = 1200; // 높이 1200에 위치
              model_height = 1400;
            } else if (vertical_length_idx == 4) { // 1860
              storage_height_position = 1400; // 높이 1400에 위치
              model_height = 2060; // 1860에 가장 가까운 모델
            }
            // 도어의 센터 위치 = 수직부재 하단 + 지정된 높이 + 도어 높이의 절반 + 오프셋
            var storage_center_y = vertical_bottom_y + storage_height_position + storage_sliding1_height / 2 + (storage_y_offset * 93.5);
            // 선반360 최상단 위치와 평면위치 동일 (Z 위치)
            // 선반 깊이 200이고 방향이 바깥쪽일 때도 선반 360과 동일한 위치
            var shelf_z_offset = 0;
            if (shelf_depth == 360 || (shelf_depth == 200 && shelf_direction == 0)) {
              shelf_z_offset = 160; // 선반360일 때 또는 선반200 바깥쪽일 때 Z축 오프셋
            }
            var shelf_z_relative = shelf_direction == 0 ? - (shelf_depth - frame_thickness + 2) / 2 : (shelf_depth - frame_thickness + 2) / 2;
            var vertical_z = - (board_depth + frame_thickness + 5) / 2;
            var shelf_z_absolute = vertical_z + shelf_z_relative + shelf_z_offset;
            
            if (storage_sliding1_models[model_height]) {
              var storage_sliding1_dup = storage_sliding1_models[model_height].clone();
              storage_sliding1_dup.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                  child.material = storage_sliding1_material;
                  child.castShadow = true;
                  child.receiveShadow = true;
                }
              });
              storage_sliding1_dup.position.set(desk_offset_x, storage_center_y, shelf_z_absolute);
              scene.add(storage_sliding1_dup);
            } else {
              // GLB 모델이 로드되지 않은 경우 기본 박스 사용
              geometry = new THREE.BoxBufferGeometry(storage_sliding1_width, storage_sliding1_height, storage_sliding1_depth);
              var storage_sliding1_dup = new THREE.Mesh(geometry, storage_sliding1_material);
              storage_sliding1_dup.position.set(desk_offset_x, storage_center_y, shelf_z_absolute);
              storage_sliding1_dup.castShadow = true;
              scene.add(storage_sliding1_dup);
            }
          }

          // 수납 슬라이딩도어 2단 (Storage_Sliding2_color)
          // 기준 규격은 기존 선반 360 깊이와 폭에 따름(도어 별도/높이 800 개별지정)
          // 수직부재 1400,1860 최상단에만 조합가능
          // 수납_슬라이딩도어 2단은 선반 3개와 대체
          // 1~6단 높이 모두 구성가능(최상단만 구성가능)
          // 규격: width=board_width - 80, depth=360, height=800
          // 위치 규칙: X축 기준 수직부재의 중앙에 위치, Y축 기준위치(센터) 수직부재의 센터와 일치, 옵션모듈의 높이는 선택한 수직부재의 규격이 1400일 경우 1200 높이에 위치, 선택한 수직부재의 규격이 1860인 경우 1400 높이에 위치, 선반360 최상단 위치와 평면위치 동일
          if (storage_sliding2_color && vertical_length > 0) {
            var storage_sliding2_width = board_width - 80; // width=board_width - 80
            var storage_sliding2_depth = 360; // depth=360
            var storage_sliding2_height = 800; // 높이 800
            // 수직부재 위치 계산
            var vertical_y_current = vertical_y + (vertical_y_offset * 93.5);
            var vertical_bottom_y = vertical_y_current - vertical_length / 2; // 수직부재 하단
            // 옵션모듈의 높이 위치 계산: 수직부재 하단에서 지정된 높이에 위치
            var storage_height_position = 0;
            var model_height = 1400; // 기본 모델 높이
            if (vertical_length_idx == 3) { // 1400
              storage_height_position = 1200; // 높이 1200에 위치
              model_height = 1400;
            } else if (vertical_length_idx == 4) { // 1860
              storage_height_position = 1400; // 높이 1400에 위치
              model_height = 2060; // 1860에 가장 가까운 모델
            }
            // 도어의 센터 위치 = 수직부재 하단 + 지정된 높이 + 도어 높이의 절반 + 오프셋
            var storage_center_y = vertical_bottom_y + storage_height_position + storage_sliding2_height / 2 + (storage_y_offset * 93.5);
            // 선반360 최상단 위치와 평면위치 동일 (Z 위치)
            // 선반 깊이 200이고 방향이 바깥쪽일 때도 선반 360과 동일한 위치
            var shelf_z_offset = 0;
            if (shelf_depth == 360 || (shelf_depth == 200 && shelf_direction == 0)) {
              shelf_z_offset = 160; // 선반360일 때 또는 선반200 바깥쪽일 때 Z축 오프셋
            }
            var shelf_z_relative = shelf_direction == 0 ? - (shelf_depth - frame_thickness + 2) / 2 : (shelf_depth - frame_thickness + 2) / 2;
            var vertical_z = - (board_depth + frame_thickness + 5) / 2;
            var shelf_z_absolute = vertical_z + shelf_z_relative + shelf_z_offset;
            
            if (storage_sliding2_models[model_height]) {
              var storage_sliding2_dup = storage_sliding2_models[model_height].clone();
              storage_sliding2_dup.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                  child.material = storage_sliding2_material;
                  child.castShadow = true;
                  child.receiveShadow = true;
                }
              });
              storage_sliding2_dup.position.set(desk_offset_x, storage_center_y, shelf_z_absolute);
              scene.add(storage_sliding2_dup);
            } else {
              // GLB 모델이 로드되지 않은 경우 기본 박스 사용
              geometry = new THREE.BoxBufferGeometry(storage_sliding2_width, storage_sliding2_height, storage_sliding2_depth);
              var storage_sliding2_dup = new THREE.Mesh(geometry, storage_sliding2_material);
              storage_sliding2_dup.position.set(desk_offset_x, storage_center_y, shelf_z_absolute);
              storage_sliding2_dup.castShadow = true;
              scene.add(storage_sliding2_dup);
            }
          }

          // 수납 플랩도어 (Storage_Flap_color) - GLB 모델 사용
          // 기준 규격은 기존 선반 360 깊이와 폭에 따름(도어 별도/높이 400 개별지정)
          // 수직부재 1400,1860 최상단에만 조합가능
          // 선반 2개와 대체
          // 주로, 4단 이상 구성
          // 규격: width=board_width - 80, depth=360, height=400
          // 위치 규칙: X축 기준 수직부재의 중앙에 위치, Y축 기준위치(센터) 수직부재의 센터와 일치, 옵션의 높이는 선택한 수직부재(1400, 1860) 위 아래 중앙에 위치, 선반360 최상단 위치와 평면위치 동일
          if (storage_flap_color && vertical_length > 0) {
            var storage_flap_width = board_width - 80; // width=board_width - 80
            var storage_flap_depth = 360; // depth=360
            var storage_flap_height = 400; // 높이 400
            // 수직부재 위치 계산
            var vertical_y_current = vertical_y + (vertical_y_offset * 93.5);
            var vertical_bottom_y = vertical_y_current - vertical_length / 2; // 수직부재 하단
            // 옵션모듈의 높이 위치 계산: 수직부재 하단에서 지정된 높이에 위치
            var storage_height_position = 0;
            var model_height = 1400; // 기본 모델 높이
            if (vertical_length_idx == 3) { // 1400
              storage_height_position = 1200; // 높이 1200에 위치
              model_height = 1400;
            } else if (vertical_length_idx == 4) { // 1860
              storage_height_position = 1400; // 높이 1400에 위치
              model_height = 2060; // 1860에 가장 가까운 모델
            }
            // 도어의 센터 위치 = 수직부재 하단 + 지정된 높이 + 도어 높이의 절반 + 오프셋
            var storage_center_y = vertical_bottom_y + storage_height_position + storage_flap_height / 2 + (storage_y_offset * 93.5);
            // 선반360 최상단 위치와 평면위치 동일 (Z 위치)
            // 선반 깊이 200이고 방향이 바깥쪽일 때도 선반 360과 동일한 위치
            var shelf_z_offset = 0;
            if (shelf_depth == 360 || (shelf_depth == 200 && shelf_direction == 0)) {
              shelf_z_offset = 160; // 선반360일 때 또는 선반200 바깥쪽일 때 Z축 오프셋
            }
            var shelf_z_relative = shelf_direction == 0 ? - (shelf_depth - frame_thickness + 2) / 2 : (shelf_depth - frame_thickness + 2) / 2;
            var vertical_z = - (board_depth + frame_thickness + 5) / 2;
            var shelf_z_absolute = vertical_z + shelf_z_relative + shelf_z_offset;
            
            if (storage_flap_models[model_height]) {
              var storage_flap_dup = storage_flap_models[model_height].clone();
              storage_flap_dup.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                  child.material = storage_flap_material;
                  child.castShadow = true;
                  child.receiveShadow = true;
                }
              });
              storage_flap_dup.position.set(desk_offset_x, storage_center_y, shelf_z_absolute);
              scene.add(storage_flap_dup);
            } else {
              // GLB 모델이 로드되지 않은 경우 기본 박스 사용
              geometry = new THREE.BoxBufferGeometry(storage_flap_width, storage_flap_height, storage_flap_depth);
              var storage_flap_dup = new THREE.Mesh(geometry, storage_flap_material);
              storage_flap_dup.position.set(desk_offset_x, storage_center_y, shelf_z_absolute);
              storage_flap_dup.castShadow = true;
              scene.add(storage_flap_dup);
            }
          }

          // 수납 플랩스테이도어 (Storage_FlapStay_color)
          // 기준 규격은 기존 선반 360 깊이와 폭에 따름(도어 별도/높이 400 개별지정)
          // 수직부재 1400,1860 최상단과 최하단에만 조합가능
          // 선반 2개와 대체
          // 주로, 4단 이하 구성
          // 규격: width=board_width - 80, depth=360, height=400
          // 위치 규칙: X축 기준 수직부재의 중앙에 위치, Y축 기준위치(센터) 수직부재의 센터와 일치, 옵션모듈의 높이는 선택한 수직부재의 규격이 1400일 경우 1200 높이에 위치, 선택한 수직부재의 규격이 1860인 경우 1400 높이에 위치, 선반360 최상단 위치와 평면위치 동일
          if (storage_flapstay_color && vertical_length > 0) {
            var storage_flapstay_width = board_width - 80; // width=board_width - 80
            var storage_flapstay_depth = 360; // depth=360
            var storage_flapstay_height = 400; // 높이 400
            // 수직부재 위치 계산
            var vertical_y_current = vertical_y + (vertical_y_offset * 93.5);
            var vertical_bottom_y = vertical_y_current - vertical_length / 2; // 수직부재 하단
            // 옵션모듈의 높이 위치 계산: 수직부재 하단에서 지정된 높이에 위치
            var storage_height_position = 0;
            if (vertical_length_idx == 3) { // 1400
              storage_height_position = 1200; // 높이 1200에 위치
            } else if (vertical_length_idx == 4) { // 1860
              storage_height_position = 1400; // 높이 1400에 위치
            }
            // 도어의 센터 위치 = 수직부재 하단 + 지정된 높이 + 도어 높이의 절반 + 오프셋
            var storage_center_y = vertical_bottom_y + storage_height_position + storage_flapstay_height / 2 + (storage_y_offset * 93.5);
            // 선반360 최상단 위치와 평면위치 동일 (Z 위치)
            // 선반 깊이 200이고 방향이 바깥쪽일 때도 선반 360과 동일한 위치
            var shelf_z_offset = 0;
            if (shelf_depth == 360 || (shelf_depth == 200 && shelf_direction == 0)) {
              shelf_z_offset = 160; // 선반360일 때 또는 선반200 바깥쪽일 때 Z축 오프셋
            }
            var shelf_z_relative = shelf_direction == 0 ? - (shelf_depth - frame_thickness + 2) / 2 : (shelf_depth - frame_thickness + 2) / 2;
            var vertical_z = - (board_depth + frame_thickness + 5) / 2;
            var shelf_z_absolute = vertical_z + shelf_z_relative + shelf_z_offset;
            
            // 모델 높이 결정
            var model_height = 1400; // 기본 모델 높이
            if (vertical_length_idx == 3) { // 1400
              model_height = 1400;
            } else if (vertical_length_idx == 4) { // 1860
              model_height = 2060; // 1860에 가장 가까운 모델
            }
            
            if (storage_flapstay_models[model_height]) {
              var storage_flapstay_dup = storage_flapstay_models[model_height].clone();
              storage_flapstay_dup.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                  child.material = storage_flapstay_material;
                  child.castShadow = true;
                  child.receiveShadow = true;
                }
              });
              storage_flapstay_dup.position.set(desk_offset_x, storage_center_y, shelf_z_absolute);
              scene.add(storage_flapstay_dup);
            } else {
              // GLB 모델이 로드되지 않은 경우 기본 박스 사용
              geometry = new THREE.BoxBufferGeometry(storage_flapstay_width, storage_flapstay_height, storage_flapstay_depth);
              var storage_flapstay_dup = new THREE.Mesh(geometry, storage_flapstay_material);
              storage_flapstay_dup.position.set(desk_offset_x, storage_center_y, shelf_z_absolute);
              storage_flapstay_dup.castShadow = true;
              scene.add(storage_flapstay_dup);
            }
          }

          // 파티션 ver_L: 첫 번째 책상의 왼쪽 파티션만 렌더링 (중첩 부분 제외)
          if (parti_ver_L_height > 0 && desk_idx == 0) {
            var board_top_y = frame_length + board_thickness; // 상판 높이
            var parti_bottom_y; // 파티션의 제일 낮은 부분
            var parti_center_y; // 파티션의 중심 높이
            
            // 파티션 폭 기본값 800
            var parti_width = 800;
            
            // 높이에 따른 설치 위치 계산
            switch (parti_ver_L_height) {
              case 460:
                parti_bottom_y = board_top_y;
                parti_center_y = parti_bottom_y + parti_ver_L_height / 2 + 15; // Y축 +15 이동 (위로)
                break;
              case 800:
                parti_bottom_y = board_top_y - 300; // 100 낮게 조정
                parti_center_y = parti_bottom_y + parti_ver_L_height / 2;
                break;
              case 1200:
              case 1400:
              case 1600:
              case 1800:
                parti_bottom_y = board_top_y - 700;
                parti_center_y = parti_bottom_y + parti_ver_L_height / 2;
                break;
              default:
                parti_bottom_y = board_top_y;
                parti_center_y = parti_bottom_y + parti_ver_L_height / 2;
            }
            
            // 파티션 X 위치 계산: 선반이 있을 경우 선반의 제일 바깥쪽으로
            var parti_x_position;
            if (vertical_length > 0 && shelf_num > 0) {
              // 선반의 바깥쪽 가장자리 계산
              var vertical_z = - (board_depth + frame_thickness + 5) / 2;
              var shelf_z_relative;
              if (shelf_direction == 0) {
                // 바깥쪽 방향 (OUT)
                shelf_z_relative = - (shelf_depth - frame_thickness + 2) / 2;
              } else {
                // 안쪽 방향 (IN)
                shelf_z_relative = (shelf_depth - frame_thickness + 2) / 2;
              }
              var shelf_z_absolute = vertical_z + shelf_z_relative;
              // 선반의 바깥쪽 가장자리 (더 뒤쪽, 음수 방향)
              var shelf_outer_edge_z = shelf_z_absolute - shelf_depth / 2;
              // 파티션을 선반 바깥쪽에 붙임 (파티션 두께의 절반만큼 뒤로)
              parti_x_position = desk_offset_x - board_width / 2 - 6; // 12mm 두께의 절반만큼 바깥쪽
            } else {
              // 선반이 없을 경우: 책상 상판 측면에 바로 붙음
              parti_x_position = desk_offset_x - board_width / 2;
            }
            
            geometry = new THREE.BoxBufferGeometry(12, parti_ver_L_height, parti_width);
            var parti_ver_L_dup = new THREE.Mesh(geometry, parti_ver_L_material);
            // 파티션 Z 위치: 책상 깊이 1000 이상이고 하부옵션 전면 정렬 선택 시
            var parti_z_pos = 0;
            if (board_depth >= 1000 && parti_z_align_front == 1) {
              parti_z_pos = board_depth / 2 - 200; // 하부옵션 전면과 같은 라인
            }
            parti_ver_L_dup.position.set(parti_x_position, parti_center_y, parti_z_pos);
            parti_ver_L_dup.castShadow = true;
            scene.add(parti_ver_L_dup);
          }

          // 파티션 ver_R: 마지막 책상의 오른쪽 파티션만 렌더링 (중첩 부분 제외)
          if (desk_idx == num_desk - 1 && parti_ver_R_height > 0) {
            var board_top_y = frame_length + board_thickness;
            var parti_bottom_y;
            var parti_center_y;
            var parti_width = 800;
            
            switch (parti_ver_R_height) {
              case 460:
                parti_bottom_y = board_top_y;
                parti_center_y = parti_bottom_y + parti_ver_R_height / 2 + 15; // Y축 +15 이동 (위로)
                break;
              case 800:
                parti_bottom_y = board_top_y - 300; // 100 낮게 조정
                parti_center_y = parti_bottom_y + parti_ver_R_height / 2;
                break;
              case 1200:
              case 1400:
              case 1600:
              case 1800:
                parti_bottom_y = board_top_y - 700;
                parti_center_y = parti_bottom_y + parti_ver_R_height / 2;
                break;
              default:
                parti_bottom_y = board_top_y;
                parti_center_y = parti_bottom_y + parti_ver_R_height / 2;
            }
            
            var parti_x_position;
            if (vertical_length > 0 && shelf_num > 0) {
              var vertical_z = - (board_depth + frame_thickness + 5) / 2;
              var shelf_z_relative;
              if (shelf_direction == 0) {
                shelf_z_relative = - (shelf_depth - frame_thickness + 2) / 2;
              } else {
                shelf_z_relative = (shelf_depth - frame_thickness + 2) / 2;
              }
              var shelf_z_absolute = vertical_z + shelf_z_relative;
              var shelf_outer_edge_z = shelf_z_absolute - shelf_depth / 2;
              parti_x_position = desk_offset_x + board_width / 2 + 6;
            } else {
              parti_x_position = desk_offset_x + board_width / 2;
            }
            
            geometry = new THREE.BoxBufferGeometry(12, parti_ver_R_height, parti_width);
            var parti_ver_R_dup = new THREE.Mesh(geometry, parti_ver_R_material);
            // 파티션 Z 위치: 책상 깊이 1000 이상이고 하부옵션 전면 정렬 선택 시
            var parti_z_pos = 0;
            if (board_depth >= 1000 && parti_z_align_front == 1) {
              parti_z_pos = board_depth / 2 - 200; // 하부옵션 전면과 같은 라인
            }
            parti_ver_R_dup.position.set(parti_x_position, parti_center_y, parti_z_pos);
            parti_ver_R_dup.castShadow = true;
            scene.add(parti_ver_R_dup);
          }

          // 책상이 1개일 때 오른쪽 파티션
          if (num_desk == 1 && parti_ver_R_height > 0) {
            var board_top_y = frame_length + board_thickness;
            var parti_bottom_y;
            var parti_center_y;
            var parti_width = 800;
            
            switch (parti_ver_R_height) {
              case 460:
                parti_bottom_y = board_top_y;
                parti_center_y = parti_bottom_y + parti_ver_R_height / 2 + 15; // Y축 +15 이동 (위로)
                break;
              case 800:
                parti_bottom_y = board_top_y - 300; // 100 낮게 조정
                parti_center_y = parti_bottom_y + parti_ver_R_height / 2;
                break;
              case 1200:
              case 1400:
              case 1600:
              case 1800:
                parti_bottom_y = board_top_y - 700;
                parti_center_y = parti_bottom_y + parti_ver_R_height / 2;
                break;
              default:
                parti_bottom_y = board_top_y;
                parti_center_y = parti_bottom_y + parti_ver_R_height / 2;
            }
            
            var parti_x_position;
            if (vertical_length > 0 && shelf_num > 0) {
              var vertical_z = - (board_depth + frame_thickness + 5) / 2;
              var shelf_z_relative;
              if (shelf_direction == 0) {
                shelf_z_relative = - (shelf_depth - frame_thickness + 2) / 2;
              } else {
                shelf_z_relative = (shelf_depth - frame_thickness + 2) / 2;
              }
              var shelf_z_absolute = vertical_z + shelf_z_relative;
              var shelf_outer_edge_z = shelf_z_absolute - shelf_depth / 2;
              parti_x_position = desk_offset_x + board_width / 2 + 6;
            } else {
              parti_x_position = desk_offset_x + board_width / 2;
            }
            
            geometry = new THREE.BoxBufferGeometry(12, parti_ver_R_height, parti_width);
            var parti_ver_R_dup = new THREE.Mesh(geometry, parti_ver_R_material);
            // 파티션 Z 위치: 책상 깊이 1000 이상이고 하부옵션 전면 정렬 선택 시
            var parti_z_pos = 0;
            if (board_depth >= 1000 && parti_z_align_front == 1) {
              parti_z_pos = board_depth / 2 - 200; // 하부옵션 전면과 같은 라인
            }
            parti_ver_R_dup.position.set(parti_x_position, parti_center_y, parti_z_pos);
            parti_ver_R_dup.castShadow = true;
            scene.add(parti_ver_R_dup);
          }

          // 파티션 hol_B (전면 파티션)
          if (parti_hol_B_width > 0) {
            var board_top_y = frame_length + board_thickness; // 상판 높이
            var parti_hol_B_height = 800; // 고정 높이 800mm
            var parti_bottom_y = board_top_y - 200; // 상판 기준 200mm 아래에서 시작
            var parti_center_y = parti_bottom_y + parti_hol_B_height / 2 - 100; // 파티션 중심 높이 (아래로 100mm 이동)
            
            // 설치 위치 계산
            var parti_z_position;
            
            if (vertical_length == 0 || shelf_num == 0) {
              // 책상만 있을 경우: 책상 전면 바깥쪽으로 부착
              parti_z_position = -board_depth / 2 - 6; // 12mm 두께의 절반
            } else {
              // 선반이 있을 경우: 반대편 책상과 가장 멀리 떨어진 선반의 끝에 부착
              var vertical_z = - (board_depth + frame_thickness + 5) / 2;
              
              var shelf_z_relative;
              if (shelf_direction == 0) {
                shelf_z_relative = - (shelf_depth - frame_thickness + 2) / 2;
              } else {
                shelf_z_relative = (shelf_depth - frame_thickness + 2) / 2;
              }
              
              var shelf_z_absolute = vertical_z + shelf_z_relative;
              
              // 선반의 앞쪽 끝과 뒤쪽 끝 계산
              var shelf_front_edge; // 더 앞쪽 (더 작은 음수, Z=0에 가까움)
              var shelf_back_edge;  // 더 뒤쪽 (더 큰 음수, Z=0에서 멀음)
              
              if (shelf_direction == 0) {
                // OUT 방향: 선반이 뒤쪽으로 향함
                shelf_back_edge = shelf_z_absolute + shelf_depth / 2;  // 더 뒤쪽 (더 큰 음수)
                shelf_front_edge = shelf_z_absolute - shelf_depth / 2; // 더 앞쪽 (더 작은 음수)
              } else {
                // IN 방향: 선반이 앞쪽으로 향함
                shelf_front_edge = shelf_z_absolute + shelf_depth / 2;  // 더 앞쪽 (더 작은 음수)
                shelf_back_edge = shelf_z_absolute - shelf_depth / 2;  // 더 뒤쪽 (더 큰 음수)
              }
              
              // 맞은편 배치 선택 여부와 관계없이 항상 뒤쪽 끝 사용 (전면 파티션 위치 고정)
              shelf_farthest_edge = shelf_back_edge;
              
              parti_z_position = shelf_farthest_edge - 6; // 12mm 두께의 절반만큼 앞쪽으로
            }
            
            // 선반의 바깥방향(OUT) 선택 시 Z축으로 -200 이동
            if (vertical_length > 0 && shelf_num > 0 && shelf_direction == 0) {
              parti_z_position -= 200;
            }
            // 선반방향이 안쪽(IN)일 때는 원래 기본위치 유지 (추가 이동 없음)
            
            geometry = new THREE.BoxBufferGeometry(parti_hol_B_width, parti_hol_B_height, 12);
            var parti_hol_B_dup = new THREE.Mesh(geometry, parti_hol_B_material);
            parti_hol_B_dup.position.set(desk_offset_x, parti_center_y, parti_z_position);
            parti_hol_B_dup.castShadow = true;
            scene.add(parti_hol_B_dup);
          }
        }
        
        // 중첩위치 파티션: 책상 사이 중첩 위치에 배치
        if (num_desk > 1 && parti_ver_M_height > 0) {
          var board_top_y = frame_length + board_thickness;
          var parti_bottom_y;
          var parti_center_y;
          var parti_width = 800;
          
          // 높이에 따른 설치 위치 계산
          switch (parti_ver_M_height) {
            case 400:
              parti_bottom_y = board_top_y;
              parti_center_y = parti_bottom_y + parti_ver_M_height / 2;
              break;
            case 800:
              parti_bottom_y = board_top_y - 300; // 100 낮게 조정
              parti_center_y = parti_bottom_y + parti_ver_M_height / 2;
              break;
            case 1200:
            case 1400:
            case 1600:
            case 1800:
              parti_bottom_y = board_top_y - 700;
              parti_center_y = parti_bottom_y + parti_ver_M_height / 2;
              break;
            default:
              parti_bottom_y = board_top_y;
              parti_center_y = parti_bottom_y + parti_ver_M_height / 2;
          }
          
          // 각 책상 사이 중첩 위치에 파티션 배치
          for (var middle_idx = 0; middle_idx < num_desk - 1; middle_idx++) {
            // 두 책상 사이의 중첩 위치 계산
            // 첫 번째 책상의 오른쪽 끝과 두 번째 책상의 왼쪽 끝이 만나는 위치
            var desk1_offset_x = (board_width + 10) * (middle_idx - 0.5 * (num_desk - 1));
            var desk2_offset_x = (board_width + 10) * ((middle_idx + 1) - 0.5 * (num_desk - 1));
            
            // 첫 번째 책상의 오른쪽 끝: desk1_offset_x + board_width/2
            // 두 번째 책상의 왼쪽 끝: desk2_offset_x - board_width/2
            // 중첩 위치는 이 두 위치의 중간 (책상 사이 간격 10의 중간)
            var overlap_x = (desk1_offset_x + board_width / 2 + desk2_offset_x - board_width / 2) / 2;
            
            // 파티션 X 위치 계산: 선반이 있을 경우 선반의 제일 바깥쪽으로
            var parti_x_position;
            if (vertical_length > 0 && shelf_num > 0) {
              var vertical_z = - (board_depth + frame_thickness + 5) / 2;
              var shelf_z_relative;
              if (shelf_direction == 0) {
                shelf_z_relative = - (shelf_depth - frame_thickness + 2) / 2;
              } else {
                shelf_z_relative = (shelf_depth - frame_thickness + 2) / 2;
              }
              var shelf_z_absolute = vertical_z + shelf_z_relative;
              var shelf_outer_edge_z = shelf_z_absolute - shelf_depth / 2;
              parti_x_position = overlap_x + 6; // 중첩 위치에서 파티션 두께의 절반만큼 오른쪽
            } else {
              parti_x_position = overlap_x; // 중첩 위치에 정확히 배치
            }
            
            geometry = new THREE.BoxBufferGeometry(12, parti_ver_M_height, parti_width);
            var parti_middle = new THREE.Mesh(geometry, parti_ver_M_material);
            // 파티션 Z 위치: 책상 깊이 1000 이상이고 하부옵션 전면 정렬 선택 시
            var parti_z_pos = 0;
            if (board_depth >= 1000 && parti_z_align_front == 1) {
              parti_z_pos = board_depth / 2 - 200; // 하부옵션 전면과 같은 라인
            }
            parti_middle.position.set(parti_x_position, parti_center_y, parti_z_pos);
            parti_middle.castShadow = true;
            scene.add(parti_middle);
          }
        }
        
        
        // light
        var lights = [];
        var d = 4000; // 그림자 범위 확대 (기존 2048에서 4000으로 증가)
        lights[0] = new THREE.DirectionalLight(0xffffff, 0.3);
        lights[1] = new THREE.DirectionalLight(0xffffff, 0.3);
        lights[2] = new THREE.DirectionalLight(0xffffff, 0.3);
        lights[3] = new THREE.DirectionalLight(0xffffff, 0.3);
        lights[4] = new THREE.AmbientLight(0xffffff, 0.5);

        lights[0].castShadow = true;
        lights[0].shadow.camera.left = -d ;
        lights[0].shadow.camera.right = d ;
        lights[0].shadow.camera.top = d ;
        lights[0].shadow.camera.bottom = -d ;
        lights[0].shadow.camera.far = 10000;
        lights[0].shadow.mapSize.width = 4096; // 그림자 해상도 증가 (기존 2048에서 4096으로 증가)
        lights[0].shadow.mapSize.height = 4096; // 그림자 해상도 증가 (기존 2048에서 4096으로 증가)
        lights[0].shadow.bias = -0.0001;
        lights[0].position.set(-1000, 1000, 1000);

        lights[1].position.set(1000, 500, -1000);
        lights[2].position.set(-1000, 500, -1000);
        lights[3].position.set(1000, 500, 1000);

        scene.add(lights[0]);
        scene.add(lights[1]);
        scene.add(lights[2]);
        scene.add(lights[3]);
        scene.add(lights[4]);

        // Calculate price and generate product code
        var price_arr = calculatePrice();
        var total_price = price_arr[0] + price_arr[1];

        product_code_string = generateProductCode();

        var my_date = new Date();
        var day_of_month = my_date.getDate();
        my_date.setDate(day_of_month + 7);
        
        var dd = my_date.getDate();
        var mm = my_date.getMonth() + 1;  //January is 0!
        var yyyy = my_date.getFullYear();

        // write price and code into HTML
        var product_code_input = document.getElementById("product_code_input");
        if (product_code_input) {
          product_code_input.value = generateProductCode();
        } else {
          // fallback for old HTML structure
        var product_code_html = document.getElementsByClassName("ft_prd_code");
          if (product_code_html.length > 0) {
        product_code_html[0].innerHTML = generateProductCode();        
          }
        }        
        
        var price_html = document.getElementsByClassName("delivery_info price");
        price_html[0].innerHTML = price_arr[0].toLocaleString();
        price_html[1].innerHTML = price_arr[1].toLocaleString();

        price_html = document.getElementsByClassName("ft_total_price");
        price_html[0].innerHTML = total_price.toLocaleString();

        var delivery_date_html = document.getElementsByClassName("delivery_info");
        delivery_date_html[1].innerHTML = yyyy + "년 " + mm + "월 " + dd + "일";
        
        // 모든 메시에 아웃라인 추가
        addOutlinesToScene();
      }

      function onWindowResize() {
        container = document.getElementById('canvas');
        width = window.innerWidth;
        height = window.innerHeight;

        camera.aspect = width / height;
        camera.updateProjectionMatrix();

        renderer.setSize(width, height);

        render();
      }

      // 모바일 감지 (전역 변수로 사용)
      var isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;
      
      function animate() {
        requestAnimationFrame(animate);
        if (controls) {
          controls.update();
        }
        render();
      }

      function render() {
        renderer.render(scene, camera);
      }
      
      function toggleRotation() {
        if (controls) {
          controls.autoRotate = !controls.autoRotate;
          updateRotationButton();
        }
      }
      
      function updateRotationButton() {
        var btn = document.getElementById('rotation-toggle-btn');
        if (btn && controls) {
          if (controls.autoRotate) {
            btn.innerHTML = '회전정지';
            btn.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
          } else {
            btn.innerHTML = '회전시작';
            btn.style.backgroundColor = 'rgba(0, 100, 0, 0.7)';
          }
        }
      }
      
      function save( blob, filename ) {
        link.href = URL.createObjectURL( blob );
        link.download = filename;
        link.click();
      }
      
      function saveString( text, filename ) {
        save( new Blob( [ text ], { type: 'text/plain' } ), filename );
      }
      
      function saveArrayBuffer( buffer, filename ) {
        save( new Blob( [ buffer ], { type: 'application/octet-stream' } ), filename );
      }
      
      // 익스포트용 그룹 생성 (책상, 파티션, 하부옵션 모두 포함)
      function createExportGroup() {
        var exportGroup = new THREE.Group();
        
        // desk 그룹 추가
        exportGroup.add(desk.clone());
        
        // 씬의 모든 객체를 순회하면서 파티션, 하부옵션, 수납옵션 등 추가
        scene.traverse(function(child) {
          // 평면은 제외
          if (child === plane) {
            return;
          }
          
          // 반대편 그룹은 제외
          if (child.userData && child.userData.isOppositeGroup) {
            return;
          }
          
          // 축 표시 그룹은 제외 (이름으로 확인)
          if (child.name && child.name.indexOf('Axis') !== -1) {
            return;
          }
          
          // desk 그룹에 속하지 않은 메시 객체 추가
          var isDeskChild = false;
          desk.traverse(function(deskChild) {
            if (deskChild === child) {
              isDeskChild = true;
            }
          });
          
          if (!isDeskChild && child instanceof THREE.Mesh) {
            // 파티션, 하부옵션, 수납옵션 등
            exportGroup.add(child.clone());
          }
        });
        
        return exportGroup;
      }

      function exportOBJ() {
        var exporter = new THREE.OBJExporter();
        var exportGroup = createExportGroup();
        var result = exporter.parse(exportGroup);
        saveString(result, "f1desk_" + product_code_string + ".obj");
      }

      function exportSTL() {
        var exporter = new THREE.STLExporter();
        var exportGroup = createExportGroup();
        var result = exporter.parse(exportGroup);
        saveString(result, "f1desk_" + product_code_string + ".stl");
      }

    </script>
</body>
</html>