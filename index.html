<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="utf-8" name="format-detection" content="telephone=no">
  <title>F1DESK CONFIGURATOR - Updated</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.0.7/js/swiper.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.0.7/css/swiper.min.css" media="only screen and (max-width:1024px)">
  <script>
    $(document).ready(function(){
      $(".mal_buttons>div").click(function(){
        // ㄱ자 하부 서랍 메뉴는 별도 처리
        if ($(this).closest("#giyeok-drawer-color-left, #giyeok-drawer-color-right").length > 0) {
          // 색상 선택 메뉴는 별도 함수에서 처리하므로 여기서는 처리하지 않음
          return;
        }
        if ($(this).closest("#giyeok-drawer-type-left, #giyeok-drawer-type-right").length > 0) {
          // 타입 선택 메뉴는 별도 함수에서 처리하므로 여기서는 처리하지 않음
          return;
        }
        $(".mal_buttons>div").removeClass("sel");
        $(this).addClass("sel");
        $(".menu_all_list").fadeOut();

        var seltext = $(this).html();
        $(this).parents("div.swiper-slide").find(".menu_sel_text").html(seltext);
      });

      $(".swiper-button-prev, .swiper-button-next").click(function(){
        $(".menu_all_list").fadeOut();
      });

      var windowWidth = $( window ).width();
      var swiper; // Swiper 인스턴스를 전역 변수로 선언
      if(windowWidth < 1024) {
       swiper = new Swiper('.sidebar .swiper-container', {
          slidesPerView: 4,
          spaceBetween: 0,
          slidesPerGroup: 4,
          freeMode: true,
          navigation: {
            nextEl: '.sidebar .swiper-button-next',
            prevEl: '.sidebar .swiper-button-prev',
          },
        });

        var btnWidth = parseInt($(".swiper-slide").css("width"));
        $(".sidebar, .swiper-slide").css({"height":btnWidth});
        var sideWidth = windowWidth-80;
        $(".line2").css({"margin-top":"2%"});

        $(".menu_box").click(function(){
          var mboxIdx = $(".swiper-slide .menu_box").index(this);
          $(".m_sidebar>.menu_all_list").fadeOut();
          $(".m_sidebar>.menu_all_list:eq(" + mboxIdx + ")").fadeIn();
        });

        $(".mal_buttons>div").click(function(){
          var seltextIdx = $(this).parents(".menu_all_list").index();
          var seltext = $(this).html();
          $(".sidebar .swiper-slide:eq("+ seltextIdx +") .menu_sel_text").html(seltext);
        });

      } else {
       swiper = new Swiper('.sidebar .swiper-container', {
          direction: 'vertical',
          slidesPerView: 5,
          spaceBetween: 0,
          slidesPerGroup: 5,
          freeMode: true,
          mousewheel: {
            enabled: true,
            sensitivity: 1,
            releaseOnEdges: false,
          },
          navigation: {
            nextEl: '.sidebar .swiper-button-next',
            prevEl: '.sidebar .swiper-button-prev',
          }
        });
        

        $(".sidebar .menu_box").click(function(){
          $(".sidebar .menu_box").removeClass("sel");
          $(this).addClass("sel");
          $(".sidebar .menu_all_list").fadeOut();
          var menuList = $(this).siblings(".menu_all_list");
          menuList.css("display", "block"); // width 계산을 위해 임시로 표시
          var menuWidth = menuList.outerWidth() || menuList[0].scrollWidth || 0;
          menuList.css("display", ""); // 원래대로 복원
          var aaWidth = Math.max(menuWidth + 130, 130);
          menuList.fadeIn();
          $(".sidebar").animate({"width":aaWidth});
        });

        $(".sidebar .swiper-button-prev, .sidebar .swiper-button-next").click(function(){
          $(".sidebar").animate({"width":"130px"});
        });
      }
      
      // Swiper 인스턴스를 전역으로 저장하여 나중에 업데이트할 수 있도록 함
      window.swiperInstance = swiper;
  });
  </script>
  <style>
    @import url(http://fonts.googleapis.com/earlyaccess/notosanskr.css);
    @import url('https://fonts.googleapis.com/css?family=Montserrat');
    @import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.min.css');

    container { width: 100%; overflow: hidden; font-family: 'Montserrat', sans-serif; }
    #canvas { position: absolute; border: 0px; left: 0px; right: 0px; top: 99px; bottom: 0px; overflow: hidden; z-index: -1; display: block; }
    * { list-style: none; border-style: none; border-width: 0; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; font-family: Montserrat, 'Noto Sans KR', Helvetica, Arial, sans-serif; margin: 0; outline: none; overflow: visible; padding: 0; }

    .header { position: fixed; z-index: 1; width: 100%; height: 99px; padding: 0 50px; background-color: #fff; border-bottom: 1px solid #eaeaea; }
    .h_title { float: left; padding-top: 21px; }
    .h_logo { float: right; padding-top: 22px; }

    .sidebar { overflow: visible; position: fixed; left: 50px; top: 99px; width: 130px; height: 730px; padding-top: 40px; }
    .sidebar .swiper-container { height:650px; }
    .sidebar .swiper-slide { position: relative; }
    .sidebar .swiper-button-next, .sidebar .swiper-button-prev { display: block; position: absolute; left: 0; height: 40px; width: 130px; line-height: 40px; background-color: #888; text-align: center; color: #fff; font-size: 20px; }
    .sidebar .swiper-button-next:hover, .sidebar .swiper-button-prev:hover { background-color: #555; }
    .sidebar .swiper-button-next { top: 690px; }
    .sidebar .swiper-button-prev { top: 0; }
    
    .m_sidebar { display: none; }
    .menu_box { position: relative; width: 130px; height: 130px; padding: 15px; background: #fff url("img/btn_menubg.gif") no-repeat 18px 50%;  text-align: center; border-top: 1px dashed #b1b1b1; }
    .menu_box.sel { background-image: url("img/btn_menubg_sel.png");}
      .menu_title { height: 30px; padding-top: 2px; color: #fff; font-size: 17px; }
      .menu_sel_text { position: relative; width: 77px; height: 64px; margin: 0 auto; line-height: 72px; font-size: 19px; }
        .menu_sel_text>img { position: absolute; left: 0; top: 13px; width: 77px; height: 44px; }
        .menu_sel_text>span { display: block; position: absolute; left: 0; top: 13px; width: 77px; height: 44px; line-height: 46px; }
    
    .menu_all_list { display: none; position: absolute; left: 122px; top: 18px; min-height: 94px; background-color: #fff; border: 1px solid #eaeaea; overflow: visible; white-space: nowrap; width: auto; max-width: none; }
      .mal_buttons { overflow: visible; white-space: nowrap; display: block; }
      .menu_all_list .mal_buttons + .mal_buttons { margin-top: 10px; }
      .mal_buttons>div { overflow: hidden; position: relative; width: 50px; height: 92px; background-color: #fff; text-align: center; line-height: 98px; font-size: 18px; cursor: pointer; color: #888; font-weight: 500; display: inline-block; vertical-align: top; }
        .mal_buttons>div>img { width: 50px; height: 92px; }
        .mal_buttons>div>span { position: absolute; left: 0; top: 0; display: block; width: 100%; height: 100%; text-align: center; color: #aaa; font-size: 12px; }
      .mal_buttons>div.sel,
      .mal_buttons>div:hover { border: 4px solid #ed9c00; line-height: 90px; color: #aaa; }
      .mal_buttons>div.sel>img,
      .mal_buttons>div:hover>img { width: 46px; height: 84px; }
      .mal_buttons>div:hover>span { color: #888; }

    .footer { position: fixed; left: 0; bottom: 0; width: 100%; height: 180px; padding:20px 0; background-color: rgba(0, 0, 0, 0.7);}
        .ft_inner>div { float: left; height: 140px; padding: 20px 40px 0; border-left: 1px solid rgba(255, 255, 255, 0.1);}

          .ft_title { font-weight: normal; color: #9f9f9f; font-size: 16px; font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, sans-serif; }
          .ft_prd_code { color: #fff; font-size: 18px; letter-spacing: -0.5px; font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, sans-serif; font-weight: 300; }

          .delivery_box { float: left; }
          .delivery_box:first-child { margin-right: 20px; }
            .delivery_info { position: relative; width: 175px; height: 35px; line-height: 35px; background-color: #000; overflow: hidden; color: #fff; text-indent: 10px; font-size: 18px; margin-top: 5px; font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, sans-serif; }
            .delivery_info.price { text-align: right; padding-right: 10px; }
              .delivery_area_list { height: 35px; }
                .delivery_area_list>li { line-height: 35px; list-style: none; font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, sans-serif; }
              .delivery_list_more { position: absolute; right: 10px; top: 0; font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, sans-serif; }
              .delivery_info.price>span { font-size: 14px; font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, sans-serif; }

            .ft_total_title { display: block; float: left; line-height: 110px; font-size: 24px; color: #fff; font-weight: normal; font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, sans-serif; }
            .ft_total_price { display: block; float: right; line-height: 110px; font-size: 25px; color: #fff; font-weight: bold; font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, sans-serif; }
              .ft_total_price>span { padding-left: 5px; font-size: 20px; font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, sans-serif; }
  
    @media (max-width:1024px) {
      .sidebar,
      .m_sidebar {display: block; overflow: hidden; position: fixed; left: 50%; top: 100px; width: 840px; height: 130px; padding: 0; margin-left: -420px; box-sizing: border-box; background-color: #fff; }
      .sidebar .swiper-container { position: static; width: 720px;; height: 100%; }
      .sidebar .swiper-wrapper { position: static; height: 100%; }
      .swiper-slide { position: static !important; }
      .swiper-slide:first-child { border-left: 0; }

      .sidebar .swiper-button-next, .sidebar .swiper-button-prev { display: block; position: absolute; top: 0; width: 60px; height: 180px; line-height: 180px; background-color: #888; text-align: center; color: #fff; background-image: none; margin-top: 0; }
      .sidebar .swiper-button-next:hover, .sidebar .swiper-button-prev:hover { background-color: #555; }
      .sidebar .swiper-button-next { left: 780px !important; }
      .sidebar .swiper-button-prev { left: 0; }

      .menu_box { width: 180px; height: 180px; border-top: 0; background-image: url("img/btn_menubg_m.gif"); background-size: 144px auto; background-position: center;  padding: 12px 17px;}
      .menu_box.sel { background-image: url("img/btn_menubg_sel_m.png");}

      .menu_all_list { display: none; position: absolute; z-index: 100; left: 50%; top: 130px; width: 100%;}
      .menu_sel_text { width: 120px; height: 68px; line-height: 68px; font-size: 24px; text-align: center; margin: 14px 0 0 14px; }
      .menu_sel_text>img { width: 100%; height: 100%; position: static; }
      .menu_sel_text>span { line-height: 3.2; width: 100%; height: 100%; top: 0;}
      .menu_title { height: 62px; line-height: 54px; font-size: 22px;}

      .m_sidebar { top: 270px; height: 130px; z-index: 10; background: none; }
      .m_sidebar .menu_all_list { display: none; top: 0; }
    
      
      .footer { height: 220px; }
      .ft_inner>div { height: 175px; }
      .delivery_box { margin-bottom: 10px; }
      .ft_total_price { position: relative; top: -50px; }
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <div class="h_title"><img src="img/configurator.jpg"></div>
      <div class="h_logo"><img src="img/logo.png"></div>
    </div>
    <div class="sidebar">
      <div class="swiper-container">
        <div class="swiper-wrapper">
          <div class="swiper-slide">
            <div class="menu_box" style=" border-top: 0;">
              <p class="menu_sel_text">기본형</p>
              <div class="menu_title">스타일</div>
            </div>
            <div class="menu_all_list" style="width: 100px;">
              <div class="mal_buttons">
                <div onclick="setMium(0)">기본형</div>
                <div onclick="setMium(1)">ㅁ다리</div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">1200</p>
              <div class="menu_title">폭(W)</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setWidth(1200)">1200</div>
                <div onclick="setWidth(1400)">1400</div>
                <div onclick="setWidth(1600)">1600</div>
                <div onclick="setWidth(1800)">1800</div>
                <div onclick="setWidth(2060)">2060</div>
                <div onclick="setWidth(2360)">2360</div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">500</p>
              <div class="menu_title">깊이(D)</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setDepth(500)">500</div>
                <div onclick="setDepth(600)">600</div>
                <div onclick="setDepth(700)">700</div>
                <div onclick="setDepth(800)">800</div>
                <div onclick="setDepth(1000)">1000</div>
                <div onclick="setDepth(1200)">1200</div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title">수직부재</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setVertical(0)">없음</div>
                <div onclick="setVertical(1)">646</div>
                <div onclick="setVertical(2)">925</div>
                <div onclick="setVertical(3)">1400</div>
                <div onclick="setVertical(4)">1860</div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">위</p>
              <div class="menu_title">수직부재<br>위치조정</div>
            </div>
            <div class="menu_all_list" style="width: 100px;">
              <div class="mal_buttons">
                <div onclick="moveVerticalUp()">위</div>
                <div onclick="moveVerticalDown()">아래</div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">1</p>
              <div class="menu_title">선반갯수</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setShelfNum(1)">1</div>
                <div onclick="setShelfNum(2)">2</div>
                <div onclick="setShelfNum(3)">3</div>
                <div onclick="setShelfNum(4)">4</div>
                <div onclick="setShelfNum(5)">5</div>
                <div onclick="setShelfNum(6)">6</div>
                <div onclick="setShelfNum(7)">7</div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">바깥쪽</p>
              <div class="menu_title">선반방향</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setShelfDirection(0)">바깥쪽</div>
                <div onclick="setShelfDirection(1)">안쪽</div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">화이트</p>
              <div class="menu_title">상판색상</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setBoardColor(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setBoardColor(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
                <div onclick="setBoardColor(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setBoardColor(8)"><img src="texture/maple.jpg"><span>밝은우드</span></div>
                <div onclick="setBoardColor(9)"><img src="texture/natural.jpg"><span>중간우드</span></div>
                <div onclick="setBoardColor(10)"><img src="texture/walnut.jpg"><span>월넛우드</span></div>
                <div onclick="setBoardColor(4)"><img src="texture/natural.jpg"><span>내추럴</span></div>
                <div onclick="setBoardColor(5)"><img src="texture/pine.jpg"><span>파인</span></div>
                <div onclick="setBoardColor(6)"><img src="texture/concrete.jpg"><span>콘크리트</span></div>
                <div onclick="setBoardColor(7)"><img src="texture/redpine.jpg"><span>레드파인</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">화이트</p>
              <div class="menu_title" >프레임색상</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setFrameColor(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setFrameColor(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setFrameColor(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">화이트</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">수직프레임<br>색상</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setVerticalColor(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setVerticalColor(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setVerticalColor(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">화이트</p>
              <div class="menu_title">선반색상</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setShelfBoardColor(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setShelfBoardColor(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
                <div onclick="setShelfBoardColor(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setShelfBoardColor(8)"><img src="texture/maple.jpg"><span>밝은우드</span></div>
                <div onclick="setShelfBoardColor(9)"><img src="texture/natural.jpg"><span>중간우드</span></div>
                <div onclick="setShelfBoardColor(10)"><img src="texture/walnut.jpg"><span>월넛우드</span></div>
                <div onclick="setShelfBoardColor(4)"><img src="texture/natural.jpg"><span>내추럴</span></div>
                <div onclick="setShelfBoardColor(5)"><img src="texture/pine.jpg"><span>파인</span></div>
                <div onclick="setShelfBoardColor(6)"><img src="texture/concrete.jpg"><span>콘크리트</span></div>
                <div onclick="setShelfBoardColor(7)"><img src="texture/redpine.jpg"><span>레드파인</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">화이트</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">선반프레임<br>색상</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setShelfFrameColor(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setShelfFrameColor(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setShelfFrameColor(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title">ㄱ자 모듈</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setGiyeok(0)">없음</div>
                <div onclick="setGiyeok(1)">왼쪽</div>
                <div onclick="setGiyeok(2)">오른쪽</div>
                <div onclick="setGiyeok(3)">중앙</div>
                <div onclick="setGiyeok(4)">양쪽</div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">ㄱ자하부<br>서랍(좌)</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons" id="giyeok-drawer-type-left">
                <div onclick="setGiyeokDrawerTypeLeft(0)">없음</div>
                <div onclick="setGiyeokDrawerTypeLeft(1)">부착서랍1단</div>
                <div onclick="setGiyeokDrawerTypeLeft(2)">부착서랍2단</div>
                <div onclick="setGiyeokDrawerTypeLeft(3)">본체함</div>
                <div onclick="setGiyeokDrawerTypeLeft(4)">이동서랍2단</div>
                <div onclick="setGiyeokDrawerTypeLeft(5)">이동서랍3단</div>
              </div>
              <div class="mal_buttons" id="giyeok-drawer-color-left" style="display: none;">
                <div onclick="setGiyeokDrawerColorLeft(0)">없음</div>
                <div onclick="setGiyeokDrawerColorLeft(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setGiyeokDrawerColorLeft(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
                <div onclick="setGiyeokDrawerColorLeft(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setGiyeokDrawerColorLeft(8)"><img src="texture/maple.jpg"><span>밝은우드</span></div>
                <div onclick="setGiyeokDrawerColorLeft(9)"><img src="texture/natural.jpg"><span>중간우드</span></div>
                <div onclick="setGiyeokDrawerColorLeft(10)"><img src="texture/walnut.jpg"><span>월넛우드</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">ㄱ자하부<br>서랍(우)</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons" id="giyeok-drawer-type-right">
                <div onclick="setGiyeokDrawerTypeRight(0)">없음</div>
                <div onclick="setGiyeokDrawerTypeRight(1)">부착서랍1단</div>
                <div onclick="setGiyeokDrawerTypeRight(2)">부착서랍2단</div>
                <div onclick="setGiyeokDrawerTypeRight(3)">본체함</div>
                <div onclick="setGiyeokDrawerTypeRight(4)">이동서랍2단</div>
                <div onclick="setGiyeokDrawerTypeRight(5)">이동서랍3단</div>
              </div>
              <div class="mal_buttons" id="giyeok-drawer-color-right" style="display: none;">
                <div onclick="setGiyeokDrawerColorRight(0)">없음</div>
                <div onclick="setGiyeokDrawerColorRight(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setGiyeokDrawerColorRight(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
                <div onclick="setGiyeokDrawerColorRight(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setGiyeokDrawerColorRight(8)"><img src="texture/maple.jpg"><span>밝은우드</span></div>
                <div onclick="setGiyeokDrawerColorRight(9)"><img src="texture/natural.jpg"><span>중간우드</span></div>
                <div onclick="setGiyeokDrawerColorRight(10)"><img src="texture/walnut.jpg"><span>월넛우드</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title">데스크매트</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setDeskMat(0)">없음</div>
                <div onclick="setDeskMat(1)"><img src="texture/gray.jpg"><span>그레이</span></div>
                <div onclick="setDeskMat(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setDeskMat(3)"><span>라이트그레이</span></div>
                <div onclick="setDeskMat(4)"><span>베이지</span></div>
                <div onclick="setDeskMat(5)"><span>브라운</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title">미니서랍</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setDrawerColor(0)">없음</div>
                <div onclick="setDrawerColor(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setDrawerColor(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setDrawerColor(3)"><span>오렌지</span></div>
                <div onclick="setDrawerColor(4)"><span>오렌지투명</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title">하부가림판</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setFence(0)">없음</div>
                <div onclick="setFence(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setFence(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
                <div onclick="setFence(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setFence(8)"><img src="texture/maple.jpg"><span>밝은우드</span></div>
                <div onclick="setFence(9)"><img src="texture/natural.jpg"><span>중간우드</span></div>
                <div onclick="setFence(10)"><img src="texture/walnut.jpg"><span>월넛우드</span></div>
                <div onclick="setFence(4)"><img src="texture/natural.jpg"><span>내추럴</span></div>
                <div onclick="setFence(5)"><img src="texture/pine.jpg"><span>파인</span></div>
                <div onclick="setFence(6)"><img src="texture/concrete.jpg"><span>콘크리트</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">이동서랍<br>2단</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setMoving2(0)">없음</div>
                <div onclick="setMoving2(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setMoving2(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
                <div onclick="setMoving2(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setMoving2(8)"><img src="texture/maple.jpg"><span>밝은우드</span></div>
                <div onclick="setMoving2(9)"><img src="texture/natural.jpg"><span>중간우드</span></div>
                <div onclick="setMoving2(10)"><img src="texture/walnut.jpg"><span>월넛우드</span></div>
                <div onclick="setMoving2(14)"><span>오렌지</span></div>
                <div onclick="setMoving2(16)"><span>레몬</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">이동서랍<br>3단</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setMoving3(0)">없음</div>
                <div onclick="setMoving3(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setMoving3(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
                <div onclick="setMoving3(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setMoving3(8)"><img src="texture/maple.jpg"><span>밝은우드</span></div>
                <div onclick="setMoving3(9)"><img src="texture/natural.jpg"><span>중간우드</span></div>
                <div onclick="setMoving3(10)"><img src="texture/walnut.jpg"><span>월넛우드</span></div>
                <div onclick="setMoving3(14)"><span>오렌지</span></div>
                <div onclick="setMoving3(16)"><span>레몬</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">200</p>
              <div class="menu_title">선반깊이</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setShelfDepth(200)">200</div>
                <div onclick="setShelfDepth(360)">360</div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">부착형서랍<br>1단</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setAttach1Left(0)">없음</div>
                <div onclick="setAttach1Left(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setAttach1Left(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
                <div onclick="setAttach1Left(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setAttach1Left(8)"><img src="texture/maple.jpg"><span>밝은우드</span></div>
                <div onclick="setAttach1Left(9)"><img src="texture/natural.jpg"><span>중간우드</span></div>
                <div onclick="setAttach1Left(10)"><img src="texture/walnut.jpg"><span>월넛우드</span></div>
                <div onclick="setAttach1Left(14)"><span>오렌지</span></div>
                <div onclick="setAttach1Left(16)"><span>레몬</span></div>
                <div onclick="setAttach1Right(0)">없음</div>
                <div onclick="setAttach1Right(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setAttach1Right(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
                <div onclick="setAttach1Right(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setAttach1Right(8)"><img src="texture/maple.jpg"><span>밝은우드</span></div>
                <div onclick="setAttach1Right(9)"><img src="texture/natural.jpg"><span>중간우드</span></div>
                <div onclick="setAttach1Right(10)"><img src="texture/walnut.jpg"><span>월넛우드</span></div>
                <div onclick="setAttach1Right(14)"><span>오렌지</span></div>
                <div onclick="setAttach1Right(16)"><span>레몬</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">부착형서랍<br>2단</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setAttach2Left(0)">없음</div>
                <div onclick="setAttach2Left(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setAttach2Left(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
                <div onclick="setAttach2Left(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setAttach2Left(8)"><img src="texture/maple.jpg"><span>밝은우드</span></div>
                <div onclick="setAttach2Left(9)"><img src="texture/natural.jpg"><span>중간우드</span></div>
                <div onclick="setAttach2Left(10)"><img src="texture/walnut.jpg"><span>월넛우드</span></div>
                <div onclick="setAttach2Left(14)"><span>오렌지</span></div>
                <div onclick="setAttach2Left(16)"><span>레몬</span></div>
                <div onclick="setAttach2Right(0)">없음</div>
                <div onclick="setAttach2Right(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setAttach2Right(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
                <div onclick="setAttach2Right(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setAttach2Right(8)"><img src="texture/maple.jpg"><span>밝은우드</span></div>
                <div onclick="setAttach2Right(9)"><img src="texture/natural.jpg"><span>중간우드</span></div>
                <div onclick="setAttach2Right(10)"><img src="texture/walnut.jpg"><span>월넛우드</span></div>
                <div onclick="setAttach2Right(14)"><span>오렌지</span></div>
                <div onclick="setAttach2Right(16)"><span>레몬</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title">본체함</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setAttach3Left(0)">없음</div>
                <div onclick="setAttach3Left(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setAttach3Left(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
                <div onclick="setAttach3Left(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setAttach3Left(8)"><img src="texture/maple.jpg"><span>밝은우드</span></div>
                <div onclick="setAttach3Left(9)"><img src="texture/natural.jpg"><span>중간우드</span></div>
                <div onclick="setAttach3Left(10)"><img src="texture/walnut.jpg"><span>월넛우드</span></div>
                <div onclick="setAttach3Left(14)"><span>오렌지</span></div>
                <div onclick="setAttach3Left(16)"><span>레몬</span></div>
                <div onclick="setAttach3Right(0)">없음</div>
                <div onclick="setAttach3Right(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setAttach3Right(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
                <div onclick="setAttach3Right(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setAttach3Right(8)"><img src="texture/maple.jpg"><span>밝은우드</span></div>
                <div onclick="setAttach3Right(9)"><img src="texture/natural.jpg"><span>중간우드</span></div>
                <div onclick="setAttach3Right(10)"><img src="texture/walnut.jpg"><span>월넛우드</span></div>
                <div onclick="setAttach3Right(14)"><span>오렌지</span></div>
                <div onclick="setAttach3Right(16)"><span>레몬</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">슬라이딩도어<br>1단</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setStorageSliding1(0)">없음</div>
                <div onclick="setStorageSliding1(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setStorageSliding1(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
                <div onclick="setStorageSliding1(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setStorageSliding1(8)"><img src="texture/maple.jpg"><span>밝은우드</span></div>
                <div onclick="setStorageSliding1(9)"><img src="texture/natural.jpg"><span>중간우드</span></div>
                <div onclick="setStorageSliding1(10)"><img src="texture/walnut.jpg"><span>월넛우드</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">슬라이딩도어<br>2단</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setStorageSliding2(0)">없음</div>
                <div onclick="setStorageSliding2(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setStorageSliding2(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
                <div onclick="setStorageSliding2(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setStorageSliding2(8)"><img src="texture/maple.jpg"><span>밝은우드</span></div>
                <div onclick="setStorageSliding2(9)"><img src="texture/natural.jpg"><span>중간우드</span></div>
                <div onclick="setStorageSliding2(10)"><img src="texture/walnut.jpg"><span>월넛우드</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title">플랩도어</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setStorageFlap(0)">없음</div>
                <div onclick="setStorageFlap(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setStorageFlap(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
                <div onclick="setStorageFlap(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setStorageFlap(8)"><img src="texture/maple.jpg"><span>밝은우드</span></div>
                <div onclick="setStorageFlap(9)"><img src="texture/natural.jpg"><span>중간우드</span></div>
                <div onclick="setStorageFlap(10)"><img src="texture/walnut.jpg"><span>월넛우드</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">플랩스테이<br>도어</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setStorageFlapStay(0)">없음</div>
                <div onclick="setStorageFlapStay(1)"><img src="texture/white.jpg"><span>화이트</span></div>
                <div onclick="setStorageFlapStay(3)"><img src="texture/gray.jpg"><span>그레이</span></div>
                <div onclick="setStorageFlapStay(2)"><img src="texture/black.jpg"><span>블랙</span></div>
                <div onclick="setStorageFlapStay(8)"><img src="texture/maple.jpg"><span>밝은우드</span></div>
                <div onclick="setStorageFlapStay(9)"><img src="texture/natural.jpg"><span>중간우드</span></div>
                <div onclick="setStorageFlapStay(10)"><img src="texture/walnut.jpg"><span>월넛우드</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">위</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">수납도어<br>위치조정</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="moveStorageUp()">위</div>
                <div onclick="moveStorageDown()">아래</div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">파티션<br>왼쪽높이</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setPartiVerLHeight(0)">없음</div>
                <div onclick="setPartiVerLHeight(480)">480</div>
                <div onclick="setPartiVerLHeight(800)">800</div>
                <div onclick="setPartiVerLHeight(1200)">1200</div>
                <div onclick="setPartiVerLHeight(1400)">1400</div>
                <div onclick="setPartiVerLHeight(1600)">1600</div>
                <div onclick="setPartiVerLHeight(1800)">1800</div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">그레이</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">파티션<br>왼쪽색상</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setPartiVerLColor(3)"><span>그레이</span></div>
                <div onclick="setPartiVerLColor(12)"><span>베이지</span></div>
                <div onclick="setPartiVerLColor(2)"><span>블랙</span></div>
                <div onclick="setPartiVerLColor(17)"><span>그린</span></div>
                <div onclick="setPartiVerLColor(14)"><span>오렌지</span></div>
                <div onclick="setPartiVerLColor(11)"><span>라이트그레이</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">파티션<br>오른쪽높이</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setPartiVerRHeight(0)">없음</div>
                <div onclick="setPartiVerRHeight(480)">480</div>
                <div onclick="setPartiVerRHeight(800)">800</div>
                <div onclick="setPartiVerRHeight(1200)">1200</div>
                <div onclick="setPartiVerRHeight(1400)">1400</div>
                <div onclick="setPartiVerRHeight(1600)">1600</div>
                <div onclick="setPartiVerRHeight(1800)">1800</div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">그레이</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">파티션<br>오른쪽색상</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setPartiVerRColor(3)"><span>그레이</span></div>
                <div onclick="setPartiVerRColor(12)"><span>베이지</span></div>
                <div onclick="setPartiVerRColor(2)"><span>블랙</span></div>
                <div onclick="setPartiVerRColor(17)"><span>그린</span></div>
                <div onclick="setPartiVerRColor(14)"><span>오렌지</span></div>
                <div onclick="setPartiVerRColor(11)"><span>라이트그레이</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">파티션<br>홀B넓이</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setPartiHolBWidth(0)">없음</div>
                <div onclick="setPartiHolBWidth(1200)">1200</div>
                <div onclick="setPartiHolBWidth(1400)">1400</div>
                <div onclick="setPartiHolBWidth(1600)">1600</div>
                <div onclick="setPartiHolBWidth(1800)">1800</div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">그레이</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">파티션<br>홀B색상</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setPartiHolBColor(3)"><span>그레이</span></div>
                <div onclick="setPartiHolBColor(12)"><span>베이지</span></div>
                <div onclick="setPartiHolBColor(2)"><span>블랙</span></div>
                <div onclick="setPartiHolBColor(17)"><span>그린</span></div>
                <div onclick="setPartiHolBColor(14)"><span>오렌지</span></div>
                <div onclick="setPartiHolBColor(11)"><span>라이트그레이</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">파티션<br>중첩위치높이</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setPartiVerMHeight(0)">없음</div>
                <div onclick="setPartiVerMHeight(460)">460</div>
                <div onclick="setPartiVerMHeight(800)">800</div>
                <div onclick="setPartiVerMHeight(1200)">1200</div>
                <div onclick="setPartiVerMHeight(1400)">1400</div>
                <div onclick="setPartiVerMHeight(1600)">1600</div>
                <div onclick="setPartiVerMHeight(1800)">1800</div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">없음</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">파티션<br>중첩위치색상</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setPartiVerMColor(0)"><span>없음</span></div>
                <div onclick="setPartiVerMColor(1)"><span>화이트</span></div>
                <div onclick="setPartiVerMColor(2)"><span>블랙</span></div>
                <div onclick="setPartiVerMColor(3)"><span>그레이</span></div>
                <div onclick="setPartiVerMColor(4)"><span>다크그레이</span></div>
                <div onclick="setPartiVerMColor(5)"><span>베이지</span></div>
                <div onclick="setPartiVerMColor(6)"><span>브라운</span></div>
                <div onclick="setPartiVerMColor(7)"><span>오렌지</span></div>
                <div onclick="setPartiVerMColor(8)"><span>라이트그레이</span></div>
                <div onclick="setPartiVerMColor(10)"><span>그린</span></div>
              </div>
            </div>
          </div>
          <div class="swiper-slide" id="parti-z-align-menu" style="visibility: hidden; height: 0; overflow: hidden;">
            <div class="menu_box">
              <p class="menu_sel_text">기본 위치</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">파티션<br>Z축 위치</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setPartiZAlignFront(0)">기본 위치</div>
                <div onclick="setPartiZAlignFront(1)">하부옵션 전면</div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">1</p>
              <div class="menu_title">책상 배열</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setDeskArray(1)">1</div>
                <div onclick="setDeskArray(2)">2</div>
                <div onclick="setDeskArray(3)">3</div>
                <div onclick="setDeskArray(4)">4</div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">복사 안함</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">책상<br>맞은편 배열</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setDeskOpposite(0)">복사 안함</div>
                <div onclick="setDeskOpposite(3600)">거리 3600</div>
                <div onclick="setDeskOpposite(-1030)">거리 -1030</div>
                <div onclick="setDeskOpposite(-2400)">거리 -2400</div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
              <p class="menu_sel_text">유지</p>
              <div class="menu_title line2" style="margin-top: -8px; line-height: 1.2;">반대편<br>좌우설정</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="setOppositeKeepSides(true)">유지</div>
                <div onclick="setOppositeKeepSides(false)">바꿈</div>
              </div>
            </div>
          </div>
          <div class="swiper-slide">
            <div class="menu_box">
                <p class="menu_sel_text">Export</p>
              <div class="menu_title">3D 파일</div>
            </div>
            <div class="menu_all_list">
              <div class="mal_buttons">
                <div onclick="exportOBJ()">OBJ</div>
                <div onclick="exportSTL()">STL</div>
              </div>
            </div>
          </div>
        </div>
        <div class="swiper-button-next">Next</div>
        <div class="swiper-button-prev">Prev</div>
      </div>
    </div>
    <div class="footer">
      <div class="ft_inner">
        <div style="width: 35.6%; border-left: 0;">
          <strong class="ft_title">상품코드</strong>
          <div style="position: relative; display: flex; align-items: center;">
            <input type="text" id="product_code_input" class="ft_prd_code" style="background: transparent; border: 1px solid rgba(255,255,255,0.3); color: #fff; font-size: 18px; letter-spacing: -0.5px; width: calc(100% - 40px); padding: 5px; box-sizing: border-box; font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, sans-serif; font-weight: 300;" value="14211-12345-00110" onchange="loadProductFromCode(this.value)" onkeypress="if(event.key==='Enter') loadProductFromCode(this.value)">
            <button id="copy_code_btn" onclick="copyProductCode()" style="background: transparent; border: none; color: #fff; cursor: pointer; padding: 5px 10px; margin-left: 5px; display: flex; align-items: center; justify-content: center; opacity: 0.7; transition: opacity 0.3s;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.7'" title="상품코드 복사">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
              </svg>
            </button>
          </div>
        </div>
        <div style="width: 18.5%;">
          <div class="delivery_box">
            <strong class="ft_title">배송지역 설정</strong>
            <div class="delivery_info">
              <ul class="delivery_area_list">
                <li>서울</li>
                <li>경기</li>
              </ul>
              <span class="delivery_list_more">+</span>
            </div>
          </div>
          <div class="delivery_box">
            <strong class="ft_title">배송 가능 날짜</strong>
            <div class="delivery_info">2017년 12월 31일</div>
          </div>
        </div>
        <div style="width: 18.5%;">
          <div class="delivery_box">
            <strong class="ft_title">배송조립비</strong>
            <div class="delivery_info price">28,000 <span>원</span></div>
          </div>
          <div class="delivery_box">
            <strong class="ft_title">상품금액</strong>
            <div class="delivery_info price">283,000 <span>원</span></div>
          </div>
        </div>
        <div style="width: 27.4%; padding-top: 0;">
          <strong class="ft_total_title">총 결제금액</strong>
          <span class="ft_total_price">123,000<span>원</span></span>
        </div>
      </div>
    </div>

    <div id="canvas">
    </div>
    
    <!-- 회전 정지/재개 버튼 -->
    <div id="rotation-control" style="position: fixed; left: 70px; bottom: 170px; z-index: 1000;">
      <button id="rotation-toggle-btn" onclick="toggleRotation()" style="
        width: 120px;
        height: 120px;
        padding: 0;
        background-color: rgba(0, 100, 0, 0.7);
        color: #fff;
        border: 2px solid #fff;
        border-radius: 50%;
        font-size: 16px;
        cursor: pointer;
        font-family: 'Montserrat', sans-serif;
        transition: all 0.3s;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        line-height: 1.3;
      ">회전시작</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/90/three.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.90.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.90.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="./OrbitControls.js"></script>
    <script src="./OBJExporter.js"></script>
    <script src="./STLExporter.js"></script>

    <script>
      var container;
      var camera, controls, scene, renderer;
      var geometry, geometry1, material;

      var width, height = 700;  // board width and height

      var white_color = 0xf8f9fb;
      var black_color = 0x21201e;
      var gray_color = 0x6f6f6f;
      var light_gray_color = 0xb0b0b0;
      var beige_color = 0xf5f5dc;
      var brown_color = 0x8b4513;
      var orange_color = 0xff8c00;
      var lemon_color = 0xfff700;
      var green_color = 0x228b22;

      var textureLoader = new THREE.TextureLoader();
      
      // 텍스처 설정 헬퍼 함수
      function configureTexture(texture) {
        if (!texture) return;
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.flipY = false;
        texture.needsUpdate = true;
      }
      
      // 텍스처 로드 (콜백으로 로드 완료 후 설정)
      var texture_natural = textureLoader.load('texture/natural.jpg', function(texture) {
        configureTexture(texture);
        // 현재 선택된 색상이 이 텍스처를 사용하는 경우 업데이트
        if (board_color == 4 || board_color == 9) {
          board_material = getMaterial(board_color);
          updateScene();
          render();
        }
      }, undefined, function(error) {
        console.error('natural.jpg 로드 실패:', error);
      });
      
      var texture_pine = textureLoader.load('texture/pine.jpg', function(texture) {
        configureTexture(texture);
        if (board_color == 5) {
          board_material = getMaterial(board_color);
          updateScene();
          render();
        }
      }, undefined, function(error) {
        console.error('pine.jpg 로드 실패:', error);
      });
      
      var texture_concrete = textureLoader.load('texture/concrete.jpg', function(texture) {
        configureTexture(texture);
        if (board_color == 6) {
          board_material = getMaterial(board_color);
          updateScene();
          render();
        }
      }, undefined, function(error) {
        console.error('concrete.jpg 로드 실패:', error);
      });
      
      var texture_redpine = textureLoader.load('texture/redpine.jpg', function(texture) {
        configureTexture(texture);
        if (board_color == 7) {
          board_material = getMaterial(board_color);
          updateScene();
          render();
        }
      }, undefined, function(error) {
        console.error('redpine.jpg 로드 실패:', error);
      });
      
      var texture_maple = textureLoader.load('texture/maple.jpg', function(texture) {
        configureTexture(texture);
        if (board_color == 8) {
          board_material = getMaterial(board_color);
          updateScene();
          render();
        }
      }, undefined, function(error) {
        console.error('maple.jpg 로드 실패:', error);
      });
      
      var texture_walnut = textureLoader.load('texture/walnut.jpg', function(texture) {
        configureTexture(texture);
        if (board_color == 10) {
          board_material = getMaterial(board_color);
          updateScene();
          render();
        }
      }, undefined, function(error) {
        console.error('walnut.jpg 로드 실패:', error);
      });
      
      // 기본 필터 설정 (로드 전에도 적용)
      configureTexture(texture_natural);
      configureTexture(texture_pine);
      configureTexture(texture_concrete);
      configureTexture(texture_redpine);
      configureTexture(texture_maple);
      configureTexture(texture_walnut);

      var plane;
      var plane_size = 10000;
      var plane_material = new THREE.MeshPhongMaterial( {
          color: 0xEEEEEE,
          side: THREE.BackSide
        } );

      // ===== 1그룹: 구조/크기 =====
      // [1] 책상옵션 - 스타일
      var is_mium = 0;
      var mium_leg;

      // [32] 배열/수납 - 책상 배열 수
      var num_desk = 1;
      // [33] 배열/수납 - 맞은편 배열
      // 0: 복사 안함, 3600: z축 거리 3600, -1030: z축 거리 -1030 (전면파티션 복재 안함), -2400: z축 거리 -2400
      var opposite_desk_distance = 0; // 초기값: 미러링 비활성화

      var desk;

      var board;
      var giyeok_board;
      var board_thickness = 20;
      // [2] 책상옵션 - 치수(폭)
      var board_width = 1200;
      var board_width_idx = 1;
      // [3] 책상옵션 - 치수(깊이)
      var board_depth = 500;
      var board_depth_idx = 1;
      // [8] 책상옵션 - 상판 색상
      var board_color = 1;
      var board_material = new THREE.MeshPhongMaterial({ color: white_color });

      var frame;
      var frame_thickness = 40;
      var frame_thickness_under_board = 20;
      var frame_length = 700;
      var frame_margin = 2;       // between frame and board
      // [9] 책상옵션 - 프레임 색상
      var frame_color = 1;
      var frame_material = new THREE.MeshPhongMaterial({ color: white_color });

      var vertical;
      // [4] 책상옵션 - 수직부재 치수(높이)
      var vertical_length_idx = 0;
      var vertical_length = 0;
      var vertical_y;
      var vertical_y_offset = 0; // 수직부재 위치 오프셋 (93.5mm 단위)
      var storage_y_offset = 0; // 수납 도어 위치 오프셋 (93.5mm 단위)
      // [10] 책상옵션 - 수직부재 색상
      var vertical_color = 1;
      var vertical_material = new THREE.MeshPhongMaterial({ color: white_color });

      var shelf;
      // [6] 책상옵션 - 선반(깊이)
      var shelf_depth = 200;
      // [5] 책상옵션 - 선반(수)
      var shelf_num = 0;
      // [7] 책상옵션 - 선반 방향
      var shelf_direction = 0; // out - 0, in - 1
      // [11] 책상옵션 - 선반 상판 색상
      var shelf_board_color = 1;
      // [12] 책상옵션 - 선반 프레임 색상
      var shelf_frame_color = 1;
      var shelf_board_material = new THREE.MeshPhongMaterial({ color: white_color });
      var shelf_frame_material = new THREE.MeshPhongMaterial({ color: white_color });

      var leg_pad;
      var leg_pad_meterial = new THREE.MeshPhongMaterial({ color: white_color });

      // ===== 3그룹: 액세서리 =====
      // [13] 책상옵션 - ㄱ자 모듈
      var giyeok_position = 0;

      // [14] 상판옵션 - 데스크 매트
      var desk_mat_color = 0;
      var desk_mat;
      var desk_mat_material;

      // [15] 상판옵션 - 미니서랍
      var drawer_position = 0;
      var drawer_color = 0;
      var drawer_up;
      var drawer_down;
      var drawer_material = getMaterial(drawer_color);

      // [16] 하부옵션 - 하부가림판
      var fence_color = 0;
      var fence;
      var fence_material = new THREE.MeshPhongMaterial({ color: white_color });

      // [30] 하부옵션 - 2단 이동 서랍
      var moving2_color = 0;
      var moving2_position = 1;
      var moving2;
      var moving2_material = new THREE.MeshPhongMaterial({ color: white_color });
      var drawer1, drawer2, drawer3;
      var wheel;

      // [31] 하부옵션 - 3단 이동 서랍
      var moving3_color = 0;
      var moving3_position = 1;
      var moving3;
      var moving3_material = new THREE.MeshPhongMaterial({ color: white_color });

      // 새로운 옵션 변수들 (좌우 각각 1개씩만 설치 가능)
      // [17] 하부옵션 - 부착형 서랍 1단
      var attach1_left_color = 0;
      var attach1_right_color = 0;
      var attach1;
      var attach1_material = new THREE.MeshPhongMaterial({ color: white_color });
      var attach1_model = null; // GLB 모델

      // [18] 하부옵션 - 부착형 서랍 2단
      var attach2_left_color = 0;
      var attach2_right_color = 0;
      var attach2;
      var attach2_material = new THREE.MeshPhongMaterial({ color: white_color });
      var attach2_model = null; // GLB 모델

      // [19] 하부옵션 - 본체함
      var attach3_left_color = 0;
      var attach3_right_color = 0;
      var attach3;
      var attach3_material = new THREE.MeshPhongMaterial({ color: white_color });
      var attach3_model = null; // GLB 모델

      // [20] 상부옵션 - 수납_슬라이딩도어 1단
      var storage_sliding1_color = 0;
      var storage_sliding1;
      var storage_sliding1_material = new THREE.MeshPhongMaterial({ color: white_color });
      var storage_sliding1_models = {}; // 높이별 GLB 모델 저장

      // [21] 상부옵션 - 수납_슬라이딩도어 2단
      var storage_sliding2_color = 0;
      var storage_sliding2;
      var storage_sliding2_material = new THREE.MeshPhongMaterial({ color: white_color });
      var storage_sliding2_models = {}; // 높이별 GLB 모델 저장

      // [22] 상부옵션 - 수납_플랩도어
      var storage_flap_color = 0;
      var storage_flap;
      var storage_flap_material = new THREE.MeshPhongMaterial({ color: white_color });
      var storage_flap_models = {}; // 높이별 GLB 모델 저장
      var storage_flap_loader = null; // GLTFLoader는 나중에 초기화

      // [23] 상부옵션 - 수납_플랩스테이도어
      var storage_flapstay_color = 0;
      var storage_flapstay;
      var storage_flapstay_material = new THREE.MeshPhongMaterial({ color: white_color });
      var storage_flapstay_models = {}; // 높이별 GLB 모델 저장

      // ㄱ자 데스크 하부 서랍 변수들 (좌우 각각 독립적으로 선택 가능)
      var giyeok_attach1_left_color = 0;
      var giyeok_attach1_right_color = 0;
      var giyeok_attach1_material = new THREE.MeshPhongMaterial({ color: white_color });
      // attach1_model 사용 (일반 부착서랍과 동일)

      var giyeok_attach2_left_color = 0;
      var giyeok_attach2_right_color = 0;
      var giyeok_attach2_material = new THREE.MeshPhongMaterial({ color: white_color });
      // attach2_model 사용 (일반 부착서랍과 동일)

      var giyeok_attach3_left_color = 0;
      var giyeok_attach3_right_color = 0;
      var giyeok_attach3_material = new THREE.MeshPhongMaterial({ color: white_color });
      // attach3_model 사용 (일반 본체함과 동일)

      var giyeok_moving2_left_color = 0;
      var giyeok_moving2_right_color = 0;
      var giyeok_moving2_material = new THREE.MeshPhongMaterial({ color: white_color });
      var giyeok_moving2_model = null; // GLB 모델 (moving2 전용 또는 attach2 재사용)

      var giyeok_moving3_left_color = 0;
      var giyeok_moving3_right_color = 0;
      var giyeok_moving3_material = new THREE.MeshPhongMaterial({ color: white_color });
      var giyeok_moving3_model = null; // GLB 모델 (moving3 전용 또는 attach3 재사용)

      // ㄱ자 하부 서랍 타입 선택 변수 (1: 부착서랍1단, 2: 부착서랍2단, 3: 본체함, 4: 이동서랍2단, 5: 이동서랍3단)
      var giyeok_drawer_type_left = 0;
      var giyeok_drawer_type_right = 0;

      // [24] 파티션옵션 - 파티션_ver_L 높이
      var parti_ver_L_height = 0;
      // [25] 파티션옵션 - 파티션_ver_L 색상
      var parti_ver_L_color = 0;
      var parti_ver_L;
      var parti_ver_L_material = new THREE.MeshPhongMaterial({ color: gray_color });

      // [26] 파티션옵션 - 파티션_ver_R 높이
      var parti_ver_R_height = 0;
      // [27] 파티션옵션 - 파티션_ver_R 색상
      var parti_ver_R_color = 0;
      var parti_ver_R;
      var parti_ver_R_material = new THREE.MeshPhongMaterial({ color: gray_color });

      // [28] 파티션옵션 - 파티션_hol_B_넓이
      var parti_hol_B_width = 0;
      // [29] 파티션옵션 - 파티션_hol_B 색상
      var parti_hol_B_color = 0;
      var parti_hol_B;
      var parti_hol_B_material = new THREE.MeshPhongMaterial({ color: gray_color });

      var parti_ver_M_height = 0; // 중첩위치 파티션 높이 (책상과 책상 사이 중첩되는 위치)
      var parti_ver_M_color = 0;
      var parti_ver_M;
      var parti_ver_M_material = new THREE.MeshPhongMaterial({ color: gray_color });
      
      // [30] 파티션옵션 - 파티션 Z축 위치 정렬 (책상 깊이 1000 이상일 때만 활성화)
      // 0: 기본 위치 (Z=0), 1: 하부옵션 전면과 같은 라인 (Z = board_depth / 2 - 200)
      var parti_z_align_front = 0;

      var link = document.createElement( 'a' );
      link.style.display = 'none';
      document.body.appendChild( link );

      var product_code_string;

      // 아웃라인을 위한 변수 (중복 방지)
      var outlineMeshes = new Set();
      
      // 아웃라인을 위한 헬퍼 함수
      function addOutlineToMesh(mesh) {
        if (!mesh || !mesh.geometry || outlineMeshes.has(mesh)) return null;
        try {
          var edges = new THREE.EdgesGeometry(mesh.geometry);
          var outline = new THREE.LineSegments(
            edges,
            new THREE.LineBasicMaterial({ 
              color: 0x000000, 
              transparent: true,
              opacity: 0.9,
              depthTest: true,
              depthWrite: false
            })
          );
          // 메시와 함께 이동/회전/스케일되도록 메시를 부모로 설정
          mesh.add(outline);
          outlineMeshes.add(mesh);
          return outline;
        } catch(e) {
          console.warn('Failed to add outline:', e);
          return null;
        }
      }
      
      // 씬의 모든 메시에 아웃라인 추가
      function addOutlinesToScene() {
        // 기존 아웃라인 제거
        scene.traverse(function(object) {
          if (object instanceof THREE.LineSegments && object.material && object.material.color && object.material.color.getHex() === 0x000000) {
            if (object.parent) {
              object.parent.remove(object);
            }
          }
        });
        outlineMeshes.clear();
        
        // 모든 메시에 아웃라인 추가
        scene.traverse(function(object) {
          if (object instanceof THREE.Mesh && object.geometry && object.material) {
            // 특정 객체는 제외 (예: 평면, 이미 아웃라인이 있는 경우)
            if (object.userData && object.userData.skipOutline) return;
            // LineSegments는 제외
            if (object instanceof THREE.LineSegments) return;
            addOutlineToMesh(object);
          }
        });
      }

      init();
      animate();

      function init() {
        container = document.getElementById('canvas');
        width = window.innerWidth;
        height = window.innerHeight;

        camera = new THREE.PerspectiveCamera(20, width / height, 100, 50000);
        camera.position.x = 1000 * 2;
        camera.position.y = 1500 * 2;
        camera.position.z = 5000 * 2;

        // GLTFLoader 초기화
        var gltfLoader = null;
        if (typeof THREE.GLTFLoader !== 'undefined') {
          gltfLoader = new THREE.GLTFLoader();
          
          // attach1, attach2, attach3 GLB 모델 로드
          gltfLoader.load('glb/attach1.glb', function(gltf) {
            attach1_model = gltf.scene;
            attach1_model.traverse(function(child) {
              if (child instanceof THREE.Mesh) {
                child.castShadow = true;
                child.receiveShadow = true;
              }
            });
        updateScene();
            render();
          }, undefined, function(error) {
            console.error('attach1.glb 로드 실패:', error);
          });
          
          gltfLoader.load('glb/attach2.glb', function(gltf) {
            attach2_model = gltf.scene;
            attach2_model.traverse(function(child) {
              if (child instanceof THREE.Mesh) {
                child.castShadow = true;
                child.receiveShadow = true;
              }
            });
            updateScene();
            render();
          }, undefined, function(error) {
            console.error('attach2.glb 로드 실패:', error);
          });
          
          gltfLoader.load('glb/attach3.glb', function(gltf) {
            attach3_model = gltf.scene;
            attach3_model.traverse(function(child) {
              if (child instanceof THREE.Mesh) {
                child.castShadow = true;
                child.receiveShadow = true;
              }
            });
            updateScene();
            render();
          }, undefined, function(error) {
            console.error('attach3.glb 로드 실패:', error);
          });
          
          // Storage_Sliding1 높이별 모델 로드
          var sliding1_heights = [1200, 1400, 1600, 1800, 2060];
          sliding1_heights.forEach(function(height) {
            gltfLoader.load('glb/Storage_Sliding1 ' + height + '.glb', function(gltf) {
              storage_sliding1_models[height] = gltf.scene;
              gltf.scene.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                  child.castShadow = true;
                  child.receiveShadow = true;
                }
              });
              updateScene();
              render();
            }, undefined, function(error) {
              console.error('Storage_Sliding1 ' + height + '.glb 로드 실패:', error);
            });
          });
          
          // Storage_Sliding2 높이별 모델 로드
          var sliding2_heights = [1200, 1400, 1600, 1800, 2060];
          sliding2_heights.forEach(function(height) {
            gltfLoader.load('glb/Storage_Sliding2 ' + height + '.glb', function(gltf) {
              storage_sliding2_models[height] = gltf.scene;
              gltf.scene.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                  child.castShadow = true;
                  child.receiveShadow = true;
                }
              });
              updateScene();
              render();
            }, undefined, function(error) {
              console.error('Storage_Sliding2 ' + height + '.glb 로드 실패:', error);
            });
          });
          
          // Storage_Flap 높이별 모델 로드
          var flap_heights = [1200, 1400, 1600, 1800, 2060];
          flap_heights.forEach(function(height) {
            gltfLoader.load('glb/Storage_Flap ' + height + '.glb', function(gltf) {
              storage_flap_models[height] = gltf.scene;
              gltf.scene.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                  child.castShadow = true;
                  child.receiveShadow = true;
                }
              });
              updateScene();
              render();
            }, undefined, function(error) {
              console.error('Storage_Flap ' + height + '.glb 로드 실패:', error);
            });
          });
          
          // Storage_FlapStay 높이별 모델 로드
          var flapstay_heights = [1200, 1400, 1600, 1800, 2060];
          flapstay_heights.forEach(function(height) {
            gltfLoader.load('glb/Storage_FlapStay ' + height + '.glb', function(gltf) {
              storage_flapstay_models[height] = gltf.scene;
              gltf.scene.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                  child.castShadow = true;
                  child.receiveShadow = true;
                }
              });
              updateScene();
              render();
            }, undefined, function(error) {
              console.error('Storage_FlapStay ' + height + '.glb 로드 실패:', error);
            });
          });
        }

        updateScene();
        
        // 선반 방향 UI 초기화
        updateShelfDirectionUI();

        // renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setClearColor(white_color);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(width, height);

        container.appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.autoRotate = false; // 기본적으로 멈춰있게 설정
        controls.autoRotateSpeed *= 2.0;
        controls.rotateSpeed = 5.0;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 1.8;
        controls.target = new THREE.Vector3(0, 500, 0);

        controls.addEventListener('change', render);
        
        // 회전 정지/재개 버튼 초기화
        updateRotationButton();
        
        // 책상 맞은편 미러링 메뉴 초기화
        opposite_desk_distance = 0;
        // UI 초기화는 updateScene()에서 처리됨
        
        // 파티션 Z축 위치 메뉴 초기화
        parti_z_align_front = 0;
        if (board_depth >= 1000) {
          $("#parti-z-align-menu").css({"visibility": "visible", "height": "auto", "overflow": "visible"});
        } else {
          $("#parti-z-align-menu").css({"visibility": "hidden", "height": "0", "overflow": "hidden"});
        }
        
        // Swiper 업데이트 (슬라이드 개수 재계산)
        setTimeout(function() {
          if (window.swiperInstance) {
            window.swiperInstance.update();
            window.swiperInstance.updateSlides();
          }
        }, 100);

        window.addEventListener('resize', onWindowResize, false);

        render();
      }

      function setMium(m) {
        is_mium = m;

        if (checkCollision()) {
          is_mium = 0;
          return;
        }

        updateScene();
        render();
      }

      function setWidth(w) {
        var prev = board_width;

        board_width = w;
        if (checkCollision()) {
          board_width = prev;
          return;
        }

        switch (board_width) {
        case 1200:
          board_width_idx = 1;
          break;
        case 1400:
          board_width_idx = 2;
          break;
        case 1600:
          board_width_idx = 3;
          break;
        case 1800:
          board_width_idx = 4;
          break;
        case 2060:
          board_width_idx = 5;
          break;
        case 2360: // Added based on CSV
          board_width_idx = 6;
          break;
        default:
          board_width_idx = 0;
        }

        updateScene();
        render();
      }

      function setDepth(d) {
        var prev = board_depth;

        board_depth = d;
        if (checkCollision()) {
          board_depth = prev;
          return;
        }

        switch (board_depth) {
        case 500:
          board_depth_idx = 1;
          break;
        case 600:
          board_depth_idx = 2;
          break;
        case 700:
          board_depth_idx = 3;
          break;
        case 800: // Added based on CSV
          board_depth_idx = 4;
          break;
        case 1000: // Added based on CSV
          board_depth_idx = 5;
          break;
        case 1200: // Added based on CSV
          board_depth_idx = 6;
          break;
        default:
          board_depth_idx = 0;
        }
        
        // 파티션 Z축 위치 메뉴 표시/숨김 (책상 깊이 1000 이상일 때만 표시)
        if (board_depth >= 1000) {
          $("#parti-z-align-menu").css({"visibility": "visible", "height": "auto", "overflow": "visible"});
        } else {
          $("#parti-z-align-menu").css({"visibility": "hidden", "height": "0", "overflow": "hidden"});
          parti_z_align_front = 0; // 깊이가 1000 미만이면 기본 위치로 리셋
        }
        
        // Swiper 업데이트 (슬라이드 개수 재계산)
        setTimeout(function() {
          if (window.swiperInstance) {
            window.swiperInstance.update();
            window.swiperInstance.updateSlides();
          }
        }, 50);

        updateScene();
        render();
      }

      function getMaterial(color_code) {
        var material;

        switch (color_code) {
          case 1: // W: 화이트
            material = new THREE.MeshPhongMaterial({ color: white_color });
            return material;
          case 2: // B: 블랙
            material = new THREE.MeshPhongMaterial({ color: black_color });
            return material;
          case 3: // G: 그레이
            material = new THREE.MeshPhongMaterial({ color: gray_color });
            return material;
          case 4: // 내추럴 (W2로도 사용 가능)
          case 9: // W2: 중간밝기 우드 (natural)
            // 텍스처가 로드되었는지 확인
            if (texture_natural && texture_natural.image && texture_natural.image.complete && texture_natural.image.width > 0) {
              configureTexture(texture_natural);
            material = new THREE.MeshPhongMaterial({ map: texture_natural });
            } else {
              // 텍스처가 아직 로드되지 않았으면 임시로 색상 사용
              material = new THREE.MeshPhongMaterial({ color: beige_color });
            }
            return material;
          case 5: // 파인
            if (texture_pine && texture_pine.image && texture_pine.image.complete && texture_pine.image.width > 0) {
              configureTexture(texture_pine);
            material = new THREE.MeshPhongMaterial({ map: texture_pine });
            } else {
              material = new THREE.MeshPhongMaterial({ color: beige_color });
            }
            return material;
          case 6: // 콘크리트
            if (texture_concrete && texture_concrete.image && texture_concrete.image.complete && texture_concrete.image.width > 0) {
              configureTexture(texture_concrete);
            material = new THREE.MeshPhongMaterial({ map: texture_concrete });
            } else {
              material = new THREE.MeshPhongMaterial({ color: gray_color });
            }
            return material;
          case 7: // 레드파인
            if (texture_redpine && texture_redpine.image && texture_redpine.image.complete && texture_redpine.image.width > 0) {
              configureTexture(texture_redpine);
            material = new THREE.MeshPhongMaterial({ map: texture_redpine });
            } else {
              material = new THREE.MeshPhongMaterial({ color: brown_color });
            }
            return material;
          case 8: // W1: 밝은 우드 (maple)
            if (texture_maple && texture_maple.image && texture_maple.image.complete && texture_maple.image.width > 0) {
              configureTexture(texture_maple);
              material = new THREE.MeshPhongMaterial({ map: texture_maple });
            } else {
              material = new THREE.MeshPhongMaterial({ color: beige_color });
            }
            return material;
          case 10: // W3: 월넛 우드 (walnut)
            if (texture_walnut && texture_walnut.image && texture_walnut.image.complete && texture_walnut.image.width > 0) {
              configureTexture(texture_walnut);
              material = new THREE.MeshPhongMaterial({ map: texture_walnut });
            } else {
              material = new THREE.MeshPhongMaterial({ color: brown_color });
            }
            return material;
          case 11: // LG: light grey
            material = new THREE.MeshPhongMaterial({ color: light_gray_color });
            return material;
          case 12: // BE: beige
            material = new THREE.MeshPhongMaterial({ color: beige_color });
            return material;
          case 13: // BR: brown
            material = new THREE.MeshPhongMaterial({ color: brown_color });
            return material;
          case 14: // O: orange
            material = new THREE.MeshPhongMaterial({ color: orange_color });
            return material;
          case 15: // OT: orange transparent (반투명)
            material = new THREE.MeshPhongMaterial({ color: orange_color, transparent: true, opacity: 0.7 });
            return material;
          case 16: // L: lemon
            material = new THREE.MeshPhongMaterial({ color: lemon_color });
            return material;
          case 17: // GN: green
            material = new THREE.MeshPhongMaterial({ color: green_color });
            return material;
          default:
            material = new THREE.MeshPhongMaterial({ color: white_color });
            return material;
        }
      }

      function setBoardColor(c) {
        board_color = c;
        
        // 텍스처가 필요한 색상인지 확인
        var needsTexture = (c == 4 || c == 5 || c == 6 || c == 7 || c == 8 || c == 9 || c == 10);
        var texture = null;
        var textureLoaded = false;
        
        if (c == 4 || c == 9) {
          texture = texture_natural;
        } else if (c == 5) {
          texture = texture_pine;
        } else if (c == 6) {
          texture = texture_concrete;
        } else if (c == 7) {
          texture = texture_redpine;
        } else if (c == 8) {
          texture = texture_maple;
        } else if (c == 10) {
          texture = texture_walnut;
        }
        
        // 텍스처 로드 상태 확인
        if (needsTexture && texture) {
          textureLoaded = (texture.image && texture.image.complete && texture.image.width > 0);
          
          if (textureLoaded) {
            // 텍스처가 이미 로드됨 - 즉시 material 생성
            configureTexture(texture);
            board_material = getMaterial(c);
          } else {
            // 텍스처가 아직 로드되지 않음 - 로드 완료 대기
            var onTextureLoad = function() {
              configureTexture(texture);
        board_material = getMaterial(c);
              updateScene();
              render();
            };
            
            if (texture.image && texture.image.complete) {
              // 이미지가 있지만 완료되지 않음
              texture.image.onload = onTextureLoad;
            } else {
              // 로드 이벤트 리스너 추가
              texture.addEventListener('load', onTextureLoad);
            }
            
            // 임시 material 생성
            board_material = getMaterial(c);
          }
        } else {
          // 텍스처가 필요 없는 색상
          board_material = getMaterial(c);
        }
        
        updateScene();
        render();
      }

      function setFrameColor(c) {
        frame_color = c;
        frame_material = getMaterial(c);

        if (c == 1)
          leg_pad_meterial = new THREE.MeshPhongMaterial({ color: white_color });
        else
          leg_pad_meterial = new THREE.MeshPhongMaterial({ color: black_color });

        updateScene();
        render();
      }

      function setVerticalColor(c) {
        vertical_color = c;
        vertical_material = getMaterial(c);
        updateScene();
        render();
      }

      function setShelfBoardColor(c) {
        shelf_board_color = c;
        shelf_board_material = getMaterial(c);
        updateScene();
        render();
      }

      function setShelfFrameColor(c) {
        shelf_frame_color = c;
        shelf_frame_material = getMaterial(c);
        updateScene();
        render();
      }

      function setVertical(c) {
        vertical_length_idx = c;
        vertical_y_offset = 0; // 수직부재 변경 시 오프셋 초기화
        storage_y_offset = 0; // 수납 도어 오프셋도 초기화
        
        // Updated based on CSV Logic
        switch (c) {
          case 0:
            vertical_length = 0;
            shelf_num = 0;
            break;
          case 1:
            vertical_length = 646; // Updated from 640
            vertical_y = -30;
            break;
          case 2:
            vertical_length = 925; // Updated from 920
            vertical_y = -30;
            break;
          case 3:
            vertical_length = 1400; // New height from CSV
            vertical_y = 240; // Approx positioning
            break;
          case 4:
            vertical_length = 1860;
            vertical_y = 360;
            break;
          default:
            vertical_length = 0;
            shelf_num = 0;
            break;
        }

        adjustShlefNum();

        updateScene();
        render();
      }

      function moveVerticalUp() {
        if (vertical_length == 0) return; // 수직부재가 없으면 동작 안함
        
        var max_up = 0; // 위로 이동 가능한 최대 칸 수
        var max_down = 0; // 아래로 이동 가능한 최대 칸 수
        
        switch (vertical_length_idx) {
          case 1: // 646
            max_up = 3;
            max_down = 3;
            break;
          case 2: // 925
            max_up = 3;
            max_down = 3;
            break;
          case 3: // 1400
            max_up = 3;
            max_down = 0; // 아래로 이동 불가
            break;
          case 4: // 1860
            max_up = 3;
            max_down = 0; // 아래로 이동 불가
            break;
          default:
            return;
        }
        
        // 위로 이동 가능한지 확인
        if (vertical_y_offset < max_up) {
          vertical_y_offset++;
          updateScene();
          render();
        }
      }

      function moveVerticalDown() {
        if (vertical_length == 0) return; // 수직부재가 없으면 동작 안함
        
        var max_up = 0; // 위로 이동 가능한 최대 칸 수
        var max_down = 0; // 아래로 이동 가능한 최대 칸 수
        
        switch (vertical_length_idx) {
          case 1: // 646
            max_up = 3;
            max_down = 3;
            break;
          case 2: // 925
            max_up = 3;
            max_down = 3;
            break;
          case 3: // 1400
            max_up = 3;
            max_down = 0; // 아래로 이동 불가
            break;
          case 4: // 1860
            max_up = 3;
            max_down = 0; // 아래로 이동 불가
            break;
          default:
            return;
        }
        
        // 아래로 이동 가능한지 확인
        if (vertical_y_offset > -max_down) {
          vertical_y_offset--;
          updateScene();
          render();
        }
      }

      function setShelfNum(n) {
        shelf_num = n;
        adjustShlefNum();

        updateScene();
        render();
      }

      function setShelfDirection(d) {
        // 선반 깊이가 360일 때는 바깥방향(0)만 선택 가능
        if (shelf_depth == 360 && d == 1) {
          // 안쪽 선택 시도 시 자동으로 바깥쪽으로 변경
          shelf_direction = 0;
        } else {
          shelf_direction = d;
        }
        // 선반 깊이가 200이고 방향을 안쪽으로 설정할 때는 상부 옵션 해제
        if (shelf_depth == 200 && d == 1) {
          storage_sliding1_color = 0;
          storage_sliding2_color = 0;
          storage_flap_color = 0;
          storage_flapstay_color = 0;
        }
        adjustShlefNum();
        updateShelfDirectionUI();

        updateScene();
        render();
      }

      // 선반 방향 UI 업데이트 함수
      function updateShelfDirectionUI() {
        // 선반 방향 버튼 찾기 (선반방향 메뉴의 버튼들)
        var shelfDirectionSlide = $(".swiper-slide").filter(function() {
          return $(this).find(".menu_title").text().trim() === "선반방향";
        });
        
        if (shelfDirectionSlide.length > 0) {
          var buttons = shelfDirectionSlide.find(".mal_buttons > div");
          var insideButton = buttons.eq(1); // 안쪽 버튼 (두 번째)
          
          // 선반 깊이가 360일 때 안쪽 버튼 비활성화
          if (shelf_depth == 360) {
            insideButton.css({
              "opacity": "0.5",
              "pointer-events": "none",
              "cursor": "not-allowed"
            });
            // 선반 방향 표시 업데이트
            shelfDirectionSlide.find(".menu_sel_text").text("바깥쪽");
          } else {
            // 선반 깊이가 200일 때는 안쪽 버튼 활성화
            insideButton.css({
              "opacity": "1",
              "pointer-events": "auto",
              "cursor": "pointer"
            });
            // 선반 방향 표시 업데이트
            var directionText = shelf_direction == 0 ? "바깥쪽" : "안쪽";
            shelfDirectionSlide.find(".menu_sel_text").text(directionText);
          }
        }
      }

      function setGiyeok(d) {
        var prev = giyeok_position;

        giyeok_position = d;
        if (checkCollision()) {
          giyeok_position = prev;
          return;
        }

        // d: 0=없음, 1=L, 2=R, 3=C, 4=L+R
        updateScene();
        render();
      }

      function setDeskMat(c) {
        var prev = desk_mat_color;

        desk_mat_color = c;
        if (checkCollision()) {
          desk_mat_color = prev;
          return;
        }

        switch (desk_mat_color) {
        case 0:
          break;
        case 1: // G: 그레이
          desk_mat_material = getMaterial(3);
          break;
        case 2: // B: 블랙
          desk_mat_material = getMaterial(2);
          break;
        case 3: // LG: light grey
          desk_mat_material = getMaterial(11);
          break;
        case 4: // BE: beige
          desk_mat_material = getMaterial(12);
          break;
        case 5: // BR: brown
          desk_mat_material = getMaterial(13);
          break;
        }
        updateScene();
        render();
      }

      function setDrawerColor(c) {
        drawer_color = c;
        if (drawer_color) {
          if (giyeok_position == 1)
            drawer_position = 2;
          else
            drawer_position = 1;

          if (checkCollision()) {
            drawer_color = 0;
            return;
          }

          // 색상 코드 매핑: 1=W, 2=B, 3=O, 4=OT
          var color_map = {1: 1, 2: 2, 3: 14, 4: 15};
          drawer_material = getMaterial(color_map[c] || c);
        }
        
        updateScene();
        render();
      }

      function setFence(c) {
        fence_color = c;
        if (fence_color)
          fence_material = getMaterial(c);

        updateScene();
        render();
      }

      function setMoving2(c) {
        moving2_color = c;
        if (moving2_color) {
          if (moving3_color && moving3_position == 1)
            moving2_position = 2;
          else
            moving2_position = 1;

          moving2_material = getMaterial(c);
          
          // 좌우 각각 부착형 서랍과 상호 배타
          if (moving2_position == 1) {
            // 좌측에 부착형 서랍이 있으면 취소
            attach1_left_color = 0;
            attach2_left_color = 0;
            attach3_left_color = 0;
          } else {
            // 우측에 부착형 서랍이 있으면 취소
            attach1_right_color = 0;
            attach2_right_color = 0;
            attach3_right_color = 0;
          }
        }

        updateScene();
        render();
      }

      function setMoving3(c) {
        moving3_color = c;

        if (checkCollision()) {
          moving3_color = 0;
          return;
        }

        if (moving3_color) {
          if (moving2_color && moving2_position == 1)
            moving3_position = 2;
          else
            moving3_position = 1;

          moving3_material = getMaterial(c);
          
          // 좌우 각각 부착형 서랍과 상호 배타
          if (moving3_position == 1) {
            // 좌측에 부착형 서랍이 있으면 취소
            attach1_left_color = 0;
            attach2_left_color = 0;
            attach3_left_color = 0;
          } else {
            // 우측에 부착형 서랍이 있으면 취소
            attach1_right_color = 0;
            attach2_right_color = 0;
            attach3_right_color = 0;
          }
        }

        updateScene();
        render();
      }

      function setDeskArray(n) {
        num_desk = n;

        updateScene();
        render();
      }

      function setDeskOpposite(distance) {
        opposite_desk_distance = distance;
        // UI 업데이트
        var menuText;
        if (distance == 0) {
          menuText = "복사 안함";
        } else if (distance == 3600) {
          menuText = "거리 3600";
        } else if (distance == -1030) {
          menuText = "거리 -1030";
        } else if (distance == -2400) {
          menuText = "거리 -2400";
        } else {
          menuText = "복사 안함";
        }
        $(".swiper-slide").filter(function() {
          return $(this).find(".menu_title").text().trim().includes("책상") && $(this).find(".menu_title").text().trim().includes("맞은편");
        }).find(".menu_sel_text").text(menuText);

        updateScene();
        render();
      }

      // ㄱ자 하부 서랍 타입 선택 - 좌측 (0: 없음, 1: 부착서랍1단, 2: 부착서랍2단, 3: 본체함, 4: 이동서랍2단, 5: 이동서랍3단)
      function setGiyeokDrawerTypeLeft(type) {
        giyeok_drawer_type_left = type;
        if (type == 0) {
          // 모든 좌측 서랍 해제
          giyeok_attach1_left_color = 0;
          giyeok_attach2_left_color = 0;
          giyeok_attach3_left_color = 0;
          giyeok_moving2_left_color = 0;
          giyeok_moving3_left_color = 0;
          $("#giyeok-drawer-color-left").hide();
          // 메뉴 텍스트 업데이트
          $(".swiper-slide").has("#giyeok-drawer-type-left").find(".menu_sel_text").text("없음");
        } else {
          // 색상 선택 메뉴 표시
          $("#giyeok-drawer-color-left").show();
          // 타입 선택 메뉴는 숨기지 않음 (같은 menu_all_list 안에 있으므로)
        }
        updateScene();
        render();
      }

      // ㄱ자 하부 서랍 색상 선택 - 좌측 (선택된 타입 하나만 표시)
      function setGiyeokDrawerColorLeft(c) {
        // 모든 좌측 서랍 초기화
        giyeok_attach1_left_color = 0;
        giyeok_attach2_left_color = 0;
        giyeok_attach3_left_color = 0;
        giyeok_moving2_left_color = 0;
        giyeok_moving3_left_color = 0;
        
        if (c == 0) {
          $(".swiper-slide").has("#giyeok-drawer-type-left").find(".menu_sel_text").text("없음");
        } else {
          // 선택된 타입에만 색상 설정
          var material = getMaterial(c);
          var typeNames = ["", "부착서랍1단", "부착서랍2단", "본체함", "이동서랍2단", "이동서랍3단"];
          var colorNames = ["없음", "화이트", "블랙", "그레이", "", "", "", "", "밝은우드", "중간우드", "월넛우드", "라이트그레이", "", "", "오렌지", "", "레몬"];
          
          if (giyeok_drawer_type_left == 1) {
            giyeok_attach1_left_color = c;
            giyeok_attach1_material = material;
          } else if (giyeok_drawer_type_left == 2) {
            giyeok_attach2_left_color = c;
            giyeok_attach2_material = material;
          } else if (giyeok_drawer_type_left == 3) {
            giyeok_attach3_left_color = c;
            giyeok_attach3_material = material;
          } else if (giyeok_drawer_type_left == 4) {
            giyeok_moving2_left_color = c;
            giyeok_moving2_material = material;
          } else if (giyeok_drawer_type_left == 5) {
            giyeok_moving3_left_color = c;
            giyeok_moving3_material = material;
          }
          
          var colorName = colorNames[c] || "색상" + c;
          $(".swiper-slide").has("#giyeok-drawer-type-left").find(".menu_sel_text").text(typeNames[giyeok_drawer_type_left] + " " + colorName);
        }
        $(".swiper-slide").has("#giyeok-drawer-type-left").find(".menu_all_list").fadeOut();
        updateScene();
        render();
      }

      // ㄱ자 하부 서랍 타입 선택 - 우측
      function setGiyeokDrawerTypeRight(type) {
        giyeok_drawer_type_right = type;
        if (type == 0) {
          // 모든 우측 서랍 해제
          giyeok_attach1_right_color = 0;
          giyeok_attach2_right_color = 0;
          giyeok_attach3_right_color = 0;
          giyeok_moving2_right_color = 0;
          giyeok_moving3_right_color = 0;
          $("#giyeok-drawer-color-right").hide();
          // 메뉴 텍스트 업데이트
          $(".swiper-slide").has("#giyeok-drawer-type-right").find(".menu_sel_text").text("없음");
        } else {
          // 색상 선택 메뉴 표시
          $("#giyeok-drawer-color-right").show();
        }
        updateScene();
        render();
      }

      // ㄱ자 하부 서랍 색상 선택 - 우측 (선택된 타입 하나만 표시)
      function setGiyeokDrawerColorRight(c) {
        // 모든 우측 서랍 초기화
        giyeok_attach1_right_color = 0;
        giyeok_attach2_right_color = 0;
        giyeok_attach3_right_color = 0;
        giyeok_moving2_right_color = 0;
        giyeok_moving3_right_color = 0;
        
        if (c == 0) {
          $(".swiper-slide").has("#giyeok-drawer-type-right").find(".menu_sel_text").text("없음");
        } else {
          // 선택된 타입에만 색상 설정
          var material = getMaterial(c);
          var typeNames = ["", "부착서랍1단", "부착서랍2단", "본체함", "이동서랍2단", "이동서랍3단"];
          var colorNames = ["없음", "화이트", "블랙", "그레이", "", "", "", "", "밝은우드", "중간우드", "월넛우드", "라이트그레이", "", "", "오렌지", "", "레몬"];
          
          if (giyeok_drawer_type_right == 1) {
            giyeok_attach1_right_color = c;
            giyeok_attach1_material = material;
          } else if (giyeok_drawer_type_right == 2) {
            giyeok_attach2_right_color = c;
            giyeok_attach2_material = material;
          } else if (giyeok_drawer_type_right == 3) {
            giyeok_attach3_right_color = c;
            giyeok_attach3_material = material;
          } else if (giyeok_drawer_type_right == 4) {
            giyeok_moving2_right_color = c;
            giyeok_moving2_material = material;
          } else if (giyeok_drawer_type_right == 5) {
            giyeok_moving3_right_color = c;
            giyeok_moving3_material = material;
          }
          
          var colorName = colorNames[c] || "색상" + c;
          $(".swiper-slide").has("#giyeok-drawer-type-right").find(".menu_sel_text").text(typeNames[giyeok_drawer_type_right] + " " + colorName);
        }
        $(".swiper-slide").has("#giyeok-drawer-type-right").find(".menu_all_list").fadeOut();
        updateScene();
        render();
      }

      function setOppositeKeepSides(keep) {
        opposite_keep_sides = keep;

        updateScene();
        render();
      }

      function setShelfDepth(d) {
        shelf_depth = d;
        // 선반 깊이를 360으로 변경할 때, 현재 방향이 안쪽(1)이면 자동으로 바깥쪽(0)으로 변경
        if (d == 360 && shelf_direction == 1) {
          shelf_direction = 0;
          // UI 업데이트: 선반 방향 표시를 "바깥쪽"으로 변경
          updateShelfDirectionUI();
        }
        // 선반 깊이를 200으로 설정하고 방향이 안쪽일 때는 상부 옵션 해제
        if (d == 200 && shelf_direction == 1) {
          storage_sliding1_color = 0;
          storage_sliding2_color = 0;
          storage_flap_color = 0;
          storage_flapstay_color = 0;
        }
        updateScene();
        render();
      }

      // 부착형 서랍 1단 - 좌측 (좌측에는 1단, 2단, 본체함, 이동서랍 2단, 3단 중 하나만 선택 가능)
      function setAttach1Left(c) {
        attach1_left_color = c;
        if (attach1_left_color) {
          // 좌측에서 다른 옵션들 자동 해제
          attach2_left_color = 0;
          attach3_left_color = 0;
          // 좌측에 이동서랍이 있으면 취소
          if (moving2_color && moving2_position == 1) {
            moving2_color = 0;
          }
          if (moving3_color && moving3_position == 1) {
            moving3_color = 0;
          }
          attach1_material = getMaterial(c);
        }
        updateScene();
        render();
      }

      // 부착형 서랍 1단 - 우측 (우측에는 1단, 2단, 본체함, 이동서랍 2단, 3단 중 하나만 선택 가능)
      function setAttach1Right(c) {
        attach1_right_color = c;
        if (attach1_right_color) {
          // 우측에서 다른 옵션들 자동 해제
          attach2_right_color = 0;
          attach3_right_color = 0;
          // 우측에 이동서랍이 있으면 취소
          if (moving2_color && moving2_position == 2) {
            moving2_color = 0;
          }
          if (moving3_color && moving3_position == 2) {
            moving3_color = 0;
          }
          attach1_material = getMaterial(c);
        }
        updateScene();
        render();
      }

      // 부착형 서랍 2단 - 좌측 (좌측에는 1단, 2단, 본체함, 이동서랍 2단, 3단 중 하나만 선택 가능)
      function setAttach2Left(c) {
        attach2_left_color = c;
        if (attach2_left_color) {
          // 좌측에서 다른 옵션들 자동 해제
          attach1_left_color = 0;
          attach3_left_color = 0;
          // 좌측에 이동서랍이 있으면 취소
          if (moving2_color && moving2_position == 1) {
            moving2_color = 0;
          }
          if (moving3_color && moving3_position == 1) {
            moving3_color = 0;
          }
          attach2_material = getMaterial(c);
        }
        updateScene();
        render();
      }

      // 부착형 서랍 2단 - 우측 (우측에는 1단, 2단, 본체함, 이동서랍 2단, 3단 중 하나만 선택 가능)
      function setAttach2Right(c) {
        attach2_right_color = c;
        if (attach2_right_color) {
          // 우측에서 다른 옵션들 자동 해제
          attach1_right_color = 0;
          attach3_right_color = 0;
          // 우측에 이동서랍이 있으면 취소
          if (moving2_color && moving2_position == 2) {
            moving2_color = 0;
          }
          if (moving3_color && moving3_position == 2) {
            moving3_color = 0;
          }
          attach2_material = getMaterial(c);
        }
        updateScene();
        render();
      }

      // 본체함 - 좌측 (좌측에는 1단, 2단, 본체함, 이동서랍 2단, 3단 중 하나만 선택 가능)
      function setAttach3Left(c) {
        attach3_left_color = c;
        if (attach3_left_color) {
          // 좌측에서 다른 옵션들 자동 해제
          attach1_left_color = 0;
          attach2_left_color = 0;
          // 좌측에 이동서랍이 있으면 취소
          if (moving2_color && moving2_position == 1) {
            moving2_color = 0;
          }
          if (moving3_color && moving3_position == 1) {
            moving3_color = 0;
          }
          attach3_material = getMaterial(c);
        }
        updateScene();
        render();
      }

      // 본체함 - 우측 (우측에는 1단, 2단, 본체함, 이동서랍 2단, 3단 중 하나만 선택 가능)
      function setAttach3Right(c) {
        attach3_right_color = c;
        if (attach3_right_color) {
          // 우측에서 다른 옵션들 자동 해제
          attach1_right_color = 0;
          attach2_right_color = 0;
          // 우측에 이동서랍이 있으면 취소
          if (moving2_color && moving2_position == 2) {
            moving2_color = 0;
          }
          if (moving3_color && moving3_position == 2) {
            moving3_color = 0;
          }
          attach3_material = getMaterial(c);
        }
        updateScene();
        render();
      }

      function setStorageSliding1(c) {
        // 선반 깊이 200이고 방향이 안쪽일 때는 상부 옵션 선택 불가
        if (c > 0 && shelf_depth == 200 && shelf_direction == 1) {
          storage_sliding1_color = 0;
          alert('선반 깊이 200이고 방향이 안쪽일 때는 상부 옵션을 선택할 수 없습니다.');
          updateScene();
          render();
          return;
        }
        storage_sliding1_color = c;
        if (storage_sliding1_color) {
          storage_sliding1_material = getMaterial(c);
          // 다른 수납 도어 선택 취소
          storage_sliding2_color = 0;
          storage_flap_color = 0;
          storage_flapstay_color = 0;
          // 수직부재가 1400 또는 1860이 아니면 수직 1860으로 변경
          if (vertical_length_idx != 3 && vertical_length_idx != 4) {
            setVertical(4); // 1860
            // UI 업데이트: 수직부재 메뉴 텍스트 업데이트
            $(".swiper-slide").filter(function() {
              return $(this).find(".menu_title").text().trim() === "수직부재";
            }).find(".menu_sel_text").text("1860");
          }
          // 선반 깊이를 360으로 변경 (항상)
          if (shelf_depth != 360) {
            setShelfDepth(360);
            // UI 업데이트: 선반깊이 메뉴 텍스트 업데이트
            $(".swiper-slide").filter(function() {
              return $(this).find(".menu_title").text().trim() === "선반깊이";
            }).find(".menu_sel_text").text("360");
          }
          // 선반 수를 3개로 변경 (항상)
          if (shelf_num != 3) {
            setShelfNum(3);
            // UI 업데이트: 선반갯수 메뉴 텍스트 업데이트
            $(".swiper-slide").filter(function() {
              return $(this).find(".menu_title").text().trim() === "선반갯수";
            }).find(".menu_sel_text").text("3");
          }
        }
        updateScene();
        render();
      }

      function setStorageSliding2(c) {
        // 선반 깊이 200이고 방향이 안쪽일 때는 상부 옵션 선택 불가
        if (c > 0 && shelf_depth == 200 && shelf_direction == 1) {
          storage_sliding2_color = 0;
          alert('선반 깊이 200이고 방향이 안쪽일 때는 상부 옵션을 선택할 수 없습니다.');
          updateScene();
          render();
          return;
        }
        storage_sliding2_color = c;
        if (storage_sliding2_color) {
          storage_sliding2_material = getMaterial(c);
          // 다른 수납 도어 선택 취소
          storage_sliding1_color = 0;
          storage_flap_color = 0;
          storage_flapstay_color = 0;
          // 수직부재가 1400 또는 1860이 아니면 수직 1860으로 변경
          if (vertical_length_idx != 3 && vertical_length_idx != 4) {
            setVertical(4); // 1860
            // UI 업데이트: 수직부재 메뉴 텍스트 업데이트
            $(".swiper-slide").filter(function() {
              return $(this).find(".menu_title").text().trim() === "수직부재";
            }).find(".menu_sel_text").text("1860");
          }
          // 선반 깊이를 360으로 변경 (항상)
          if (shelf_depth != 360) {
            setShelfDepth(360);
            // UI 업데이트: 선반깊이 메뉴 텍스트 업데이트
            $(".swiper-slide").filter(function() {
              return $(this).find(".menu_title").text().trim() === "선반깊이";
            }).find(".menu_sel_text").text("360");
          }
          // 선반 수를 3개로 변경 (항상)
          if (shelf_num != 3) {
            setShelfNum(3);
            // UI 업데이트: 선반갯수 메뉴 텍스트 업데이트
            $(".swiper-slide").filter(function() {
              return $(this).find(".menu_title").text().trim() === "선반갯수";
            }).find(".menu_sel_text").text("3");
          }
        }
        updateScene();
        render();
      }

      function setStorageFlap(c) {
        // 선반 깊이 200이고 방향이 안쪽일 때는 상부 옵션 선택 불가
        if (c > 0 && shelf_depth == 200 && shelf_direction == 1) {
          storage_flap_color = 0;
          alert('선반 깊이 200이고 방향이 안쪽일 때는 상부 옵션을 선택할 수 없습니다.');
          updateScene();
          render();
          return;
        }
        storage_flap_color = c;
        if (storage_flap_color) {
          storage_flap_material = getMaterial(c);
          // 다른 수납 도어 선택 취소
          storage_sliding1_color = 0;
          storage_sliding2_color = 0;
          storage_flapstay_color = 0;
          // 수직부재가 1400 또는 1860이 아니면 수직 1860으로 변경
          if (vertical_length_idx != 3 && vertical_length_idx != 4) {
            setVertical(4); // 1860
            // UI 업데이트: 수직부재 메뉴 텍스트 업데이트
            $(".swiper-slide").filter(function() {
              return $(this).find(".menu_title").text().trim() === "수직부재";
            }).find(".menu_sel_text").text("1860");
          }
          // 선반 깊이를 360으로 변경 (항상)
          if (shelf_depth != 360) {
            setShelfDepth(360);
            // UI 업데이트: 선반깊이 메뉴 텍스트 업데이트
            $(".swiper-slide").filter(function() {
              return $(this).find(".menu_title").text().trim() === "선반깊이";
            }).find(".menu_sel_text").text("360");
          }
          // 선반 수를 3개로 변경 (항상)
          if (shelf_num != 3) {
            setShelfNum(3);
            // UI 업데이트: 선반갯수 메뉴 텍스트 업데이트
            $(".swiper-slide").filter(function() {
              return $(this).find(".menu_title").text().trim() === "선반갯수";
            }).find(".menu_sel_text").text("3");
          }
        }
        updateScene();
        render();
      }

      function setStorageFlapStay(c) {
        // 선반 깊이 200이고 방향이 안쪽일 때는 상부 옵션 선택 불가
        if (c > 0 && shelf_depth == 200 && shelf_direction == 1) {
          storage_flapstay_color = 0;
          alert('선반 깊이 200이고 방향이 안쪽일 때는 상부 옵션을 선택할 수 없습니다.');
          updateScene();
          render();
          return;
        }
        storage_flapstay_color = c;
        if (storage_flapstay_color) {
          storage_flapstay_material = getMaterial(c);
          // 다른 수납 도어 선택 취소
          storage_sliding1_color = 0;
          storage_sliding2_color = 0;
          storage_flap_color = 0;
          // 수직부재가 1400 또는 1860이 아니면 수직 1860으로 변경
          if (vertical_length_idx != 3 && vertical_length_idx != 4) {
            setVertical(4); // 1860
            // UI 업데이트: 수직부재 메뉴 텍스트 업데이트
            $(".swiper-slide").filter(function() {
              return $(this).find(".menu_title").text().trim() === "수직부재";
            }).find(".menu_sel_text").text("1860");
          }
          // 선반 깊이를 360으로 변경 (항상)
          if (shelf_depth != 360) {
            setShelfDepth(360);
            // UI 업데이트: 선반깊이 메뉴 텍스트 업데이트
            $(".swiper-slide").filter(function() {
              return $(this).find(".menu_title").text().trim() === "선반깊이";
            }).find(".menu_sel_text").text("360");
          }
          // 선반 수를 3개로 변경 (항상)
          if (shelf_num != 3) {
            setShelfNum(3);
            // UI 업데이트: 선반갯수 메뉴 텍스트 업데이트
            $(".swiper-slide").filter(function() {
              return $(this).find(".menu_title").text().trim() === "선반갯수";
            }).find(".menu_sel_text").text("3");
          }
        }
        updateScene();
        render();
      }

      function moveStorageUp() {
        // 수납 도어가 선택되어 있고, 수직부재가 1400 또는 1860이어야 함
        if ((storage_sliding1_color == 0 && storage_sliding2_color == 0 && storage_flap_color == 0 && storage_flapstay_color == 0) || 
            (vertical_length_idx != 3 && vertical_length_idx != 4)) {
          return;
        }
        
        var max_up = 0;
        var max_down = 0;
        
        switch (vertical_length_idx) {
          case 3: // 1400
            max_up = 10;
            max_down = 10;
            break;
          case 4: // 1860
            max_up = 12;
            max_down = 12;
            break;
          default:
            return;
        }
        
        // 위로 이동 가능한지 확인
        if (storage_y_offset < max_up) {
          storage_y_offset++;
          updateScene();
          render();
        }
      }

      function moveStorageDown() {
        // 수납 도어가 선택되어 있고, 수직부재가 1400 또는 1860이어야 함
        if ((storage_sliding1_color == 0 && storage_sliding2_color == 0 && storage_flap_color == 0 && storage_flapstay_color == 0) || 
            (vertical_length_idx != 3 && vertical_length_idx != 4)) {
          return;
        }
        
        var max_up = 0;
        var max_down = 0;
        
        switch (vertical_length_idx) {
          case 3: // 1400
            max_up = 10;
            max_down = 10;
            break;
          case 4: // 1860
            max_up = 12;
            max_down = 12;
            break;
          default:
            return;
        }
        
        // 아래로 이동 가능한지 확인
        if (storage_y_offset > -max_down) {
          storage_y_offset--;
          updateScene();
          render();
        }
      }

      function setPartiVerLHeight(h) {
        parti_ver_L_height = h;
        if (parti_ver_L_height > 0 && parti_ver_L_color == 0) {
          parti_ver_L_color = 3; // 기본값: 그레이
        }
        updateScene();
        render();
      }

      function setPartiVerLColor(c) {
        parti_ver_L_color = c;
        if (parti_ver_L_color) {
          parti_ver_L_material = getMaterial(c);
        }
        updateScene();
        render();
      }

      function setPartiVerRHeight(h) {
        parti_ver_R_height = h;
        if (parti_ver_R_height > 0 && parti_ver_R_color == 0) {
          parti_ver_R_color = 3; // 기본값: 그레이
        }
        updateScene();
        render();
      }

      function setPartiVerRColor(c) {
        parti_ver_R_color = c;
        if (parti_ver_R_color) {
          parti_ver_R_material = getMaterial(c);
        }
        updateScene();
        render();
      }

      function setPartiHolBWidth(w) {
        parti_hol_B_width = w;
        if (parti_hol_B_width > 0 && parti_hol_B_color == 0) {
          parti_hol_B_color = 3; // 기본값: 그레이
        }
        updateScene();
        render();
      }

      function setPartiHolBColor(c) {
        parti_hol_B_color = c;
        if (parti_hol_B_color) {
          parti_hol_B_material = getMaterial(c);
        }
        updateScene();
        render();
      }

      function setPartiVerMHeight(h) {
        parti_ver_M_height = h;
        if (parti_ver_M_height > 0 && parti_ver_M_color == 0) {
          parti_ver_M_color = 3; // 기본값: 그레이
        }
        updateScene();
        render();
      }

      function setPartiVerMColor(c) {
        parti_ver_M_color = c;
        if (parti_ver_M_color) {
          parti_ver_M_material = getMaterial(c);
        }
        updateScene();
        render();
      }
      
      function setPartiZAlignFront(align) {
        parti_z_align_front = align;
        
        // 메뉴 UI 업데이트
        var menuText = align == 1 ? "하부옵션 전면" : "기본 위치";
        $("#parti-z-align-menu .menu_sel_text").text(menuText);
        
        updateScene();
        render();
      }
      
      // 상품코드 복사 함수
      function copyProductCode() {
        var productCodeInput = document.getElementById("product_code_input");
        if (productCodeInput) {
          productCodeInput.select();
          productCodeInput.setSelectionRange(0, 99999); // 모바일에서도 작동하도록
          
          try {
            document.execCommand('copy');
            // 복사 성공 피드백
            var copyBtn = document.getElementById("copy_code_btn");
            if (copyBtn) {
              var originalTitle = copyBtn.getAttribute('title');
              copyBtn.setAttribute('title', '복사되었습니다!');
              setTimeout(function() {
                copyBtn.setAttribute('title', originalTitle || '상품코드 복사');
              }, 2000);
            }
          } catch (err) {
            // Clipboard API 사용 (최신 브라우저)
            if (navigator.clipboard && navigator.clipboard.writeText) {
              navigator.clipboard.writeText(productCodeInput.value).then(function() {
                var copyBtn = document.getElementById("copy_code_btn");
                if (copyBtn) {
                  var originalTitle = copyBtn.getAttribute('title');
                  copyBtn.setAttribute('title', '복사되었습니다!');
                  setTimeout(function() {
                    copyBtn.setAttribute('title', originalTitle || '상품코드 복사');
                  }, 2000);
                }
              }).catch(function(err) {
                console.error('복사 실패:', err);
                alert('상품코드 복사에 실패했습니다.');
              });
            } else {
              alert('상품코드를 복사할 수 없습니다. 브라우저를 업데이트해주세요.');
            }
          }
        }
      }

      // ㄱ자 하부 서랍 생성 헬퍼 함수
      // targetGroup이 제공되면 그룹에 추가하고, 그렇지 않으면 씬에 직접 추가
      function createGiyeokDrawer(drawerType, drawerColor, side, deskOffsetX, giyeokAttachTopY, giyeokInnerX, giyeokInnerZ, rotationY, targetGroup) {
        if (!drawerColor) return null;
        
        var model = null;
        var geometry = null;
        var height = 0;
        
        // 타입별 모델과 크기 설정
        if (drawerType == 1) {
          model = attach1_model;
          geometry = new THREE.BoxBufferGeometry(300, 160, 400);
          height = 160;
        } else if (drawerType == 2) {
          model = attach2_model;
          geometry = new THREE.BoxBufferGeometry(300, 500, 400);
          height = 500;
        } else if (drawerType == 3) {
          model = attach3_model;
          geometry = new THREE.BoxBufferGeometry(300, 500, 400);
          height = 500;
        } else if (drawerType == 4) {
          model = attach2_model; // moving2는 attach2 재사용
          geometry = new THREE.BoxBufferGeometry(300, 585, 400);
          height = 585;
        } else if (drawerType == 5) {
          model = attach3_model; // moving3는 attach3 재사용
          geometry = new THREE.BoxBufferGeometry(400, 585, 580);
          height = 585;
        }
        
        if (!model && !geometry) return null;
        
        var drawer;
        if (model) {
          drawer = model.clone();
          drawer.traverse(function(child) {
            if (child instanceof THREE.Mesh) {
              child.material = getMaterial(drawerColor);
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });
        } else {
          var material = getMaterial(drawerColor);
          drawer = new THREE.Mesh(geometry, material);
          drawer.castShadow = true;
        }
        
        var yPos = (drawerType == 4 || drawerType == 5) ? height / 2 : giyeokAttachTopY - height / 2;
        drawer.position.set(giyeokInnerX, yPos, giyeokInnerZ);
        drawer.rotation.y = rotationY;
        
        // 그룹이 제공되면 그룹에 추가, 그렇지 않으면 씬에 직접 추가
        if (targetGroup) {
          targetGroup.add(drawer);
        } else {
          scene.add(drawer);
        }
        return drawer;
      }
      
      // 부착형 서랍 생성 헬퍼 함수
      function createAttachDrawer(attachType, attachColor, side, deskOffsetX, attachTopY, legInnerX, zPos) {
        if (!attachColor) return null;
        
        var model = null;
        var geometry = null;
        var height = 0;
        
        if (attachType == 1) {
          model = attach1_model;
          geometry = new THREE.BoxBufferGeometry(300, 160, 400);
          height = 160;
        } else if (attachType == 2) {
          model = attach2_model;
          geometry = new THREE.BoxBufferGeometry(300, 500, 400);
          height = 500;
        } else if (attachType == 3) {
          model = attach3_model;
          geometry = new THREE.BoxBufferGeometry(300, 500, 400);
          height = 500;
        }
        
        if (!model && !geometry) return null;
        
        var attach;
        if (model) {
          attach = model.clone();
          attach.traverse(function(child) {
            if (child instanceof THREE.Mesh) {
              child.material = getMaterial(attachColor);
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });
        } else {
          var material = getMaterial(attachColor);
          attach = new THREE.Mesh(geometry, material);
          attach.castShadow = true;
        }
        
        attach.position.set(deskOffsetX + legInnerX, attachTopY - height / 2, zPos);
        scene.add(attach);
        return attach;
      }
      
      // 반대편 ㄱ자 하부 서랍 생성 헬퍼 함수 (그룹용 - 상대 위치 반환)
      // 그룹에 scale.z = -1이 적용되므로, 원래 위치를 그대로 사용하면 자동으로 미러링됨
      function createOppositeGiyeokDrawer(drawerType, drawerColor, oppositeDeskX, giyeokAttachTopY, oppositeDeskZ, isLeft, targetGroup) {
        if (!drawerColor) return null;
        
        // 그룹 내 상대 위치로 계산 (그룹의 위치는 opposite_desk_offset_x, 0, opposite_desk_z)
        // 원래 책상의 위치 계산과 동일하게 하되, 그룹 중심(0, 0, 0) 기준으로 계산
        // 원래: giyeok_inner_x = desk_offset_x - (board_width - 600) / 2 + 300 - 200 (왼쪽)
        // 그룹 기준: giyeok_inner_x = - (board_width - 600) / 2 + 300 - 200 (왼쪽)
        var giyeok_inner_x = isLeft ? 
          - (board_width - 600) / 2 + 300 - 200 : // 좌측 ㄱ자 우측 끝 -200 (그룹 중심 기준)
          (board_width - 600) / 2 - 300 + 200; // 우측 ㄱ자 좌측 끝 +200 (그룹 중심 기준)
        
        // 원래 위치: giyeok_inner_z = (board_depth + 800) / 2 - 200 + 400
        // 그룹에 scale.z = -1이 적용되므로, 원래 위치를 그대로 사용하면 자동으로 반전됨
        var giyeok_inner_z = (board_depth + 800) / 2 - 200 + 400; // 원래 위치 그대로 사용 (그룹 중심 기준)
        var rotationY = isLeft ? Math.PI / 2 : -Math.PI / 2;
        
        return createGiyeokDrawer(drawerType, drawerColor, isLeft ? 'left' : 'right', 0, giyeokAttachTopY, giyeok_inner_x, giyeok_inner_z, rotationY, targetGroup);
      }
      
      // 반대편 부착형 서랍 생성 헬퍼 함수 (그룹용 - 상대 위치 반환)
      function createOppositeAttachDrawerForGroup(attachType, attachColor, leg_inner_x, attach_top_y, attach_z) {
        if (!attachColor) return null;
        
        var model = null;
        var geometry = null;
        var height = 0;
        
        if (attachType == 1) {
          model = attach1_model;
          geometry = new THREE.BoxBufferGeometry(300, 160, 400);
          height = 160;
        } else if (attachType == 2) {
          model = attach2_model;
          geometry = new THREE.BoxBufferGeometry(300, 500, 400);
          height = 500;
        } else if (attachType == 3) {
          model = attach3_model;
          geometry = new THREE.BoxBufferGeometry(300, 500, 400);
          height = 500;
        }
        
        if (!model && !geometry) return null;
        
        var attach;
        if (model) {
          attach = model.clone();
          attach.traverse(function(child) {
            if (child instanceof THREE.Mesh) {
              child.material = getMaterial(attachColor);
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });
        } else {
          var material = getMaterial(attachColor);
          attach = new THREE.Mesh(geometry, material);
          attach.castShadow = true;
        }
        
        // 상대 위치로 설정 (그룹 내에서의 위치)
        attach.position.set(leg_inner_x, attach_top_y - height / 2, attach_z);
        return attach;
      }
      
      // 반대편 부착형 서랍 생성 헬퍼 함수
      // 거울 반사: isLeft가 true면 우측에, false면 좌측에 배치 (원래와 반대)
      function createOppositeAttachDrawer(attachType, attachColor, oppositeDeskOffsetX, oppositeDeskZ, isLeft) {
        if (!attachColor) return null;
        
        var attach_top_y = frame_length + board_thickness - 60;
        var leg_inner_x;
        // 거울 반사: isLeft가 true면 원래 좌측이었으므로 반대편에서는 우측에 배치
        if (isLeft) {
          leg_inner_x = (board_width - frame_thickness) / 2 - frame_thickness / 2 - 155; // 우측
        } else {
          leg_inner_x = - (board_width - frame_thickness) / 2 + frame_thickness / 2 + 155; // 좌측
        }
        
        var model = null;
        var geometry = null;
        var height = 0;
        
        if (attachType == 1) {
          model = attach1_model;
          geometry = new THREE.BoxBufferGeometry(300, 160, 400);
          height = 160;
        } else if (attachType == 2) {
          model = attach2_model;
          geometry = new THREE.BoxBufferGeometry(300, 500, 400);
          height = 500;
        } else if (attachType == 3) {
          model = attach3_model;
          geometry = new THREE.BoxBufferGeometry(300, 500, 400);
          height = 500;
        }
        
        if (!model && !geometry) return null;
        
        var attach;
        if (model) {
          attach = model.clone();
          attach.traverse(function(child) {
            if (child instanceof THREE.Mesh) {
              child.material = getMaterial(attachColor);
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });
        } else {
          var material = getMaterial(attachColor);
          attach = new THREE.Mesh(geometry, material);
          attach.castShadow = true;
        }
        
        // 반대편 앞뒤 반전: Z 위치를 반대로 계산 (수직부재 쪽 기준)
        attach.position.set(oppositeDeskOffsetX + leg_inner_x, attach_top_y - height / 2, oppositeDeskZ + (board_depth / 2 - 200));
        scene.add(attach);
        return attach;
      }

      function checkCollision() {
        // Rule: L-module and Mini-drawer collision
        if (giyeok_position && drawer_color && (giyeok_position == drawer_position)) {
          alert("ㄱ자 모듈과 미니서랍이 겹칩니다.");
          return true;
        }

        // Rule: Width < 2000 implies collision between L-module and Mat
        if (giyeok_position && desk_mat_color && (board_width < 2000)) {
          alert("폭이 2000 미만일 경우 데스크매트와 ㄱ자 모듈이 겹칩니다.");
          return true;
        }

        // Rule: Width < 1500 implies collision between Mat and Mini-drawer
        if (desk_mat_color && drawer_color && (board_width < 1500)) {
          alert("데스크매트와 미니서랍이 겹칩니다.");
          return true;
        }

        // Rule: Fence and 3-drawer collision
        if (fence_color && moving3_color) {
          alert("하부가림막과 3단 서랍이 겹칩니다.");
          return true;
        }

        // Rule: Square leg allowed only at depth 600
        if (board_depth != 600 && is_mium) {
          alert("ㅁ다리는 상판깊이가 600일 때만 가능합니다.");
          return true;
        }

        return false;
      }

      function adjustShlefNum() {
        var max_shelf_num = 0;

        // Rule 5: Shelf number constraints based on vertical height
        switch (vertical_length) {
          case 0:
            shelf_num = 0;
            return;
          case 646:
            max_shelf_num = 3;
            break;
          case 925:
            max_shelf_num = 4; // Updated from 5 to 4 based on CSV Rule 5
            break;
          case 1400:
            max_shelf_num = 5; // New rule for 1400 height
            break;
          case 1860:
            max_shelf_num = 7;
            break;
          default:
            max_shelf_num = 0;
            break;
        }

        if (max_shelf_num < shelf_num)
          shelf_num = max_shelf_num;

        if ((vertical_length > 0) && (shelf_num == 0))
          shelf_num = 1;
      }

      function generateProductCode() {
        var ret;
        var sub_str;

        if (is_mium)
          ret = "2";
        else
          ret = "1";
        
        sub_str = board_width_idx.toString();
        ret += sub_str;

        sub_str = board_depth_idx.toString();
        ret += sub_str;

        sub_str = vertical_length_idx.toString();
        ret += sub_str;

        if (vertical_length) {
          sub_str = shelf_num.toString();
          ret += sub_str;
        }
        else
          ret += "0";

        // delimiter
        ret += "-";

        if (shelf_direction)
          ret += "2";
        else
          ret += "1";
          
        sub_str = board_color.toString();
        ret += sub_str;

        sub_str = frame_color.toString();
        ret += sub_str;

        sub_str = vertical_color.toString();
        ret += sub_str;

        sub_str = shelf_board_color.toString();
        ret += sub_str;

        // delimiter
        ret += "-";

        sub_str = shelf_frame_color.toString();
        ret += sub_str;

        sub_str = giyeok_position.toString();
        ret += sub_str;

        sub_str = desk_mat_color.toString();
        ret += sub_str;

        sub_str = drawer_color.toString();
        ret += sub_str;

        sub_str = fence_color.toString();
        ret += sub_str;

        // delimiter
        ret += "-";

        sub_str = moving2_color.toString();
        ret += sub_str;

        sub_str = moving3_color.toString();
        ret += sub_str;

        sub_str = num_desk.toString();
        ret += sub_str;

        // 맞은편 배열 거리: 0=복사 안함, 3600=거리 3600, -1030=거리 -1030, -2400=거리 -2400
        if (opposite_desk_distance == 0)
          ret += "1";
        else if (opposite_desk_distance == 3600)
          ret += "2";
        else if (opposite_desk_distance == -1030)
          ret += "3";
        else if (opposite_desk_distance == -2400)
          ret += "4";
        else
          ret += "1";

        // delimiter
        ret += "-";

        // 새로운 옵션들 추가 (좌우 각각)
        sub_str = attach1_left_color.toString();
        ret += sub_str;
        sub_str = attach1_right_color.toString();
        ret += sub_str;

        sub_str = attach2_left_color.toString();
        ret += sub_str;
        sub_str = attach2_right_color.toString();
        ret += sub_str;

        sub_str = attach3_left_color.toString();
        ret += sub_str;
        sub_str = attach3_right_color.toString();
        ret += sub_str;

        sub_str = storage_sliding1_color.toString();
        ret += sub_str;

        sub_str = storage_sliding2_color.toString();
        ret += sub_str;

        sub_str = storage_flap_color.toString();
        ret += sub_str;

        sub_str = storage_flapstay_color.toString();
        ret += sub_str;

        // delimiter
        ret += "-";

        // 파티션 옵션들 (높이/넓이 값은 인덱스로 변환)
        // parti_ver_L_height: 0=없음, 1=480, 2=800, 3=1200, 4=1400, 5=1600, 6=1800
        var parti_ver_L_height_idx = 0;
        if (parti_ver_L_height == 480) parti_ver_L_height_idx = 1;
        else if (parti_ver_L_height == 800) parti_ver_L_height_idx = 2;
        else if (parti_ver_L_height == 1200) parti_ver_L_height_idx = 3;
        else if (parti_ver_L_height == 1400) parti_ver_L_height_idx = 4;
        else if (parti_ver_L_height == 1600) parti_ver_L_height_idx = 5;
        else if (parti_ver_L_height == 1800) parti_ver_L_height_idx = 6;
        ret += parti_ver_L_height_idx.toString();

        sub_str = parti_ver_L_color.toString();
        ret += sub_str;

        // parti_ver_R_height: 0=없음, 1=480, 2=800, 3=1200, 4=1400, 5=1600, 6=1800
        var parti_ver_R_height_idx = 0;
        if (parti_ver_R_height == 480) parti_ver_R_height_idx = 1;
        else if (parti_ver_R_height == 800) parti_ver_R_height_idx = 2;
        else if (parti_ver_R_height == 1200) parti_ver_R_height_idx = 3;
        else if (parti_ver_R_height == 1400) parti_ver_R_height_idx = 4;
        else if (parti_ver_R_height == 1600) parti_ver_R_height_idx = 5;
        else if (parti_ver_R_height == 1800) parti_ver_R_height_idx = 6;
        ret += parti_ver_R_height_idx.toString();

        sub_str = parti_ver_R_color.toString();
        ret += sub_str;

        // parti_ver_M_height: 0=없음, 1=460, 2=800, 3=1200, 4=1400, 5=1600, 6=1800
        var parti_ver_M_height_idx = 0;
        if (parti_ver_M_height == 460) parti_ver_M_height_idx = 1;
        else if (parti_ver_M_height == 800) parti_ver_M_height_idx = 2;
        else if (parti_ver_M_height == 1200) parti_ver_M_height_idx = 3;
        else if (parti_ver_M_height == 1400) parti_ver_M_height_idx = 4;
        else if (parti_ver_M_height == 1600) parti_ver_M_height_idx = 5;
        else if (parti_ver_M_height == 1800) parti_ver_M_height_idx = 6;
        ret += parti_ver_M_height_idx.toString();

        sub_str = parti_ver_M_color.toString();
        ret += sub_str;

        // parti_hol_B_width: 0=없음, 1=1200, 2=1400, 3=1600, 4=1800
        var parti_hol_B_width_idx = 0;
        if (parti_hol_B_width == 1200) parti_hol_B_width_idx = 1;
        else if (parti_hol_B_width == 1400) parti_hol_B_width_idx = 2;
        else if (parti_hol_B_width == 1600) parti_hol_B_width_idx = 3;
        else if (parti_hol_B_width == 1800) parti_hol_B_width_idx = 4;
        ret += parti_hol_B_width_idx.toString();

        sub_str = parti_hol_B_color.toString();
        ret += sub_str;
        
        // 파티션 Z축 위치 정렬 (책상 깊이 1000 이상일 때만 사용)
        sub_str = parti_z_align_front.toString();
        ret += sub_str;

        // delimiter
        ret += "-";

        // ㄱ자 하부 서랍 옵션들
        sub_str = giyeok_drawer_type_left.toString();
        ret += sub_str;
        
        // 좌측 색상: 타입에 따라 해당 색상 값 사용
        var giyeok_left_color_val = 0;
        if (giyeok_drawer_type_left == 1) {
          giyeok_left_color_val = giyeok_attach1_left_color;
        } else if (giyeok_drawer_type_left == 2) {
          giyeok_left_color_val = giyeok_attach2_left_color;
        } else if (giyeok_drawer_type_left == 3) {
          giyeok_left_color_val = giyeok_attach3_left_color;
        } else if (giyeok_drawer_type_left == 4) {
          giyeok_left_color_val = giyeok_moving2_left_color;
        } else if (giyeok_drawer_type_left == 5) {
          giyeok_left_color_val = giyeok_moving3_left_color;
        }
        sub_str = giyeok_left_color_val.toString();
        ret += sub_str;

        sub_str = giyeok_drawer_type_right.toString();
        ret += sub_str;
        
        // 우측 색상: 타입에 따라 해당 색상 값 사용
        var giyeok_right_color_val = 0;
        if (giyeok_drawer_type_right == 1) {
          giyeok_right_color_val = giyeok_attach1_right_color;
        } else if (giyeok_drawer_type_right == 2) {
          giyeok_right_color_val = giyeok_attach2_right_color;
        } else if (giyeok_drawer_type_right == 3) {
          giyeok_right_color_val = giyeok_attach3_right_color;
        } else if (giyeok_drawer_type_right == 4) {
          giyeok_right_color_val = giyeok_moving2_right_color;
        } else if (giyeok_drawer_type_right == 5) {
          giyeok_right_color_val = giyeok_moving3_right_color;
        }
        sub_str = giyeok_right_color_val.toString();
        ret += sub_str;

        // 선반 깊이 (part6의 마지막)
        if (shelf_depth == 200)
          ret += "1";
        else if (shelf_depth == 360)
          ret += "2";
        else
          ret += "0";

        return ret;
      }

      // 코드에서 제품 생성 함수
      function loadProductFromCode(code) {
        if (!code || code.trim() === '') {
          alert('상품코드를 입력해주세요.');
          return;
        }
        
        try {
          var parts = code.split('-');
          if (parts.length < 6) {
            alert('상품코드 형식이 올바르지 않습니다.');
            return;
          }
          
          var part1 = parts[0]; // 구조 정보
          var part2 = parts[1]; // 색상 정보 (기본)
          var part3 = parts[2]; // 색상 정보 (추가)
          var part4 = parts[3]; // 옵션 정보
          var part5 = parts[4]; // 파티션 및 선반 깊이
          var part6 = parts[5]; // ㄱ자 하부 서랍 옵션
          
          // part1 파싱: is_mium(1) + board_width_idx(1) + board_depth_idx(1) + vertical_length_idx(1) + shelf_num(1)
          if (part1.length >= 5) {
            var is_mium_val = parseInt(part1[0]);
            var board_width_idx_val = parseInt(part1[1]);
            var board_depth_idx_val = parseInt(part1[2]);
            var vertical_length_idx_val = parseInt(part1[3]);
            var shelf_num_val = parseInt(part1[4]);
            
            // is_mium 설정
            if (is_mium_val == 2) {
              setMium(1);
            } else {
              setMium(0);
            }
            
            // board_width 설정
            var width_values = [0, 1200, 1400, 1600, 1800, 2060, 2360];
            if (board_width_idx_val > 0 && board_width_idx_val < width_values.length) {
              setWidth(width_values[board_width_idx_val]);
            }
            
            // board_depth 설정
            var depth_values = [0, 500, 600, 700, 800, 1000, 1200];
            if (board_depth_idx_val > 0 && board_depth_idx_val < depth_values.length) {
              setDepth(depth_values[board_depth_idx_val]);
            }
            
            // vertical_length 설정
            setVertical(vertical_length_idx_val);
            
            // shelf_num 설정
            if (shelf_num_val > 0) {
              setShelfNum(shelf_num_val);
            }
          }
          
          // part2 파싱: shelf_direction(1) + board_color(1) + frame_color(1) + vertical_color(1) + shelf_board_color(1)
          if (part2.length >= 5) {
            var shelf_direction_val = parseInt(part2[0]);
            var board_color_val = parseInt(part2[1]);
            var frame_color_val = parseInt(part2[2]);
            var vertical_color_val = parseInt(part2[3]);
            var shelf_board_color_val = parseInt(part2[4]);
            
            setShelfDirection(shelf_direction_val == 2 ? 1 : 0);
            setBoardColor(board_color_val);
            setFrameColor(frame_color_val);
            setVerticalColor(vertical_color_val);
            setShelfBoardColor(shelf_board_color_val);
          }
          
          // part3 파싱: shelf_frame_color(1) + giyeok_position(1) + desk_mat_color(1) + drawer_color(1) + fence_color(1)
          if (part3.length >= 5) {
            var shelf_frame_color_val = parseInt(part3[0]);
            var giyeok_position_val = parseInt(part3[1]);
            var desk_mat_color_val = parseInt(part3[2]);
            var drawer_color_val = parseInt(part3[3]);
            var fence_color_val = parseInt(part3[4]);
            
            setShelfFrameColor(shelf_frame_color_val);
            setGiyeok(giyeok_position_val);
            setDeskMat(desk_mat_color_val);
            setDrawerColor(drawer_color_val);
            setFence(fence_color_val);
          }
          
          // part4 파싱: moving2_color(1) + moving3_color(1) + num_desk(1) + is_desk_duplicated(1) + attach1_left(1) + attach1_right(1) + attach2_left(1) + attach2_right(1) + attach3_left(1) + attach3_right(1) + storage_sliding1(1) + storage_sliding2(1) + storage_flap(1) + storage_flapstay(1)
          if (part4.length >= 14) {
            var moving2_color_val = parseInt(part4[0]);
            var moving3_color_val = parseInt(part4[1]);
            var num_desk_val = parseInt(part4[2]);
            var is_desk_duplicated_val = parseInt(part4[3]);
            var attach1_left_val = parseInt(part4[4]);
            var attach1_right_val = parseInt(part4[5]);
            var attach2_left_val = parseInt(part4[6]);
            var attach2_right_val = parseInt(part4[7]);
            var attach3_left_val = parseInt(part4[8]);
            var attach3_right_val = parseInt(part4[9]);
            var storage_sliding1_val = parseInt(part4[10]);
            var storage_sliding2_val = parseInt(part4[11]);
            var storage_flap_val = parseInt(part4[12]);
            var storage_flapstay_val = parseInt(part4[13]);
            
            setMoving2(moving2_color_val);
            setMoving3(moving3_color_val);
            setDeskArray(num_desk_val);
            // 맞은편 배열: 1=복사 안함, 2=거리 3600, 3=거리 -1030, 4=거리 -2400
            if (is_desk_duplicated_val == 1) {
              setDeskOpposite(0);
            } else if (is_desk_duplicated_val == 2) {
              setDeskOpposite(3600);
            } else if (is_desk_duplicated_val == 3) {
              setDeskOpposite(-1030);
            } else if (is_desk_duplicated_val == 4) {
              setDeskOpposite(-2400);
            } else {
              setDeskOpposite(0);
            }
            
            // 부착형 서랍 설정
            if (attach1_left_val > 0) {
              attach1_left_color = attach1_left_val;
              attach1_material = getMaterial(attach1_left_val);
            } else {
              attach1_left_color = 0;
            }
            if (attach1_right_val > 0) {
              attach1_right_color = attach1_right_val;
              attach1_material = getMaterial(attach1_right_val);
            } else {
              attach1_right_color = 0;
            }
            if (attach2_left_val > 0) {
              attach2_left_color = attach2_left_val;
              attach2_material = getMaterial(attach2_left_val);
            } else {
              attach2_left_color = 0;
            }
            if (attach2_right_val > 0) {
              attach2_right_color = attach2_right_val;
              attach2_material = getMaterial(attach2_right_val);
            } else {
              attach2_right_color = 0;
            }
            if (attach3_left_val > 0) {
              attach3_left_color = attach3_left_val;
              attach3_material = getMaterial(attach3_left_val);
            } else {
              attach3_left_color = 0;
            }
            if (attach3_right_val > 0) {
              attach3_right_color = attach3_right_val;
              attach3_material = getMaterial(attach3_right_val);
            } else {
              attach3_right_color = 0;
            }
            
            // 수납 도어 설정
            if (storage_sliding1_val > 0) {
              setStorageSliding1(storage_sliding1_val);
            } else {
              storage_sliding1_color = 0;
            }
            if (storage_sliding2_val > 0) {
              setStorageSliding2(storage_sliding2_val);
            } else {
              storage_sliding2_color = 0;
            }
            if (storage_flap_val > 0) {
              setStorageFlap(storage_flap_val);
            } else {
              storage_flap_color = 0;
            }
            if (storage_flapstay_val > 0) {
              setStorageFlapStay(storage_flapstay_val);
            } else {
              storage_flapstay_color = 0;
            }
          }
          
          // part5 파싱: parti_ver_L_height_idx + parti_ver_L_color + parti_ver_R_height_idx + parti_ver_R_color + parti_ver_M_height_idx + parti_ver_M_color + parti_hol_B_width_idx + parti_hol_B_color + parti_z_align_front
          if (part5.length >= 8) {
            var parti_ver_L_height_idx = parseInt(part5[0]);
            var parti_ver_L_color_val = parseInt(part5[1]);
            var parti_ver_R_height_idx = parseInt(part5[2]);
            var parti_ver_R_color_val = parseInt(part5[3]);
            var parti_ver_M_height_idx = parseInt(part5[4]);
            var parti_ver_M_color_val = parseInt(part5[5]);
            var parti_hol_B_width_idx = parseInt(part5[6]);
            var parti_hol_B_color_val = parseInt(part5[7]);
            var parti_z_align_front_val = part5.length >= 9 ? parseInt(part5[8]) : 0;
            
            // 파티션 높이/넓이 값 설정 (인덱스로 저장됨)
            var height_values_LR = [0, 480, 800, 1200, 1400, 1600, 1800];
            if (parti_ver_L_height_idx >= 0 && parti_ver_L_height_idx < height_values_LR.length) {
              setPartiVerLHeight(height_values_LR[parti_ver_L_height_idx]);
            } else {
              setPartiVerLHeight(0);
            }
            if (parti_ver_L_color_val > 0) {
              setPartiVerLColor(parti_ver_L_color_val);
            }
            
            if (parti_ver_R_height_idx >= 0 && parti_ver_R_height_idx < height_values_LR.length) {
              setPartiVerRHeight(height_values_LR[parti_ver_R_height_idx]);
            } else {
              setPartiVerRHeight(0);
            }
            if (parti_ver_R_color_val > 0) {
              setPartiVerRColor(parti_ver_R_color_val);
            }
            
            var height_values_M = [0, 460, 800, 1200, 1400, 1600, 1800];
            if (parti_ver_M_height_idx >= 0 && parti_ver_M_height_idx < height_values_M.length) {
              setPartiVerMHeight(height_values_M[parti_ver_M_height_idx]);
            } else {
              setPartiVerMHeight(0);
            }
            if (parti_ver_M_color_val > 0) {
              setPartiVerMColor(parti_ver_M_color_val);
            }
            
            var width_values_parti = [0, 1200, 1400, 1600, 1800];
            if (parti_hol_B_width_idx >= 0 && parti_hol_B_width_idx < width_values_parti.length) {
              setPartiHolBWidth(width_values_parti[parti_hol_B_width_idx]);
            } else {
              setPartiHolBWidth(0);
            }
            if (parti_hol_B_color_val > 0) {
              setPartiHolBColor(parti_hol_B_color_val);
            }
            
            // 파티션 Z축 위치 정렬 설정
            if (parti_z_align_front_val == 1) {
              setPartiZAlignFront(1);
            } else {
              setPartiZAlignFront(0);
            }
          }
          
          // part6 파싱: giyeok_drawer_type_left + giyeok_left_color + giyeok_drawer_type_right + giyeok_right_color + shelf_depth
          if (part6 && part6.length >= 5) {
            var giyeok_drawer_type_left_val = parseInt(part6[0]);
            var giyeok_left_color_val = parseInt(part6[1]);
            var giyeok_drawer_type_right_val = parseInt(part6[2]);
            var giyeok_right_color_val = parseInt(part6[3]);
            var shelf_depth_val = parseInt(part6[4]);
            
            // ㄱ자 하부 서랍 설정
            setGiyeokDrawerTypeLeft(giyeok_drawer_type_left_val);
            if (giyeok_left_color_val > 0) {
              setGiyeokDrawerColorLeft(giyeok_left_color_val);
            }
            
            setGiyeokDrawerTypeRight(giyeok_drawer_type_right_val);
            if (giyeok_right_color_val > 0) {
              setGiyeokDrawerColorRight(giyeok_right_color_val);
            }
            
            // shelf_depth 설정
            if (shelf_depth_val == 1) {
              setShelfDepth(200);
            } else if (shelf_depth_val == 2) {
              setShelfDepth(360);
            } else {
              setShelfDepth(200);
            }
          } else if (part5.length >= 9) {
            // 이전 형식 호환: part5에 shelf_depth가 포함된 경우
            var shelf_depth_val = parseInt(part5[8]);
            if (shelf_depth_val == 1) {
              setShelfDepth(200);
            } else if (shelf_depth_val == 2) {
              setShelfDepth(360);
            } else {
              setShelfDepth(200);
            }
          }
          
          // 모든 설정이 완료된 후 씬 업데이트
          updateScene();
          render();
          
          // 코드 입력창 업데이트
          var codeInput = document.getElementById('product_code_input');
          if (codeInput) {
            codeInput.value = generateProductCode();
          }
          
        } catch (error) {
          console.error('코드 파싱 오류:', error);
          alert('상품코드를 읽는 중 오류가 발생했습니다: ' + error.message);
        }
      }

      function calculatePrice() {
        var delivery_price = 0;
        var product_price = 0;
        var ret_price = new Array(2);

        // Extended Price Table Placeholder (36 entries needed for 6x6 grid)
        // NOTE: CSV did not contain prices for new sizes (Width 2360, Depth 800+). 
        // 0 is used as placeholder. Please update with real prices.
        var board_price_table = [
             // Depth 500 (Idx 1)
             109800, 129800, 141700, 159700, 193100, 0,
             // Depth 600 (Idx 2)
             118400, 139900, 159900, 198800, 214500, 0,
             // Depth 700 (Idx 3)
             151000, 169800, 189800, 217300, 241400, 0,
             // Depth 800 (Idx 4) - Placeholder
             0, 0, 0, 0, 0, 0,
             // Depth 1000 (Idx 5) - Placeholder
             0, 0, 0, 0, 0, 0,
             // Depth 1200 (Idx 6) - Placeholder
             0, 0, 0, 0, 0, 0
        ];

        var shelf_product_price_table = [34000, 43000, 45000, 51000, 57000, 0]; // Extended
        var shelf_delivery_price_table = [29800, 29800, 32800, 35800, 38800, 41800, 44800];
        var fence_price_table = [81700, 101700, 103400, 105000, 113900, 0]; // Extended

        // Updated Table Index Logic for 6x6 grid (Width Max 6)
        var table_index = (board_width_idx - 1) + (board_depth_idx - 1) * 6; 
        
        if (board_price_table[table_index] !== undefined) {
             product_price += board_price_table[table_index];
        }
        delivery_price += 29800;

        if (is_mium) {
          product_price += 69900;
          delivery_price += 29800;
        }

        if (vertical_length_idx) {
          if (shelf_product_price_table[board_width_idx - 1]) {
             product_price += shelf_product_price_table[board_width_idx - 1] * shelf_num;
          }
          delivery_price += shelf_delivery_price_table[shelf_num - 1];

          if (vertical_length_idx == 2)
            product_price += 11400;
          else if (vertical_length_idx == 3) // New height cost
            product_price += 16000; // Estimation needed
          else if (vertical_length_idx == 4)
            product_price += 21900;
        }

        if (giyeok_position)
          product_price += 94500;

        if (desk_mat_color) {
          product_price += 65000;
          delivery_price += 5000;
        }

        if (drawer_color) {
          product_price += 34400;
          delivery_price += 3000;
        }

        if (fence_color) {
          if (fence_price_table[board_width_idx - 1])
             product_price += fence_price_table[board_width_idx - 1];
          delivery_price += 19800;
        }

        if (moving2_color) {
          product_price += 88000;
          delivery_price += 19800;
        }

        if (moving3_color) {
          product_price += 121000;
          delivery_price += 19800;
        }

        if (num_desk > 1) {
          product_price *= num_desk;
          delivery_price *= num_desk;
        }

        if (opposite_desk_distance != 0) {
          product_price *= 2;
          delivery_price *= 2;
        }
        
        // return
        ret_price[0] = delivery_price;
        ret_price[1] = product_price;

        return ret_price;
      }

      // 상세 좌표축 생성 함수
      function createDetailedAxes(length, majorTickInterval, minorTickInterval, majorTickSize, minorTickSize) {
        var axesGroup = new THREE.Group();
        
        // 축 색상
        var xColor = 0xff0000; // 빨강
        var yColor = 0x00ff00; // 초록
        var zColor = 0x0000ff; // 파랑
        
        // 텍스트 스프라이트 생성 함수
        function createTextSprite(text, color, position, isSmall) {
          var canvas = document.createElement('canvas');
          var context = canvas.getContext('2d');
          var width = isSmall ? 140 : 160;
          var height = isSmall ? 60 : 80;
          canvas.width = width;
          canvas.height = height;
          
          context.fillStyle = 'rgba(255, 255, 255, 0.9)';
          context.fillRect(0, 0, canvas.width, canvas.height);
          
          context.fillStyle = color === 'red' ? '#ff0000' : color === 'green' ? '#00ff00' : '#0000ff';
          var fontSize = isSmall ? 24 : 28;
          context.font = 'Bold ' + fontSize + 'px Arial';
          context.textAlign = 'center';
          context.textBaseline = 'middle';
          context.fillText(text, canvas.width / 2, canvas.height / 2);
          
          var texture = new THREE.CanvasTexture(canvas);
          texture.needsUpdate = true;
          var spriteMaterial = new THREE.SpriteMaterial({ 
            map: texture,
            transparent: true,
            opacity: 0.9
          });
          var sprite = new THREE.Sprite(spriteMaterial);
          var scale = isSmall ? 250 : 300;
          sprite.scale.set(scale, scale * 0.5, 1);
          sprite.position.copy(position);
          return sprite;
        }
        
        // X축 (빨강) - 양수 방향
        var xAxisPosGeometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(length, 0, 0)
        ]);
        var xAxisPosMaterial = new THREE.LineBasicMaterial({ color: xColor, linewidth: 3 });
        var xAxisPos = new THREE.Line(xAxisPosGeometry, xAxisPosMaterial);
        axesGroup.add(xAxisPos);
        
        // X축 (빨강) - 음수 방향
        var xAxisNegGeometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(-length, 0, 0)
        ]);
        var xAxisNegMaterial = new THREE.LineBasicMaterial({ color: xColor, linewidth: 3, opacity: 0.5 });
        xAxisNegMaterial.transparent = true;
        var xAxisNeg = new THREE.Line(xAxisNegGeometry, xAxisNegMaterial);
        axesGroup.add(xAxisNeg);
        
        // X축 주 눈금선과 레이블
        for (var x = -length; x <= length; x += majorTickInterval) {
          if (x === 0) continue; // 원점은 제외
          
          // 주 눈금선
          var tickGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(x, -majorTickSize, 0),
            new THREE.Vector3(x, majorTickSize, 0)
          ]);
          var tickMaterial = new THREE.LineBasicMaterial({ color: xColor, linewidth: 2 });
          var tick = new THREE.Line(tickGeometry, tickMaterial);
          axesGroup.add(tick);
          
          // 레이블 (X축명 병기)
          var labelText = 'X' + (x > 0 ? '+' : '') + x;
          var label = createTextSprite(labelText, 'red', new THREE.Vector3(x, majorTickSize + 100, 0), true);
          axesGroup.add(label);
        }
        
        // X축 보조 눈금선
        for (var x = -length; x <= length; x += minorTickInterval) {
          if (x === 0 || x % majorTickInterval === 0) continue; // 원점과 주 눈금은 제외
          
          var tickGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(x, -minorTickSize, 0),
            new THREE.Vector3(x, minorTickSize, 0)
          ]);
          var tickMaterial = new THREE.LineBasicMaterial({ color: xColor, opacity: 0.6 });
          tickMaterial.transparent = true;
          var tick = new THREE.Line(tickGeometry, tickMaterial);
          axesGroup.add(tick);
        }
        
        // Y축 (초록) - 양수 방향
        var yAxisPosGeometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(0, length, 0)
        ]);
        var yAxisPosMaterial = new THREE.LineBasicMaterial({ color: yColor, linewidth: 3 });
        var yAxisPos = new THREE.Line(yAxisPosGeometry, yAxisPosMaterial);
        axesGroup.add(yAxisPos);
        
        // Y축 (초록) - 음수 방향
        var yAxisNegGeometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(0, -length, 0)
        ]);
        var yAxisNegMaterial = new THREE.LineBasicMaterial({ color: yColor, linewidth: 3, opacity: 0.5 });
        yAxisNegMaterial.transparent = true;
        var yAxisNeg = new THREE.Line(yAxisNegGeometry, yAxisNegMaterial);
        axesGroup.add(yAxisNeg);
        
        // Y축 주 눈금선과 레이블
        for (var y = -length; y <= length; y += majorTickInterval) {
          if (y === 0) continue; // 원점은 제외
          
          // 주 눈금선
          var tickGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(-majorTickSize, y, 0),
            new THREE.Vector3(majorTickSize, y, 0)
          ]);
          var tickMaterial = new THREE.LineBasicMaterial({ color: yColor, linewidth: 2 });
          var tick = new THREE.Line(tickGeometry, tickMaterial);
          axesGroup.add(tick);
          
          // 레이블 (Y축명 병기)
          var labelText = 'Y' + (y > 0 ? '+' : '') + y;
          var label = createTextSprite(labelText, 'green', new THREE.Vector3(majorTickSize + 100, y, 0), true);
          axesGroup.add(label);
        }
        
        // Y축 보조 눈금선
        for (var y = -length; y <= length; y += minorTickInterval) {
          if (y === 0 || y % majorTickInterval === 0) continue; // 원점과 주 눈금은 제외
          
          var tickGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(-minorTickSize, y, 0),
            new THREE.Vector3(minorTickSize, y, 0)
          ]);
          var tickMaterial = new THREE.LineBasicMaterial({ color: yColor, opacity: 0.6 });
          tickMaterial.transparent = true;
          var tick = new THREE.Line(tickGeometry, tickMaterial);
          axesGroup.add(tick);
        }
        
        // Z축 (파랑) - 양수 방향
        var zAxisPosGeometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(0, 0, length)
        ]);
        var zAxisPosMaterial = new THREE.LineBasicMaterial({ color: zColor, linewidth: 3 });
        var zAxisPos = new THREE.Line(zAxisPosGeometry, zAxisPosMaterial);
        axesGroup.add(zAxisPos);
        
        // Z축 (파랑) - 음수 방향
        var zAxisNegGeometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(0, 0, -length)
        ]);
        var zAxisNegMaterial = new THREE.LineBasicMaterial({ color: zColor, linewidth: 3, opacity: 0.5 });
        zAxisNegMaterial.transparent = true;
        var zAxisNeg = new THREE.Line(zAxisNegGeometry, zAxisNegMaterial);
        axesGroup.add(zAxisNeg);
        
        // Z축 주 눈금선과 레이블
        for (var z = -length; z <= length; z += majorTickInterval) {
          if (z === 0) continue; // 원점은 제외
          
          // 주 눈금선
          var tickGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, -majorTickSize, z),
            new THREE.Vector3(0, majorTickSize, z)
          ]);
          var tickMaterial = new THREE.LineBasicMaterial({ color: zColor, linewidth: 2 });
          var tick = new THREE.Line(tickGeometry, tickMaterial);
          axesGroup.add(tick);
          
          // 레이블 (Z축명 병기)
          var labelText = 'Z' + (z > 0 ? '+' : '') + z;
          var label = createTextSprite(labelText, 'blue', new THREE.Vector3(0, majorTickSize + 100, z), true);
          axesGroup.add(label);
        }
        
        // Z축 보조 눈금선
        for (var z = -length; z <= length; z += minorTickInterval) {
          if (z === 0 || z % majorTickInterval === 0) continue; // 원점과 주 눈금은 제외
          
          var tickGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, -minorTickSize, z),
            new THREE.Vector3(0, minorTickSize, z)
          ]);
          var tickMaterial = new THREE.LineBasicMaterial({ color: zColor, opacity: 0.6 });
          tickMaterial.transparent = true;
          var tick = new THREE.Line(tickGeometry, tickMaterial);
          axesGroup.add(tick);
        }
        
        // 축 레이블 (X, Y, Z) - 작은 크기로
        var xLabel = createTextSprite('X', 'red', new THREE.Vector3(length + 300, 0, 0), true);
        var yLabel = createTextSprite('Y', 'green', new THREE.Vector3(0, length + 300, 0), true);
        var zLabel = createTextSprite('Z', 'blue', new THREE.Vector3(0, 0, length + 300), true);
        axesGroup.add(xLabel);
        axesGroup.add(yLabel);
        axesGroup.add(zLabel);
        
        // 원점 레이블
        var originLabel = createTextSprite('O(0,0,0)', 'black', new THREE.Vector3(0, 100, 0), true);
        axesGroup.add(originLabel);
        
        return axesGroup;
      }

      function updateScene() {
        // world
        scene = new THREE.Scene();

        // X, Y, Z 축 표시 (절대좌표) - 상세 버전
        // 길이: 5000mm, 주 눈금 간격: 500mm, 보조 눈금 간격: 100mm, 주 눈금 크기: 80mm, 보조 눈금 크기: 40mm
        var detailedAxes = createDetailedAxes(5000, 500, 100, 80, 40);
        scene.add(detailedAxes);

        // plane
        geometry = new THREE.PlaneGeometry(plane_size, plane_size);
        plane = new THREE.Mesh(geometry, plane_material);
        plane.rotation.x = 0.5 * Math.PI;
        plane.receiveShadow = true;
        scene.add(plane);

        // desk (empty parent)
        geometry = new THREE.BoxBufferGeometry(0, 0, 0);
        desk = new THREE.Mesh(geometry, board_material);

        // board
        geometry = new THREE.BoxBufferGeometry(board_width, board_thickness, board_depth);
        board = new THREE.Mesh(geometry, board_material);
        board.position.y = frame_length + board_thickness;
        board.castShadow = true;
        desk.add(board);

        // desk mat
        if (desk_mat_color) {
          geometry = new THREE.BoxBufferGeometry(700, board_thickness, 420);
          desk_mat = new THREE.Mesh(geometry, desk_mat_material);
          desk_mat.position.y = 2;
          desk_mat.position.z = (board_depth - 420) / 2 + 2;
          board.add(desk_mat);
        }

        // drawer
        if (drawer_color) {
          geometry = new THREE.BoxBufferGeometry(309, 30, 150);
          drawer_down = new THREE.Mesh(geometry, drawer_material);
          if (drawer_position == 1)
            drawer_down.position.x = -(board_width - 309 - 90) / 2;
          else
            drawer_down.position.x = (board_width - 309 - 90) / 2;
          drawer_down.position.y = -32;
          drawer_down.position.z = (board_depth - 150) / 2 + 2;
          board.add(drawer_down);

          geometry1 = new THREE.BoxBufferGeometry(309, 25, 40);
          drawer_up = new THREE.Mesh(geometry1, drawer_material);
          drawer_up.position.y = 32;
          drawer_up.position.z = 56;
          drawer_down.add(drawer_up);
        }

        // moving2와 moving3는 각 책상마다 생성되므로 여기서는 생성하지 않음 (desk_idx 루프에서 생성)

        // frame (leg)
        geometry = new THREE.BoxBufferGeometry(frame_thickness, frame_length, frame_thickness);
        frame = new THREE.Mesh(geometry, frame_material);
        frame.position.x = - (board_width - frame_thickness) / 2;
        frame.position.y = - (frame_length + board_thickness) / 2 - frame_margin;
        frame.position.z = - (board_depth - frame_thickness) / 2;
        frame.castShadow = true;
        board.add(frame);

        // leg pad
        geometry1 = new THREE.CylinderBufferGeometry(frame_thickness / 1.8, frame_thickness / 1.8, 10);
        leg_pad = new THREE.Mesh(geometry1, leg_pad_meterial);
        leg_pad.position.y = - frame_length / 2 - 8;
        frame.add(leg_pad);

        var frame_dup = frame.clone();
        frame_dup.position.x = (board_width - frame_thickness) / 2;
        frame_dup.position.y = - (frame_length + board_thickness) / 2 - frame_margin;
        frame_dup.position.z = - (board_depth - frame_thickness) / 2;
        frame_dup.castShadow = true;
        board.add(frame_dup);

        frame_dup = frame.clone();
        frame_dup.position.x = - (board_width - frame_thickness) / 2;
        frame_dup.position.y = - (frame_length + board_thickness) / 2 - frame_margin;
        frame_dup.position.z = (board_depth - frame_thickness) / 2;
        frame_dup.castShadow = true;
        board.add(frame_dup);

        frame_dup = frame.clone();
        frame_dup.position.x = (board_width - frame_thickness) / 2;
        frame_dup.position.y = - (frame_length + board_thickness) / 2 - frame_margin;
        frame_dup.position.z = (board_depth - frame_thickness) / 2;
        frame_dup.castShadow = true;
        board.add(frame_dup);

        // frame under board
        geometry = new THREE.BoxBufferGeometry(frame_thickness, frame_thickness, board_depth);
        frame = new THREE.Mesh(geometry, frame_material);
        frame.position.x = (board_width - frame_thickness) / 2;
        frame.position.y = - (board_thickness + frame_thickness) / 2 - frame_margin;
        board.add(frame);

        frame = new THREE.Mesh(geometry, frame_material);
        frame.position.x = - (board_width - frame_thickness) / 2;
        frame.position.y = - (board_thickness + frame_thickness) / 2 - frame_margin;
        board.add(frame);

        // mium leg
        if (is_mium) {
          geometry = new THREE.BoxBufferGeometry(frame_thickness, frame_thickness, board_depth);
          mium_leg = new THREE.Mesh(geometry, frame_material);
          mium_leg.position.x = (board_width - frame_thickness) / 2;
          mium_leg.position.y = - frame_length + (frame_thickness - board_thickness) / 2 - frame_margin;
          mium_leg.castShadow = true;
          board.add(mium_leg);

          mium_leg = new THREE.Mesh(geometry, frame_material);
          mium_leg.position.x = - (board_width - frame_thickness) / 2;
          mium_leg.position.y = - frame_length + (frame_thickness - board_thickness) / 2 - frame_margin;
          mium_leg.castShadow = true;
          board.add(mium_leg);
        }

        // frame under board
        geometry = new THREE.BoxBufferGeometry(board_width - 2, frame_thickness, frame_thickness_under_board);
        frame = new THREE.Mesh(geometry, frame_material);
        frame.position.y = - (board_thickness + frame_thickness) / 2 - frame_margin;
        frame.position.z = board_depth / 4;
        board.add(frame);

        var frame_back = new THREE.Mesh(geometry, frame_material);
        frame_back.position.y = - (board_thickness + frame_thickness) / 2 - frame_margin;
        frame_back.position.z = - board_depth / 4;
        board.add(frame_back);

        // fence
        if (fence_color) {
          geometry = new THREE.BoxBufferGeometry(board_width - 5, 200, 18);
          fence = new THREE.Mesh(geometry, fence_material);
          fence.position.y = -100;
          fence.position.z = - frame_thickness_under_board;
          fence.castShadow = true;
          frame_back.add(fence);

          fence = new THREE.Mesh(geometry, fence_material);
          fence.position.y = -305;
          fence.position.z = - frame_thickness_under_board;
          fence.castShadow = true;
          frame_back.add(fence);
        }

        // vertical
        if (vertical_length > 0) {
          geometry = new THREE.BoxBufferGeometry(frame_thickness, vertical_length, frame_thickness);
          var vertical_y_current = vertical_y + (vertical_y_offset * 93.5); // 오프셋 적용
          vertical = new THREE.Mesh(geometry, vertical_material);
          vertical.position.x = - (board_width - frame_thickness) / 2;
          vertical.position.y = vertical_y_current;
          vertical.position.z = - (board_depth + frame_thickness + 5) / 2;
          vertical.castShadow = true;
          board.add(vertical);

          vertical = new THREE.Mesh(geometry, vertical_material);
          vertical.position.x = + (board_width - frame_thickness) / 2;
          vertical.position.y = vertical_y_current;
          vertical.position.z = - (board_depth + frame_thickness + 5) / 2;
          vertical.castShadow = true;
          board.add(vertical);

          // shelves
          // shelf frame (top)
          geometry = new THREE.BoxBufferGeometry(board_width + 8, frame_thickness, frame_thickness + 2);
          frame = new THREE.Mesh(geometry, shelf_frame_material);
          frame.position.x = - (board_width - frame_thickness) / 2;
          frame.position.y = (vertical_length + frame_thickness) / 2 - board_thickness;
          frame.castShadow = true;
          vertical.add(frame);

          // shelf board (top)
          // 선반깊이 360일 때: 기존 200 선반을 200에서 360으로 늘리고, Z축으로 160 이동
          var shelf_z_offset = 0; // 선반 위치 오프셋
          if (shelf_depth == 360) {
            shelf_z_offset = 160; // Z축으로 160 이동
          }
          
          geometry = new THREE.BoxBufferGeometry(board_width - 52, board_thickness, shelf_depth); // 양쪽 20mm씩 줄임 (총 40mm)
          shelf = new THREE.Mesh(geometry, shelf_board_material);
          shelf.position.y = (frame_thickness + board_thickness) / 2;
          if (shelf_direction)
            shelf.position.z = (shelf_depth - frame_thickness + 2) / 2 + shelf_z_offset;
          else 
            shelf.position.z = - (shelf_depth - frame_thickness + 2) / 2 + shelf_z_offset;
          shelf.castShadow = true;
          frame.add(shelf);    

          // shelf duplicate
          var i;
          for (i = 1; i < shelf_num; i++) {
            var frame_dup = frame.clone();
            frame_dup.position.x = - (board_width - frame_thickness) / 2;
            if (shelf_direction)
              frame_dup.position.y = - (vertical_length / 2 + vertical_y) * (i / (shelf_num - 1)) + vertical_length / 2;
            else
              frame_dup.position.y = vertical_length * (0.5 - i / (shelf_num - 1));
            frame_dup.castShadow = true;
            vertical.add(frame_dup);
          }

          // safety leg
          // 선반깊이 360일 때: safety leg도 같은 오프셋 적용
          // 360 선반일 때도 기존 200 선반일 때와 같은 형상 유지
          var safety_leg_z_offset = 0;
          var safety_leg_depth = shelf_depth; // safety leg의 깊이
          if (shelf_depth == 360) {
            safety_leg_z_offset = 0; // Z축 원점으로 이동
            safety_leg_depth = 200; // 360 선반일 때도 200 선반과 같은 형상 유지
          }
          
          geometry = new THREE.BoxBufferGeometry(frame_thickness, frame_thickness, safety_leg_depth);
          frame = new THREE.Mesh(geometry, frame_material);
          frame.position.x = - (board_width - frame_thickness) / 2;
          frame.position.y = - frame_length + (frame_thickness - board_thickness) / 2;
          if (shelf_direction)
            frame.position.z = - (board_depth - safety_leg_depth) / 2 + safety_leg_z_offset;
          else
            frame.position.z = - (board_depth + safety_leg_depth) / 2 + safety_leg_z_offset;
          frame.castShadow = true;
          board.add(frame);

          // safety leg pad
          // 선반 360일 때도 선반 200 바깥방향일 때와 똑같은 형태 유지
          leg_pad = new THREE.Mesh(geometry1, leg_pad_meterial);
          leg_pad.position.y = - frame_thickness / 2 - 8;
          if (shelf_depth == 360) {
            // 선반 360일 때: 선반 200 바깥방향일 때와 동일한 위치 (Z축 원점)
            leg_pad.position.z = - (200 - frame_thickness) / 2;
          } else {
            // 선반 200일 때: 기존 로직 유지
          if (shelf_direction)
              leg_pad.position.z = (safety_leg_depth - frame_thickness) / 2 + safety_leg_z_offset;
          else
              leg_pad.position.z = - (safety_leg_depth - frame_thickness) / 2 + safety_leg_z_offset;
          }
          frame.add(leg_pad);

          // safety leg duplicate
          frame_dup = frame.clone();
          frame_dup.position.x = + (board_width - frame_thickness) / 2;
          frame_dup.position.y = - frame_length + (frame_thickness - board_thickness) / 2;
          if (shelf_direction)
            frame_dup.position.z = - (board_depth - safety_leg_depth) / 2 + safety_leg_z_offset;
          else
            frame_dup.position.z = - (board_depth + safety_leg_depth) / 2 + safety_leg_z_offset;
          frame_dup.castShadow = true;
          board.add(frame_dup);
        }

        // Gieok module
        if (giyeok_position) {
          // 양쪽(4)인 경우 좌우 각각 생성
          var giyeok_positions = [];
          if (giyeok_position == 4) {
            giyeok_positions = [1, 2]; // 왼쪽, 오른쪽
          } else {
            giyeok_positions = [giyeok_position];
          }
          
          for (var g_idx = 0; g_idx < giyeok_positions.length; g_idx++) {
            var g_pos = giyeok_positions[g_idx];
          geometry = new THREE.BoxBufferGeometry(600, board_thickness, 800);
          giyeok_board = new THREE.Mesh(geometry, board_material);
            if (g_pos == 1)
            giyeok_board.position.x = - (board_width - 600) / 2;
            else if (g_pos == 2)
            giyeok_board.position.x = (board_width - 600) / 2;
            else if (g_pos == 3)
              giyeok_board.position.x = 0; // 중앙
          giyeok_board.position.z = (board_depth + 800) / 2;
          giyeok_board.castShadow = true;
            giyeok_board.userData = { isGiyeokBoard: true, giyeokSide: g_pos }; // 반대편에서 찾을 수 있도록 표시
          board.add(giyeok_board);

          // frame (leg)
          geometry = new THREE.BoxBufferGeometry(frame_thickness, frame_length, frame_thickness);
          frame = new THREE.Mesh(geometry, frame_material);
          frame.position.x = - (600 - frame_thickness) / 2;
          frame.position.y = - (frame_length + board_thickness) / 2 - frame_margin;
          frame.position.z = (800 - frame_thickness) / 2;
          frame.castShadow = true;
          giyeok_board.add(frame);

          // leg pad
          leg_pad = new THREE.Mesh(geometry1, leg_pad_meterial);
          leg_pad.position.y = - frame_length / 2 - 8;
          frame.add(leg_pad);

          frame_dup = frame.clone();
          frame_dup.position.x = (600 - frame_thickness) / 2;
          frame_dup.position.y = - (frame_length + board_thickness) / 2 - frame_margin;
          frame_dup.position.z = (800 - frame_thickness) / 2;
          frame_dup.castShadow = true;
          giyeok_board.add(frame_dup);

          // frame under board
          geometry = new THREE.BoxBufferGeometry(600, frame_thickness, frame_thickness);
          frame = new THREE.Mesh(geometry, frame_material);           
          frame.position.y = - (board_thickness + frame_thickness) / 2 - frame_margin;
          frame.position.z = (800 - frame_thickness) / 2;
          giyeok_board.add(frame);

          geometry = new THREE.BoxBufferGeometry(frame_thickness_under_board, frame_thickness, 800 + board_depth / 4);
          frame = new THREE.Mesh(geometry, frame_material);
          frame.position.y = - (board_thickness + frame_thickness) / 2 - frame_margin;
          frame.position.z = - board_depth / 8;
          giyeok_board.add(frame);

            // ㄱ자 하부 서랍은 desk_idx 루프 안에서 각 책상마다 생성됨 (아래 참조)
          }
        }

        // desk array
        for (var i = 1; i < num_desk; i++) {
          var board_dup = board.clone();
          board_dup.position.set((board_width + 10) * i, frame_length + board_thickness, 0);
          desk.add(board_dup);
          // ㄱ자 하부 서랍은 desk_idx 루프에서 생성됨 (아래 참조)
        }

        // desk array in opposite side
        if (opposite_desk_distance != 0) {
          // 기존 선반 끝 위치 계산
          var original_shelf_end_z = board_depth + 10;
          if (vertical_length > 0) {
            if (shelf_direction) { // in
              original_shelf_end_z += frame_thickness * 2;
            } else { // out
              // 선반 360일 때도 200 선반 바깥방향일 때와 같은 거리 유지
              if (shelf_depth == 360) {
                original_shelf_end_z += 200 * 2; // 200 선반 바깥방향일 때와 동일한 거리
              } else {
                original_shelf_end_z += shelf_depth * 2;
              }
            }
          }
          
          // 반대편 선반 끝 위치 계산 (반대편 책상의 앞쪽 끝에서 선반 깊이만큼)
          var opposite_shelf_end_z;
          if (vertical_length > 0) {
            if (shelf_direction) { // in
              opposite_shelf_end_z = -frame_thickness * 2; // 반대편 책상 앞쪽에서 선반 깊이만큼
            } else { // out
              if (shelf_depth == 360) {
                opposite_shelf_end_z = -200 * 2; // 반대편 책상 앞쪽에서 선반 깊이만큼
              } else {
                opposite_shelf_end_z = -shelf_depth * 2; // 반대편 책상 앞쪽에서 선반 깊이만큼
              }
            }
          } else {
            opposite_shelf_end_z = 0; // 선반이 없으면 반대편 책상 앞쪽 끝
          }
          
          // 반대편 책상의 Z 위치: 선택한 거리만큼 이동
          // 거리 값이 양수면 원래 책상의 Z 위치에서 +거리, 음수면 -거리
          // 원래 책상의 Z 위치는 0이므로, 거리 값 그대로 사용
          // 책상 깊이에 따른 추가 Z축 오프셋 적용
          var depth_z_offset = 0;
          if (board_depth == 700) {
            depth_z_offset = -100;
          } else if (board_depth == 800) {
            depth_z_offset = -200;
          } else if (board_depth == 1000) {
            depth_z_offset = -400;
          } else if (board_depth == 1200) {
            depth_z_offset = -600;
          }
          var opposite_desk_z_position = opposite_desk_distance + depth_z_offset;
          
          for (var i = 0; i < num_desk; i++) {
            var board_dup = board.clone();
            
            // 반대편 책상의 X 위치: 원래 책상과 동일한 상대 위치 사용
            // 첫 번째 책상은 0, 두 번째부터는 (board_width + 10) * i
            var opposite_board_x;
            if (i == 0) {
              opposite_board_x = 0; // 첫 번째 책상은 원점
            } else {
              opposite_board_x = (board_width + 10) * i; // 나머지는 원래와 동일한 상대 위치
            }
            
            // 거울 반사: Y축 기준으로 반전 (scale.z = -1)
            // Y축 기준 미러링은 Z축을 반전시키는 것
            board_dup.scale.z = -1;
            
            // 반대편 책상 위치: 기존 선반 끝과 새 선반 끝이 만나는 위치에서 -20 이동
            board_dup.position.set(opposite_board_x, frame_length + board_thickness, opposite_desk_z_position);
            
            desk.add(board_dup);    
            
            // 반대편 책상의 offset 계산 (desk_idx와 동일한 인덱스 사용)
            var opposite_desk_offset_x = (board_width + 10) * (i - 0.5 * (num_desk - 1));
            // 반대편 책상 Z 위치: 계산된 위치 사용
            var opposite_desk_z = opposite_desk_z_position;
            
            // Y축 기준 미러링: board_dup에 scale.z = -1이 적용되어 있으므로
            // ㄱ자 모듈과 하부 서랍은 board_dup의 자식이므로 자동으로 앞뒤 반전됨
            // 별도로 추가하는 부착형 서랍도 Y축 기준 미러링에 맞게 조정 필요
            
            // 반대편 부착형 서랍은 하부옵션 그룹에 포함됨 (아래 참조)
            
            // 반대편 수납 슬라이딩도어 1단
            if (storage_sliding1_color && vertical_length > 0) {
              var storage_sliding1_width = board_width - 80;
              var storage_sliding1_depth = 360;
              var storage_sliding1_height = 400;
              var vertical_y_current = vertical_y + (vertical_y_offset * 93.5);
              var vertical_bottom_y = vertical_y_current - vertical_length / 2;
              var storage_height_position = 0;
              if (vertical_length_idx == 3) {
                storage_height_position = 1200;
              } else if (vertical_length_idx == 4) {
                storage_height_position = 1400;
              }
              var storage_center_y = vertical_bottom_y + storage_height_position + storage_sliding1_height / 2 + (storage_y_offset * 93.5);
              // 선반 깊이 200이고 방향이 바깥쪽일 때도 선반 360과 동일한 위치
              var shelf_z_offset = 0;
              if (shelf_depth == 360 || (shelf_depth == 200 && shelf_direction == 0)) {
                shelf_z_offset = 160;
              }
              var shelf_z_relative = shelf_direction == 0 ? - (shelf_depth - frame_thickness + 2) / 2 : (shelf_depth - frame_thickness + 2) / 2;
              var vertical_z = - (board_depth + frame_thickness + 5) / 2;
              var shelf_z_absolute = vertical_z + shelf_z_relative + shelf_z_offset;
              geometry = new THREE.BoxBufferGeometry(storage_sliding1_width, storage_sliding1_height, storage_sliding1_depth);
              var storage_sliding1_opposite = new THREE.Mesh(geometry, storage_sliding1_material);
              // 반대편 앞뒤 반전: 수직부재는 반대편 책상의 앞쪽에 위치하므로 Z 좌표 반전
              storage_sliding1_opposite.position.set(opposite_desk_offset_x, storage_center_y, opposite_desk_z - shelf_z_absolute);
              storage_sliding1_opposite.castShadow = true;
              scene.add(storage_sliding1_opposite);
            }
            
            // 반대편 수납 슬라이딩도어 2단
            if (storage_sliding2_color && vertical_length > 0) {
              var storage_sliding2_width = board_width - 80;
              var storage_sliding2_depth = 360;
              var storage_sliding2_height = 800;
              var vertical_y_current = vertical_y + (vertical_y_offset * 93.5);
              var vertical_bottom_y = vertical_y_current - vertical_length / 2;
              var storage_height_position = 0;
              if (vertical_length_idx == 3) {
                storage_height_position = 1200;
              } else if (vertical_length_idx == 4) {
                storage_height_position = 1400;
              }
              var storage_center_y = vertical_bottom_y + storage_height_position + storage_sliding2_height / 2 + (storage_y_offset * 93.5);
              // 선반 깊이 200이고 방향이 바깥쪽일 때도 선반 360과 동일한 위치
              var shelf_z_offset = 0;
              if (shelf_depth == 360 || (shelf_depth == 200 && shelf_direction == 0)) {
                shelf_z_offset = 160;
              }
              var shelf_z_relative = shelf_direction == 0 ? - (shelf_depth - frame_thickness + 2) / 2 : (shelf_depth - frame_thickness + 2) / 2;
              var vertical_z = - (board_depth + frame_thickness + 5) / 2;
              var shelf_z_absolute = vertical_z + shelf_z_relative + shelf_z_offset;
              geometry = new THREE.BoxBufferGeometry(storage_sliding2_width, storage_sliding2_height, storage_sliding2_depth);
              var storage_sliding2_opposite = new THREE.Mesh(geometry, storage_sliding2_material);
              // 반대편 앞뒤 반전: 수직부재는 반대편 책상의 앞쪽에 위치하므로 Z 좌표 반전
              storage_sliding2_opposite.position.set(opposite_desk_offset_x, storage_center_y, opposite_desk_z - shelf_z_absolute);
              storage_sliding2_opposite.castShadow = true;
              scene.add(storage_sliding2_opposite);
            }
            
            // 반대편 수납 플랩도어
            if (storage_flap_color && vertical_length > 0) {
              var storage_flap_width = board_width - 80;
              var storage_flap_depth = 360;
              var storage_flap_height = 400;
              var vertical_y_current = vertical_y + (vertical_y_offset * 93.5);
              var vertical_bottom_y = vertical_y_current - vertical_length / 2;
              var storage_height_position = 0;
              var model_height = 1400; // 기본 모델 높이
              if (vertical_length_idx == 3) {
                storage_height_position = 1200;
                model_height = 1400;
              } else if (vertical_length_idx == 4) {
                storage_height_position = 1400;
                model_height = 1800; // 1860에 가장 가까운 모델
              }
              var storage_center_y = vertical_bottom_y + storage_height_position + storage_flap_height / 2 + (storage_y_offset * 93.5);
              // 선반 깊이 200이고 방향이 바깥쪽일 때도 선반 360과 동일한 위치
              var shelf_z_offset = 0;
              if (shelf_depth == 360 || (shelf_depth == 200 && shelf_direction == 0)) {
                shelf_z_offset = 160;
              }
              var shelf_z_relative = shelf_direction == 0 ? - (shelf_depth - frame_thickness + 2) / 2 : (shelf_depth - frame_thickness + 2) / 2;
              var vertical_z = - (board_depth + frame_thickness + 5) / 2;
              var shelf_z_absolute = vertical_z + shelf_z_relative + shelf_z_offset;
              
              if (storage_flap_models[model_height]) {
                var storage_flap_opposite = storage_flap_models[model_height].clone();
                storage_flap_opposite.traverse(function(child) {
                  if (child instanceof THREE.Mesh) {
                    child.material = storage_flap_material;
                    child.castShadow = true;
                    child.receiveShadow = true;
                  }
                });
                // 반대편 앞뒤 반전: 수직부재는 반대편 책상의 앞쪽에 위치하므로 Z 좌표 반전
                storage_flap_opposite.position.set(opposite_desk_offset_x, storage_center_y, opposite_desk_z - shelf_z_absolute);
                scene.add(storage_flap_opposite);
              } else {
                geometry = new THREE.BoxBufferGeometry(storage_flap_width, storage_flap_height, storage_flap_depth);
                var storage_flap_opposite = new THREE.Mesh(geometry, storage_flap_material);
                // 반대편 앞뒤 반전: 수직부재는 반대편 책상의 앞쪽에 위치하므로 Z 좌표 반전
                storage_flap_opposite.position.set(opposite_desk_offset_x, storage_center_y, opposite_desk_z - shelf_z_absolute);
                storage_flap_opposite.castShadow = true;
                scene.add(storage_flap_opposite);
              }
            }
            
            // 반대편 수납 플랩스테이도어
            if (storage_flapstay_color && vertical_length > 0) {
              var storage_flapstay_width = board_width - 80;
              var storage_flapstay_depth = 360;
              var storage_flapstay_height = 400;
              var vertical_y_current = vertical_y + (vertical_y_offset * 93.5);
              var vertical_bottom_y = vertical_y_current - vertical_length / 2;
              var storage_height_position = 0;
              if (vertical_length_idx == 3) {
                storage_height_position = 1200;
              } else if (vertical_length_idx == 4) {
                storage_height_position = 1400;
              }
              var storage_center_y = vertical_bottom_y + storage_height_position + storage_flapstay_height / 2 + (storage_y_offset * 93.5);
              // 선반 깊이 200이고 방향이 바깥쪽일 때도 선반 360과 동일한 위치
              var shelf_z_offset = 0;
              if (shelf_depth == 360 || (shelf_depth == 200 && shelf_direction == 0)) {
                shelf_z_offset = 160;
              }
              var shelf_z_relative = shelf_direction == 0 ? - (shelf_depth - frame_thickness + 2) / 2 : (shelf_depth - frame_thickness + 2) / 2;
              var vertical_z = - (board_depth + frame_thickness + 5) / 2;
              var shelf_z_absolute = vertical_z + shelf_z_relative + shelf_z_offset;
              
              // 모델 높이 결정
              var model_height = 1400; // 기본 모델 높이
              if (vertical_length_idx == 3) {
                model_height = 1400;
              } else if (vertical_length_idx == 4) {
                model_height = 2060; // 1860에 가장 가까운 모델
              }
              
              if (storage_flapstay_models[model_height]) {
                var storage_flapstay_opposite = storage_flapstay_models[model_height].clone();
                storage_flapstay_opposite.traverse(function(child) {
                  if (child instanceof THREE.Mesh) {
                    child.material = storage_flapstay_material;
                    child.castShadow = true;
                    child.receiveShadow = true;
                  }
                });
                // 반대편 앞뒤 반전: 수직부재는 반대편 책상의 앞쪽에 위치하므로 Z 좌표 반전
                storage_flapstay_opposite.position.set(opposite_desk_offset_x, storage_center_y, opposite_desk_z - shelf_z_absolute);
                scene.add(storage_flapstay_opposite);
              } else {
                // GLB 모델이 로드되지 않은 경우 기본 박스 사용
                geometry = new THREE.BoxBufferGeometry(storage_flapstay_width, storage_flapstay_height, storage_flapstay_depth);
                var storage_flapstay_opposite = new THREE.Mesh(geometry, storage_flapstay_material);
                // 반대편 앞뒤 반전: 수직부재는 반대편 책상의 앞쪽에 위치하므로 Z 좌표 반전
                storage_flapstay_opposite.position.set(opposite_desk_offset_x, storage_center_y, opposite_desk_z - shelf_z_absolute);
                storage_flapstay_opposite.castShadow = true;
                scene.add(storage_flapstay_opposite);
              }
            }
            
            // 반대편 하부옵션 복사 - 모든 하부옵션을 하나의 그룹으로 묶어서 미러링
            // 책상처럼 scale.z = -1로 미러링하여 일관되게 처리
            var oppositeBottomOptionsGroup = new THREE.Group();
            
            // [30] 하부옵션 - 2단 이동 서랍
            // 책상처럼 미러링: 좌우는 그대로 유지, scale.z = -1로 앞뒤만 반전
            if (moving2_color) {
              geometry = new THREE.BoxBufferGeometry(300, 585, 400);
              var moving2_opposite = new THREE.Mesh(geometry, moving2_material);
              moving2_opposite.position.y = 585 / 2 + 50;
              
              // 원본과 동일한 X 위치 (좌우 반전 없음)
              var moving2_x;
              if (moving2_position == 1) {
                moving2_x = - (board_width - 400) / 2; // 좌측
              } else {
                moving2_x = (board_width - 400) / 2; // 우측
              }
              moving2_opposite.position.x = moving2_x;
              moving2_opposite.position.z = (board_depth - 450) / 2;
              moving2_opposite.castShadow = true;
              oppositeBottomOptionsGroup.add(moving2_opposite);
              
              // drawer 1 and 2
              geometry = new THREE.BoxBufferGeometry(300, 275, 20);
              var drawer1_opposite = new THREE.Mesh(geometry, moving2_material);
              drawer1_opposite.position.y = (585 - 275) / 2;
              drawer1_opposite.position.z = 220;
              moving2_opposite.add(drawer1_opposite);
              
              var drawer2_opposite = new THREE.Mesh(geometry, moving2_material);
              drawer2_opposite.position.y = -(585 - 275) / 2;
              drawer2_opposite.position.z = 220;
              moving2_opposite.add(drawer2_opposite);
              
              // wheel
              geometry = new THREE.CylinderBufferGeometry(25, 25, 30);
              var wheel_opposite = new THREE.Mesh(geometry, leg_pad_meterial);
              wheel_opposite.position.set(-130, -320, 180);
              wheel_opposite.rotation.x = Math.PI / 2;
              moving2_opposite.add(wheel_opposite);
              
              wheel_opposite = new THREE.Mesh(geometry, leg_pad_meterial);
              wheel_opposite.position.set(130, -320, 180);
              wheel_opposite.rotation.x = Math.PI / 2;
              moving2_opposite.add(wheel_opposite);
              
              wheel_opposite = new THREE.Mesh(geometry, leg_pad_meterial);
              wheel_opposite.position.set(-130, -320, -180);
              wheel_opposite.rotation.x = Math.PI / 2;
              moving2_opposite.add(wheel_opposite);
              
              wheel_opposite = new THREE.Mesh(geometry, leg_pad_meterial);
              wheel_opposite.position.set(130, -320, -180);
              wheel_opposite.rotation.x = Math.PI / 2;
              moving2_opposite.add(wheel_opposite);
            }
            
            // [31] 하부옵션 - 3단 이동 서랍
            // 책상처럼 미러링: 좌우는 그대로 유지, scale.z = -1로 앞뒤만 반전
            if (moving3_color) {
              geometry = new THREE.BoxBufferGeometry(400, 585, 580);
              var moving3_opposite = new THREE.Mesh(geometry, moving3_material);
              moving3_opposite.position.y = 585 / 2 + 50;
              
              // 원본과 동일한 X 위치 (좌우 반전 없음)
              var moving3_x;
              if (moving3_position == 1) {
                moving3_x = - (board_width - 500) / 2; // 좌측
              } else {
                moving3_x = (board_width - 500) / 2; // 우측
              }
              moving3_opposite.position.x = moving3_x;
              moving3_opposite.position.z = (board_depth - 640) / 2;
              moving3_opposite.castShadow = true;
              oppositeBottomOptionsGroup.add(moving3_opposite);
              
              // drawer 1, 2, 3
              geometry = new THREE.BoxBufferGeometry(400, 190, 20);
              var drawer1_opposite = new THREE.Mesh(geometry, moving3_material);
              drawer1_opposite.position.y = (585 - 190) / 2;
              drawer1_opposite.position.z = 310;
              moving3_opposite.add(drawer1_opposite);
              
              var drawer2_opposite = new THREE.Mesh(geometry, moving3_material);
              drawer2_opposite.position.y = 0;
              drawer2_opposite.position.z = 310;
              moving3_opposite.add(drawer2_opposite);
              
              var drawer3_opposite = new THREE.Mesh(geometry, moving3_material);
              drawer3_opposite.position.y = - (585 - 190) / 2;
              drawer3_opposite.position.z = 310;
              moving3_opposite.add(drawer3_opposite);
              
              // wheel
              geometry = new THREE.CylinderBufferGeometry(25, 25, 30);
              var wheel_opposite = new THREE.Mesh(geometry, leg_pad_meterial);
              wheel_opposite.position.set(-180, -320, 280);
              wheel_opposite.rotation.x = Math.PI / 2;
              moving3_opposite.add(wheel_opposite);
              
              wheel_opposite = new THREE.Mesh(geometry, leg_pad_meterial);
              wheel_opposite.position.set(180, -320, 280);
              wheel_opposite.rotation.x = Math.PI / 2;
              moving3_opposite.add(wheel_opposite);
              
              wheel_opposite = new THREE.Mesh(geometry, leg_pad_meterial);
              wheel_opposite.position.set(-180, -320, -280);
              wheel_opposite.rotation.x = Math.PI / 2;
              moving3_opposite.add(wheel_opposite);
              
              wheel_opposite = new THREE.Mesh(geometry, leg_pad_meterial);
              wheel_opposite.position.set(180, -320, -280);
              wheel_opposite.rotation.x = Math.PI / 2;
              moving3_opposite.add(wheel_opposite);
            }
            
            // 부착형 서랍들도 그룹에 추가 (상대 위치로)
            if (attach1_left_color) {
              var attach_top_y = frame_length + board_thickness - 60;
              var left_leg_inner_x = - (board_width - frame_thickness) / 2 + frame_thickness / 2 + 155;
              var attach1_opposite = createOppositeAttachDrawerForGroup(1, attach1_left_color, left_leg_inner_x, attach_top_y, board_depth / 2 - 200);
              if (attach1_opposite) oppositeBottomOptionsGroup.add(attach1_opposite);
            }
            if (attach1_right_color) {
              var attach_top_y = frame_length + board_thickness - 60;
              var right_leg_inner_x = (board_width - frame_thickness) / 2 - frame_thickness / 2 - 155;
              var attach1_opposite = createOppositeAttachDrawerForGroup(1, attach1_right_color, right_leg_inner_x, attach_top_y, board_depth / 2 - 200);
              if (attach1_opposite) oppositeBottomOptionsGroup.add(attach1_opposite);
            }
            if (attach2_left_color) {
              var attach_top_y = frame_length + board_thickness - 60;
              var left_leg_inner_x = - (board_width - frame_thickness) / 2 + frame_thickness / 2 + 155;
              var attach2_opposite = createOppositeAttachDrawerForGroup(2, attach2_left_color, left_leg_inner_x, attach_top_y, board_depth / 2 - 200);
              if (attach2_opposite) oppositeBottomOptionsGroup.add(attach2_opposite);
            }
            if (attach2_right_color) {
              var attach_top_y = frame_length + board_thickness - 60;
              var right_leg_inner_x = (board_width - frame_thickness) / 2 - frame_thickness / 2 - 155;
              var attach2_opposite = createOppositeAttachDrawerForGroup(2, attach2_right_color, right_leg_inner_x, attach_top_y, board_depth / 2 - 200);
              if (attach2_opposite) oppositeBottomOptionsGroup.add(attach2_opposite);
            }
            if (attach3_left_color) {
              var attach_top_y = frame_length + board_thickness - 60;
              var left_leg_inner_x = - (board_width - frame_thickness) / 2 + frame_thickness / 2 + 155;
              var attach3_opposite = createOppositeAttachDrawerForGroup(3, attach3_left_color, left_leg_inner_x, attach_top_y, board_depth / 2 - 200);
              if (attach3_opposite) oppositeBottomOptionsGroup.add(attach3_opposite);
            }
            if (attach3_right_color) {
              var attach_top_y = frame_length + board_thickness - 60;
              var right_leg_inner_x = (board_width - frame_thickness) / 2 - frame_thickness / 2 - 155;
              var attach3_opposite = createOppositeAttachDrawerForGroup(3, attach3_right_color, right_leg_inner_x, attach_top_y, board_depth / 2 - 200);
              if (attach3_opposite) oppositeBottomOptionsGroup.add(attach3_opposite);
            }
            
            // 그룹에 미러링 적용 (책상처럼 scale.z = -1)
            oppositeBottomOptionsGroup.scale.z = -1;
            // 그룹 위치 설정 (반대편 책상 위치 기준)
            oppositeBottomOptionsGroup.position.set(opposite_desk_offset_x, 0, opposite_desk_z);
            scene.add(oppositeBottomOptionsGroup);
            
            // 반대편 파티션 옵션 복사
            // 파티션 ver_L: 반대편 첫 번째 책상의 왼쪽 파티션
            if (parti_ver_L_height > 0 && i == 0) {
              var board_top_y = frame_length + board_thickness;
              var parti_bottom_y;
              var parti_center_y;
              var parti_width = 800;
              
              switch (parti_ver_L_height) {
                case 460:
                  parti_bottom_y = board_top_y;
                  parti_center_y = parti_bottom_y + parti_ver_L_height / 2 + 15;
                  break;
                case 800:
                  parti_bottom_y = board_top_y - 300;
                  parti_center_y = parti_bottom_y + parti_ver_L_height / 2;
                  break;
                case 1200:
                case 1400:
                case 1600:
                case 1800:
                  parti_bottom_y = board_top_y - 700;
                  parti_center_y = parti_bottom_y + parti_ver_L_height / 2;
                  break;
                default:
                  parti_bottom_y = board_top_y;
                  parti_center_y = parti_bottom_y + parti_ver_L_height / 2;
              }
              
              var parti_x_position;
              if (vertical_length > 0 && shelf_num > 0) {
                var vertical_z = - (board_depth + frame_thickness + 5) / 2;
                var shelf_z_relative;
                if (shelf_direction == 0) {
                  shelf_z_relative = - (shelf_depth - frame_thickness + 2) / 2;
                } else {
                  shelf_z_relative = (shelf_depth - frame_thickness + 2) / 2;
                }
                var shelf_z_absolute = vertical_z + shelf_z_relative;
                parti_x_position = - board_width / 2 - 6;
              } else {
                parti_x_position = - board_width / 2;
              }
              
              geometry = new THREE.BoxBufferGeometry(12, parti_ver_L_height, parti_width);
              var parti_ver_L_opposite = new THREE.Mesh(geometry, parti_ver_L_material);
              // 반대편 위치: 그룹 내 상대 위치로 설정 (미러링 적용됨)
              // 파티션 Z 위치: 책상 깊이 1000 이상이고 하부옵션 전면 정렬 선택 시
              var parti_z_pos = 0;
              if (board_depth >= 1000 && parti_z_align_front == 1) {
                parti_z_pos = board_depth / 2 - 200; // 하부옵션 전면과 같은 라인 (그룹 중심 기준)
              }
              parti_ver_L_opposite.position.set(parti_x_position, parti_center_y, parti_z_pos);
              parti_ver_L_opposite.castShadow = true;
              oppositeBottomOptionsGroup.add(parti_ver_L_opposite);
            }
            
            // 파티션 ver_R: 반대편 마지막 책상의 오른쪽 파티션
            if (i == num_desk - 1 && parti_ver_R_height > 0) {
              var board_top_y = frame_length + board_thickness;
              var parti_bottom_y;
              var parti_center_y;
              var parti_width = 800;
              
              switch (parti_ver_R_height) {
                case 460:
                  parti_bottom_y = board_top_y;
                  parti_center_y = parti_bottom_y + parti_ver_R_height / 2 + 15;
                  break;
                case 800:
                  parti_bottom_y = board_top_y - 300;
                  parti_center_y = parti_bottom_y + parti_ver_R_height / 2;
                  break;
                case 1200:
                case 1400:
                case 1600:
                case 1800:
                  parti_bottom_y = board_top_y - 700;
                  parti_center_y = parti_bottom_y + parti_ver_R_height / 2;
                  break;
                default:
                  parti_bottom_y = board_top_y;
                  parti_center_y = parti_bottom_y + parti_ver_R_height / 2;
              }
              
              var parti_x_position;
              if (vertical_length > 0 && shelf_num > 0) {
                var vertical_z = - (board_depth + frame_thickness + 5) / 2;
                var shelf_z_relative;
                if (shelf_direction == 0) {
                  shelf_z_relative = - (shelf_depth - frame_thickness + 2) / 2;
                } else {
                  shelf_z_relative = (shelf_depth - frame_thickness + 2) / 2;
                }
                var shelf_z_absolute = vertical_z + shelf_z_relative;
                parti_x_position = board_width / 2 + 6;
              } else {
                parti_x_position = board_width / 2;
              }
              
              geometry = new THREE.BoxBufferGeometry(12, parti_ver_R_height, parti_width);
              var parti_ver_R_opposite = new THREE.Mesh(geometry, parti_ver_R_material);
              // 반대편 위치: 그룹 내 상대 위치로 설정 (미러링 적용됨)
              // 파티션 Z 위치: 책상 깊이 1000 이상이고 하부옵션 전면 정렬 선택 시
              var parti_z_pos = 0;
              if (board_depth >= 1000 && parti_z_align_front == 1) {
                parti_z_pos = board_depth / 2 - 200; // 하부옵션 전면과 같은 라인 (그룹 중심 기준)
              }
              parti_ver_R_opposite.position.set(parti_x_position, parti_center_y, parti_z_pos);
              parti_ver_R_opposite.castShadow = true;
              oppositeBottomOptionsGroup.add(parti_ver_R_opposite);
            }
            
            // 파티션 ver_M: 반대편 중첩 위치 파티션 (책상과 책상 사이)
            // 각 책상 사이에 중첩위치 파티션 생성
            if (parti_ver_M_height > 0 && num_desk > 1 && i < num_desk - 1) {
              var board_top_y = frame_length + board_thickness;
              var parti_bottom_y;
              var parti_center_y;
              var parti_width = 800;
              
              switch (parti_ver_M_height) {
                case 460:
                  parti_bottom_y = board_top_y;
                  parti_center_y = parti_bottom_y + parti_ver_M_height / 2 + 15;
                  break;
                case 800:
                  parti_bottom_y = board_top_y - 300;
                  parti_center_y = parti_bottom_y + parti_ver_M_height / 2;
                  break;
                case 1200:
                case 1400:
                case 1600:
                case 1800:
                  parti_bottom_y = board_top_y - 700;
                  parti_center_y = parti_bottom_y + parti_ver_M_height / 2;
                  break;
                default:
                  parti_bottom_y = board_top_y;
                  parti_center_y = parti_bottom_y + parti_ver_M_height / 2;
              }
              
              // 중첩 위치: 현재 책상(i)과 다음 책상(i+1) 사이
              // 그룹 내 상대 위치로 계산 (그룹 중심이 현재 책상 중심이므로)
              // 현재 책상의 그룹 내 상대 X 위치: 0 (그룹 중심이 현재 책상 중심)
              // 다음 책상의 그룹 내 상대 X 위치: (board_width + 10) (다음 책상까지의 거리)
              // 현재 책상의 오른쪽 끝: 0 + board_width / 2 = board_width / 2
              // 다음 책상의 왼쪽 끝: (board_width + 10) - board_width / 2 = board_width / 2 + 10
              // 중첩 위치는 이 두 위치의 중간: (board_width / 2 + board_width / 2 + 10) / 2 = board_width / 2 + 5
              var overlap_x = board_width / 2 + 5;
              
              // 파티션 X 위치 계산: 선반이 있을 경우 선반의 제일 바깥쪽으로
              var parti_x_position;
              if (vertical_length > 0 && shelf_num > 0) {
                parti_x_position = overlap_x + 6; // 중첩 위치에서 파티션 두께의 절반만큼 오른쪽
              } else {
                parti_x_position = overlap_x; // 중첩 위치에 정확히 배치
              }
              
              geometry = new THREE.BoxBufferGeometry(12, parti_ver_M_height, parti_width);
              var parti_ver_M_opposite = new THREE.Mesh(geometry, parti_ver_M_material);
              // 반대편 위치: 그룹 내 상대 위치로 설정 (미러링 적용됨)
              // 파티션 Z 위치: 책상 깊이 1000 이상이고 하부옵션 전면 정렬 선택 시
              var parti_z_pos = 0;
              if (board_depth >= 1000 && parti_z_align_front == 1) {
                parti_z_pos = board_depth / 2 - 200; // 하부옵션 전면과 같은 라인 (그룹 중심 기준)
              }
              parti_ver_M_opposite.position.set(parti_x_position, parti_center_y, parti_z_pos);
              parti_ver_M_opposite.castShadow = true;
              oppositeBottomOptionsGroup.add(parti_ver_M_opposite);
            }
            
            // 파티션 hol_B: 반대편 전면 파티션
            // 거리 -1030일 때는 전면파티션 복재 안함
            if (parti_hol_B_width > 0 && opposite_desk_distance != -1030) {
              var board_top_y = frame_length + board_thickness;
              var parti_hol_B_height = 800;
              var parti_bottom_y = board_top_y - 200;
              var parti_center_y = parti_bottom_y + parti_hol_B_height / 2 - 100;
              
              // 원래 전면파티션과 동일한 Z 위치 계산 로직 사용
              var parti_z_position;
              if (vertical_length == 0 || shelf_num == 0) {
                parti_z_position = -board_depth / 2 - 6;
              } else {
                var vertical_z = - (board_depth + frame_thickness + 5) / 2;
                var shelf_z_relative;
                if (shelf_direction == 0) {
                  shelf_z_relative = - (shelf_depth - frame_thickness + 2) / 2;
                } else {
                  shelf_z_relative = (shelf_depth - frame_thickness + 2) / 2;
                }
                var shelf_z_absolute = vertical_z + shelf_z_relative;
                var shelf_front_edge;
                var shelf_back_edge;
                
                if (shelf_direction == 0) {
                  shelf_back_edge = shelf_z_absolute + shelf_depth / 2;
                  shelf_front_edge = shelf_z_absolute - shelf_depth / 2;
                } else {
                  shelf_front_edge = shelf_z_absolute + shelf_depth / 2;
                  shelf_back_edge = shelf_z_absolute - shelf_depth / 2;
                }
                
                // 원래 전면파티션과 동일하게 뒤쪽 끝 사용
                var shelf_farthest_edge = shelf_back_edge;
                parti_z_position = shelf_farthest_edge - 6;
              }
              
              // 선반의 바깥방향(OUT) 선택 시 Z축으로 -200 이동 (원래와 동일)
              if (vertical_length > 0 && shelf_num > 0 && shelf_direction == 0) {
                parti_z_position -= 200;
              }
              
              geometry = new THREE.BoxBufferGeometry(parti_hol_B_width, parti_hol_B_height, 12);
              var parti_hol_B_opposite = new THREE.Mesh(geometry, parti_hol_B_material);
              // 반대편 위치: 그룹 내 상대 위치로 설정 (Z=0 기준, 그룹의 scale.z = -1로 미러링됨)
              // 원래 전면파티션의 Z 위치를 그대로 사용하면 그룹 미러링으로 올바르게 반전됨
              parti_hol_B_opposite.position.set(0, parti_center_y, parti_z_position);
              parti_hol_B_opposite.castShadow = true;
              oppositeBottomOptionsGroup.add(parti_hol_B_opposite);
            }
            
            // 반대편 ㄱ자 하부 서랍 (각 책상마다 생성) - 그룹에 추가하여 미러링
            if (giyeok_position) {
              var giyeok_positions = [];
              if (giyeok_position == 4) {
                giyeok_positions = [1, 2]; // 왼쪽, 오른쪽
              } else {
                giyeok_positions = [giyeok_position];
              }
              
              var giyeok_attach_top_y = frame_length + board_thickness - 60;
              
              for (var g_idx = 0; g_idx < giyeok_positions.length; g_idx++) {
                var g_pos = giyeok_positions[g_idx];
                
                // 왼쪽 ㄱ자 하부 서랍
                if (g_pos == 1 || g_pos == 4) {
                  if (giyeok_drawer_type_left == 1) {
                    createOppositeGiyeokDrawer(1, giyeok_attach1_left_color, opposite_desk_offset_x, giyeok_attach_top_y, opposite_desk_z, true, oppositeBottomOptionsGroup);
                  } else if (giyeok_drawer_type_left == 2) {
                    createOppositeGiyeokDrawer(2, giyeok_attach2_left_color, opposite_desk_offset_x, giyeok_attach_top_y, opposite_desk_z, true, oppositeBottomOptionsGroup);
                  } else if (giyeok_drawer_type_left == 3) {
                    createOppositeGiyeokDrawer(3, giyeok_attach3_left_color, opposite_desk_offset_x, giyeok_attach_top_y, opposite_desk_z, true, oppositeBottomOptionsGroup);
                  } else if (giyeok_drawer_type_left == 4) {
                    createOppositeGiyeokDrawer(4, giyeok_moving2_left_color, opposite_desk_offset_x, giyeok_attach_top_y, opposite_desk_z, true, oppositeBottomOptionsGroup);
                  } else if (giyeok_drawer_type_left == 5) {
                    createOppositeGiyeokDrawer(5, giyeok_moving3_left_color, opposite_desk_offset_x, giyeok_attach_top_y, opposite_desk_z, true, oppositeBottomOptionsGroup);
                  }
                }
                
                // 오른쪽 ㄱ자 하부 서랍
                if (g_pos == 2 || g_pos == 4) {
                  if (giyeok_drawer_type_right == 1) {
                    createOppositeGiyeokDrawer(1, giyeok_attach1_right_color, opposite_desk_offset_x, giyeok_attach_top_y, opposite_desk_z, false, oppositeBottomOptionsGroup);
                  } else if (giyeok_drawer_type_right == 2) {
                    createOppositeGiyeokDrawer(2, giyeok_attach2_right_color, opposite_desk_offset_x, giyeok_attach_top_y, opposite_desk_z, false, oppositeBottomOptionsGroup);
                  } else if (giyeok_drawer_type_right == 3) {
                    createOppositeGiyeokDrawer(3, giyeok_attach3_right_color, opposite_desk_offset_x, giyeok_attach_top_y, opposite_desk_z, false, oppositeBottomOptionsGroup);
                  } else if (giyeok_drawer_type_right == 4) {
                    createOppositeGiyeokDrawer(4, giyeok_moving2_right_color, opposite_desk_offset_x, giyeok_attach_top_y, opposite_desk_z, false, oppositeBottomOptionsGroup);
                  } else if (giyeok_drawer_type_right == 5) {
                    createOppositeGiyeokDrawer(5, giyeok_moving3_right_color, opposite_desk_offset_x, giyeok_attach_top_y, opposite_desk_z, false, oppositeBottomOptionsGroup);
                  }
                }
              }
            }
          }
        }

        // move desk array to center
        desk.position.set(-(board_width + 10) * 0.5 * (num_desk - 1), 0, 0);
        scene.add(desk);

        // 모든 옵션들을 각 책상마다 복사
        // desk_offset_x는 책상이 중앙 정렬된 후의 실제 위치를 반영해야 함
        for (var desk_idx = 0; desk_idx < num_desk; desk_idx++) {
          // 책상의 실제 X 위치 = 책상 배열 루프에서 설정한 위치 (i * (board_width + 10)) - 중앙 정렬 오프셋
          var desk_offset_x = (board_width + 10) * (desk_idx - 0.5 * (num_desk - 1));
          
          // 부착형 서랍 1단 (좌우 각각 1개만 설치 가능)
          // 부착형 서랍 1단, 부착형 서랍 2단, 본체함은 좌 1개와 우 1개를 각 택 1하여 설치할 수 있다
          // 상판하부 보강바 아래 부착, 전면 상판 마감선 맞춤
          // 책상 넓이 1200이상 일 경우: 1개, 1800이상일 경우: 중앙 1개, 사이드 1개 또는 좌우 다리 안쪽으로 1개씩 2개까지 가능
          // ㄱ자 모듈 부착시에는 ㄱ자 모듈에 부착
          // 좌측 1개만 가능
          // 규격: width=300, depth=400, height=160
          // 위치 규칙: 최상부는 상판 하단부에서 60 아래 위치, 전면부는 상판 전면부부터 -200 뒤로 위치
          // 좌측에 설치시, 좌측면 책상 좌측다리 내측 +155
          // 우측에 설치시, 우측면 책상 우측다리 내측 -155
          if (attach1_left_color) {
            var attach_top_y = frame_length + board_thickness - 60;
            // 좌측 다리 내측 +155
            var left_leg_inner_x = - (board_width - frame_thickness) / 2 + frame_thickness / 2 + 155;
            
            if (attach1_model) {
              var attach1_left = attach1_model.clone();
              attach1_left.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                  child.material = getMaterial(attach1_left_color);
                  child.castShadow = true;
                  child.receiveShadow = true;
                }
              });
              attach1_left.position.set(desk_offset_x + left_leg_inner_x, attach_top_y - 160 / 2, board_depth / 2 - 200);
              scene.add(attach1_left);
            } else {
              // GLB 모델이 로드되지 않은 경우 기본 박스 사용
              geometry = new THREE.BoxBufferGeometry(300, 160, 400);
              var attach1_left_material = getMaterial(attach1_left_color);
              var attach1_left = new THREE.Mesh(geometry, attach1_left_material);
              attach1_left.position.set(desk_offset_x + left_leg_inner_x, attach_top_y - 160 / 2, board_depth / 2 - 200);
              attach1_left.castShadow = true;
              scene.add(attach1_left);
            }
          }
          // 우측 1개만 가능
          // 규격: width=300, depth=400, height=160
          if (attach1_right_color) {
            var attach_top_y = frame_length + board_thickness - 60;
            // 우측 다리 내측 -155
            var right_leg_inner_x = (board_width - frame_thickness) / 2 - frame_thickness / 2 - 155;
            
            if (attach1_model) {
              var attach1_right = attach1_model.clone();
              attach1_right.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                  child.material = getMaterial(attach1_right_color);
                  child.castShadow = true;
                  child.receiveShadow = true;
                }
              });
              attach1_right.position.set(desk_offset_x + right_leg_inner_x, attach_top_y - 160 / 2, board_depth / 2 - 200);
              scene.add(attach1_right);
            } else {
              // GLB 모델이 로드되지 않은 경우 기본 박스 사용
              geometry = new THREE.BoxBufferGeometry(300, 160, 400);
              var attach1_right_material = getMaterial(attach1_right_color);
              var attach1_right = new THREE.Mesh(geometry, attach1_right_material);
              attach1_right.position.set(desk_offset_x + right_leg_inner_x, attach_top_y - 160 / 2, board_depth / 2 - 200);
              attach1_right.castShadow = true;
              scene.add(attach1_right);
            }
          }

          // 부착형 서랍 2단 (좌우 각각 1개만 설치 가능)
          // 부착형 서랍 1단, 부착형 서랍 2단, 본체함은 좌 1개와 우 1개를 각 택 1하여 설치할 수 있다
          // 상판하부 보강바 아래 부착, 전면 상판 마감선 맞춤
          // 책상 넓이 1200이상 일 경우: 1개, 1800이상일 경우: 중앙 1개, 사이드 1개 또는 좌우 다리 안쪽으로 1개씩 총 2개까지 가능
          // ㄱ자 모듈 부착시에는 ㄱ자 모듈에 부착
          // 좌측 1개만 가능
          // 규격: width=300, depth=400, height=500
          // 위치 규칙: 최상부는 상판 하단부에서 60 아래 위치, 전면부는 상판 전면부부터 -200 뒤로 위치
          // 좌측에 설치시, 좌측면 책상 좌측다리 내측 +155
          if (attach2_left_color) {
            var attach_top_y = frame_length + board_thickness - 60;
            var left_leg_inner_x = - (board_width - frame_thickness) / 2 + frame_thickness / 2 + 155;
            
            if (attach2_model) {
              var attach2_left = attach2_model.clone();
              attach2_left.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                  child.material = getMaterial(attach2_left_color);
                  child.castShadow = true;
                  child.receiveShadow = true;
                }
              });
              attach2_left.position.set(desk_offset_x + left_leg_inner_x, attach_top_y - 500 / 2, board_depth / 2 - 200);
              scene.add(attach2_left);
            } else {
              // GLB 모델이 로드되지 않은 경우 기본 박스 사용
              geometry = new THREE.BoxBufferGeometry(300, 500, 400);
              var attach2_left_material = getMaterial(attach2_left_color);
              var attach2_left = new THREE.Mesh(geometry, attach2_left_material);
              attach2_left.position.set(desk_offset_x + left_leg_inner_x, attach_top_y - 500 / 2, board_depth / 2 - 200);
              attach2_left.castShadow = true;
              scene.add(attach2_left);
            }
          }
          // 우측 1개만 가능
          // 규격: width=300, depth=400, height=500
          // 우측에 설치시, 우측면 책상 우측다리 내측 -155
          if (attach2_right_color) {
            var attach_top_y = frame_length + board_thickness - 60;
            var right_leg_inner_x = (board_width - frame_thickness) / 2 - frame_thickness / 2 - 155;
            
            if (attach2_model) {
              var attach2_right = attach2_model.clone();
              attach2_right.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                  child.material = getMaterial(attach2_right_color);
                  child.castShadow = true;
                  child.receiveShadow = true;
                }
              });
              attach2_right.position.set(desk_offset_x + right_leg_inner_x, attach_top_y - 500 / 2, board_depth / 2 - 200);
              scene.add(attach2_right);
            } else {
              // GLB 모델이 로드되지 않은 경우 기본 박스 사용
              geometry = new THREE.BoxBufferGeometry(300, 500, 400);
              var attach2_right_material = getMaterial(attach2_right_color);
              var attach2_right = new THREE.Mesh(geometry, attach2_right_material);
              attach2_right.position.set(desk_offset_x + right_leg_inner_x, attach_top_y - 500 / 2, board_depth / 2 - 200);
              attach2_right.castShadow = true;
              scene.add(attach2_right);
            }
          }

          // 본체함 (좌우 각각 1개만 설치 가능)
          // 부착형 서랍 1단, 부착형 서랍 2단, 본체함은 좌 1개와 우 1개를 각 택 1하여 설치할 수 있다
          // 상판하부 보강바 아래 부착, 전면 상판 마감선 맞춤
          // 책상 넓이 1200이상 일 경우: 1개, 1800이상일 경우: 중앙 1개, 사이드 1개 또는 좌우 다리 안쪽으로 1개씩 총 2개까지 가능
          // ㄱ자 모듈 부착시에는 ㄱ자 모듈 상판 하부에 부착
          // 좌측 1개만 가능
          // 규격: width=300, depth=400, height=500
          // 위치 규칙: 최상부는 상판 하단부에서 60 아래 위치, 전면부는 상판 전면부부터 -200 뒤로 위치
          // 좌측에 설치시, 좌측면 책상 좌측다리 내측 +155
          if (attach3_left_color) {
            var attach_top_y = frame_length + board_thickness - 60;
            var left_leg_inner_x = - (board_width - frame_thickness) / 2 + frame_thickness / 2 + 155;
            
            if (attach3_model) {
              var attach3_left = attach3_model.clone();
              attach3_left.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                  child.material = getMaterial(attach3_left_color);
                  child.castShadow = true;
                  child.receiveShadow = true;
                }
              });
              attach3_left.position.set(desk_offset_x + left_leg_inner_x, attach_top_y - 500 / 2, board_depth / 2 - 200);
              scene.add(attach3_left);
            } else {
              // GLB 모델이 로드되지 않은 경우 기본 박스 사용
              geometry = new THREE.BoxBufferGeometry(300, 500, 400);
              var attach3_left_material = getMaterial(attach3_left_color);
              var attach3_left = new THREE.Mesh(geometry, attach3_left_material);
              attach3_left.position.set(desk_offset_x + left_leg_inner_x, attach_top_y - 500 / 2, board_depth / 2 - 200);
              attach3_left.castShadow = true;
              scene.add(attach3_left);
            }
          }
          // 우측 1개만 가능
          // 규격: width=300, depth=400, height=500
          // 우측에 설치시, 우측면 책상 우측다리 내측 -155
          if (attach3_right_color) {
            var attach_top_y = frame_length + board_thickness - 60;
            var right_leg_inner_x = (board_width - frame_thickness) / 2 - frame_thickness / 2 - 155;
            
            if (attach3_model) {
              var attach3_right = attach3_model.clone();
              attach3_right.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                  child.material = getMaterial(attach3_right_color);
                  child.castShadow = true;
                  child.receiveShadow = true;
                }
              });
              attach3_right.position.set(desk_offset_x + right_leg_inner_x, attach_top_y - 500 / 2, board_depth / 2 - 200);
              scene.add(attach3_right);
            } else {
              // GLB 모델이 로드되지 않은 경우 기본 박스 사용
              geometry = new THREE.BoxBufferGeometry(300, 500, 400);
              var attach3_right_material = getMaterial(attach3_right_color);
              var attach3_right = new THREE.Mesh(geometry, attach3_right_material);
              attach3_right.position.set(desk_offset_x + right_leg_inner_x, attach_top_y - 500 / 2, board_depth / 2 - 200);
              attach3_right.castShadow = true;
              scene.add(attach3_right);
            }
          }

          // 이동 서랍 2단 (moving2)
          if (moving2_color) {
            geometry = new THREE.BoxBufferGeometry(300, 585, 400);
            var moving2_dup = new THREE.Mesh(geometry, moving2_material);
            // 이동서랍의 중심 Y 위치: 땅(y=0)에서 이동서랍 높이의 절반만큼 위 + 50
            moving2_dup.position.y = 585 / 2 + 50;
            
            // 기존 위치 유지 (ㄱ자 선택과 관계없이 독립적으로 작동)
            var moving2_x;
            if (moving2_position == 1)
              moving2_x = desk_offset_x - (board_width - 400) / 2;
            else
              moving2_x = desk_offset_x + (board_width - 400) / 2;
            moving2_dup.position.x = moving2_x;
            moving2_dup.position.z = (board_depth - 450) / 2;
            moving2_dup.castShadow = true;
            scene.add(moving2_dup);

            // drawer 1 and 2
            geometry = new THREE.BoxBufferGeometry(300, 275, 20);
            var drawer1_dup = new THREE.Mesh(geometry, moving2_material);
            drawer1_dup.position.y = (585 - 275) / 2;
            drawer1_dup.position.z = 220;
            moving2_dup.add(drawer1_dup);

            var drawer2_dup = new THREE.Mesh(geometry, moving2_material);
            drawer2_dup.position.y = -(585 - 275) / 2;
            drawer2_dup.position.z = 220;
            moving2_dup.add(drawer2_dup);

            // wheel
            geometry = new THREE.CylinderBufferGeometry(25, 25, 30);
            var wheel_dup = new THREE.Mesh(geometry, leg_pad_meterial);
            wheel_dup.position.set(-130, -320, 180);
            wheel_dup.rotation.x = Math.PI / 2;
            moving2_dup.add(wheel_dup);

            wheel_dup = new THREE.Mesh(geometry, leg_pad_meterial);
            wheel_dup.position.set(130, -320, 180);
            wheel_dup.rotation.x = Math.PI / 2;
            moving2_dup.add(wheel_dup);

            wheel_dup = new THREE.Mesh(geometry, leg_pad_meterial);
            wheel_dup.position.set(-130, -320, -180);
            wheel_dup.rotation.x = Math.PI / 2;
            moving2_dup.add(wheel_dup);

            wheel_dup = new THREE.Mesh(geometry, leg_pad_meterial);
            wheel_dup.position.set(130, -320, -180);
            wheel_dup.rotation.x = Math.PI / 2;
            moving2_dup.add(wheel_dup);
          }

          // 이동 서랍 3단 (moving3)
          if (moving3_color) {
            geometry = new THREE.BoxBufferGeometry(400, 585, 580);
            var moving3_dup = new THREE.Mesh(geometry, moving3_material);
            // 이동서랍의 중심 Y 위치: 땅(y=0)에서 이동서랍 높이의 절반만큼 위 + 50
            moving3_dup.position.y = 585 / 2 + 50;
            
            // 기존 위치 유지 (ㄱ자 선택과 관계없이 독립적으로 작동)
            var moving3_x;
            if (moving3_position == 1)
              moving3_x = desk_offset_x - (board_width - 500) / 2;
            else
              moving3_x = desk_offset_x + (board_width - 500) / 2;
            moving3_dup.position.x = moving3_x;
            moving3_dup.position.z = (board_depth - 640) / 2;
            moving3_dup.castShadow = true;
            scene.add(moving3_dup);

            // drawer 1, 2, 3
            geometry = new THREE.BoxBufferGeometry(400, 190, 20);
            var drawer1_dup = new THREE.Mesh(geometry, moving3_material);
            drawer1_dup.position.y = (585 - 190) / 2;
            drawer1_dup.position.z = 310;
            moving3_dup.add(drawer1_dup);

            var drawer2_dup = new THREE.Mesh(geometry, moving3_material);
            drawer2_dup.position.y = 0;
            drawer2_dup.position.z = 310;
            moving3_dup.add(drawer2_dup);

            var drawer3_dup = new THREE.Mesh(geometry, moving3_material);
            drawer3_dup.position.y = - (585 - 190) / 2;
            drawer3_dup.position.z = 310;
            moving3_dup.add(drawer3_dup);

            // wheel
            geometry = new THREE.CylinderBufferGeometry(25, 25, 30);
            var wheel_dup = new THREE.Mesh(geometry, leg_pad_meterial);
            wheel_dup.position.set(-180, -320, 280);
            wheel_dup.rotation.x = Math.PI / 2;
            moving3_dup.add(wheel_dup);

            wheel_dup = new THREE.Mesh(geometry, leg_pad_meterial);
            wheel_dup.position.set(180, -320, 280);
            wheel_dup.rotation.x = Math.PI / 2;
            moving3_dup.add(wheel_dup);

            wheel_dup = new THREE.Mesh(geometry, leg_pad_meterial);
            wheel_dup.position.set(-180, -320, -280);
            wheel_dup.rotation.x = Math.PI / 2;
            moving3_dup.add(wheel_dup);

            wheel_dup = new THREE.Mesh(geometry, leg_pad_meterial);
            wheel_dup.position.set(180, -320, -280);
            wheel_dup.rotation.x = Math.PI / 2;
            moving3_dup.add(wheel_dup);
          }

          // ㄱ자 하부 서랍 (desk_idx 루프 내에서 각 책상마다 생성)
          if (giyeok_position) {
            var giyeok_positions = [];
            if (giyeok_position == 4) {
              giyeok_positions = [1, 2]; // 왼쪽, 오른쪽
            } else {
              giyeok_positions = [giyeok_position];
            }
            
            var giyeok_attach_top_y = frame_length + board_thickness - 60;
            
            for (var g_idx = 0; g_idx < giyeok_positions.length; g_idx++) {
              var g_pos = giyeok_positions[g_idx];
              
              // 왼쪽 ㄱ자 하부 서랍
              if (g_pos == 1 || g_pos == 4) {
                // 좌측 ㄱ자 보드의 우측 끝 위치: desk_offset_x - (board_width - 600) / 2 + 300
                var giyeok_board_right_edge = desk_offset_x - (board_width - 600) / 2 + 300;
                var giyeok_inner_x = giyeok_board_right_edge - 200; // ㄱ자 옵션 우측 끝 -200까지 이동
                var giyeok_inner_z = (board_depth + 800) / 2 - 200 + 400; // Z축 +400 이동
                
                // 타입별 서랍 생성
                if (giyeok_drawer_type_left == 1) {
                  createGiyeokDrawer(1, giyeok_attach1_left_color, 'left', desk_offset_x, giyeok_attach_top_y, giyeok_inner_x, giyeok_inner_z, Math.PI / 2);
                } else if (giyeok_drawer_type_left == 2) {
                  createGiyeokDrawer(2, giyeok_attach2_left_color, 'left', desk_offset_x, giyeok_attach_top_y, giyeok_inner_x, giyeok_inner_z, Math.PI / 2);
                } else if (giyeok_drawer_type_left == 3) {
                  createGiyeokDrawer(3, giyeok_attach3_left_color, 'left', desk_offset_x, giyeok_attach_top_y, giyeok_inner_x, giyeok_inner_z, Math.PI / 2);
                } else if (giyeok_drawer_type_left == 4) {
                  createGiyeokDrawer(4, giyeok_moving2_left_color, 'left', desk_offset_x, giyeok_attach_top_y, giyeok_inner_x, giyeok_inner_z, Math.PI / 2);
                } else if (giyeok_drawer_type_left == 5) {
                  createGiyeokDrawer(5, giyeok_moving3_left_color, 'left', desk_offset_x, giyeok_attach_top_y, giyeok_inner_x, giyeok_inner_z, Math.PI / 2);
                }
              }
              
              // 오른쪽 ㄱ자 하부 서랍
              if (g_pos == 2 || g_pos == 4) {
                // 우측 ㄱ자 보드의 좌측 끝 위치: desk_offset_x + (board_width - 600) / 2 - 300
                var giyeok_board_left_edge = desk_offset_x + (board_width - 600) / 2 - 300;
                var giyeok_inner_x = giyeok_board_left_edge + 200; // ㄱ자 옵션 좌측 끝 +200까지 이동
                var giyeok_inner_z = (board_depth + 800) / 2 - 200 + 400; // Z축 +400 이동
                
                // 타입별 서랍 생성
                if (giyeok_drawer_type_right == 1) {
                  createGiyeokDrawer(1, giyeok_attach1_right_color, 'right', desk_offset_x, giyeok_attach_top_y, giyeok_inner_x, giyeok_inner_z, -Math.PI / 2);
                } else if (giyeok_drawer_type_right == 2) {
                  createGiyeokDrawer(2, giyeok_attach2_right_color, 'right', desk_offset_x, giyeok_attach_top_y, giyeok_inner_x, giyeok_inner_z, -Math.PI / 2);
                } else if (giyeok_drawer_type_right == 3) {
                  createGiyeokDrawer(3, giyeok_attach3_right_color, 'right', desk_offset_x, giyeok_attach_top_y, giyeok_inner_x, giyeok_inner_z, -Math.PI / 2);
                } else if (giyeok_drawer_type_right == 4) {
                  createGiyeokDrawer(4, giyeok_moving2_right_color, 'right', desk_offset_x, giyeok_attach_top_y, giyeok_inner_x, giyeok_inner_z, -Math.PI / 2);
                } else if (giyeok_drawer_type_right == 5) {
                  createGiyeokDrawer(5, giyeok_moving3_right_color, 'right', desk_offset_x, giyeok_attach_top_y, giyeok_inner_x, giyeok_inner_z, -Math.PI / 2);
                }
              }
            }
          }

          // 수납 슬라이딩도어 1단 (Storage_Sliding1_color)
          // 기준 규격은 기존 선반 360 깊이와 폭에 따름(도어 별도/높이 400 개별지정)
          // 수직부재 1400,1860 최상단에만 조합가능
          // 수납_슬라이딩도어 1단은 선반 2개와 대체
          // 1~6단 높이 모두 구성가능(최상단과 최하단 구성가능)
          // 규격: width=board_width - 80, depth=360, height=400
          // 위치 규칙: X축 기준 수직부재의 중앙에 위치, Y축 기준위치(센터) 수직부재의 센터와 일치, 옵션모듈의 높이는 선택한 수직부재의 규격이 1400일 경우 1200 높이에 위치, 선택한 수직부재의 규격이 1860인 경우 1400 높이에 위치, 선반360 최상단 위치와 평면위치 동일
          if (storage_sliding1_color && vertical_length > 0) {
            var storage_sliding1_width = board_width - 80; // width=board_width - 80
            var storage_sliding1_depth = 360; // depth=360
            var storage_sliding1_height = 400; // 높이 400
            // 수직부재 위치 계산
            var vertical_y_current = vertical_y + (vertical_y_offset * 93.5);
            var vertical_bottom_y = vertical_y_current - vertical_length / 2; // 수직부재 하단
            // 옵션모듈의 높이 위치 계산: 수직부재 하단에서 지정된 높이에 위치
            var storage_height_position = 0;
            var model_height = 1400; // 기본 모델 높이
            if (vertical_length_idx == 3) { // 1400
              storage_height_position = 1200; // 높이 1200에 위치
              model_height = 1400;
            } else if (vertical_length_idx == 4) { // 1860
              storage_height_position = 1400; // 높이 1400에 위치
              model_height = 2060; // 1860에 가장 가까운 모델
            }
            // 도어의 센터 위치 = 수직부재 하단 + 지정된 높이 + 도어 높이의 절반 + 오프셋
            var storage_center_y = vertical_bottom_y + storage_height_position + storage_sliding1_height / 2 + (storage_y_offset * 93.5);
            // 선반360 최상단 위치와 평면위치 동일 (Z 위치)
            // 선반 깊이 200이고 방향이 바깥쪽일 때도 선반 360과 동일한 위치
            var shelf_z_offset = 0;
            if (shelf_depth == 360 || (shelf_depth == 200 && shelf_direction == 0)) {
              shelf_z_offset = 160; // 선반360일 때 또는 선반200 바깥쪽일 때 Z축 오프셋
            }
            var shelf_z_relative = shelf_direction == 0 ? - (shelf_depth - frame_thickness + 2) / 2 : (shelf_depth - frame_thickness + 2) / 2;
            var vertical_z = - (board_depth + frame_thickness + 5) / 2;
            var shelf_z_absolute = vertical_z + shelf_z_relative + shelf_z_offset;
            
            if (storage_sliding1_models[model_height]) {
              var storage_sliding1_dup = storage_sliding1_models[model_height].clone();
              storage_sliding1_dup.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                  child.material = storage_sliding1_material;
                  child.castShadow = true;
                  child.receiveShadow = true;
                }
              });
              storage_sliding1_dup.position.set(desk_offset_x, storage_center_y, shelf_z_absolute);
              scene.add(storage_sliding1_dup);
            } else {
              // GLB 모델이 로드되지 않은 경우 기본 박스 사용
              geometry = new THREE.BoxBufferGeometry(storage_sliding1_width, storage_sliding1_height, storage_sliding1_depth);
              var storage_sliding1_dup = new THREE.Mesh(geometry, storage_sliding1_material);
              storage_sliding1_dup.position.set(desk_offset_x, storage_center_y, shelf_z_absolute);
              storage_sliding1_dup.castShadow = true;
              scene.add(storage_sliding1_dup);
            }
          }

          // 수납 슬라이딩도어 2단 (Storage_Sliding2_color)
          // 기준 규격은 기존 선반 360 깊이와 폭에 따름(도어 별도/높이 800 개별지정)
          // 수직부재 1400,1860 최상단에만 조합가능
          // 수납_슬라이딩도어 2단은 선반 3개와 대체
          // 1~6단 높이 모두 구성가능(최상단만 구성가능)
          // 규격: width=board_width - 80, depth=360, height=800
          // 위치 규칙: X축 기준 수직부재의 중앙에 위치, Y축 기준위치(센터) 수직부재의 센터와 일치, 옵션모듈의 높이는 선택한 수직부재의 규격이 1400일 경우 1200 높이에 위치, 선택한 수직부재의 규격이 1860인 경우 1400 높이에 위치, 선반360 최상단 위치와 평면위치 동일
          if (storage_sliding2_color && vertical_length > 0) {
            var storage_sliding2_width = board_width - 80; // width=board_width - 80
            var storage_sliding2_depth = 360; // depth=360
            var storage_sliding2_height = 800; // 높이 800
            // 수직부재 위치 계산
            var vertical_y_current = vertical_y + (vertical_y_offset * 93.5);
            var vertical_bottom_y = vertical_y_current - vertical_length / 2; // 수직부재 하단
            // 옵션모듈의 높이 위치 계산: 수직부재 하단에서 지정된 높이에 위치
            var storage_height_position = 0;
            var model_height = 1400; // 기본 모델 높이
            if (vertical_length_idx == 3) { // 1400
              storage_height_position = 1200; // 높이 1200에 위치
              model_height = 1400;
            } else if (vertical_length_idx == 4) { // 1860
              storage_height_position = 1400; // 높이 1400에 위치
              model_height = 2060; // 1860에 가장 가까운 모델
            }
            // 도어의 센터 위치 = 수직부재 하단 + 지정된 높이 + 도어 높이의 절반 + 오프셋
            var storage_center_y = vertical_bottom_y + storage_height_position + storage_sliding2_height / 2 + (storage_y_offset * 93.5);
            // 선반360 최상단 위치와 평면위치 동일 (Z 위치)
            // 선반 깊이 200이고 방향이 바깥쪽일 때도 선반 360과 동일한 위치
            var shelf_z_offset = 0;
            if (shelf_depth == 360 || (shelf_depth == 200 && shelf_direction == 0)) {
              shelf_z_offset = 160; // 선반360일 때 또는 선반200 바깥쪽일 때 Z축 오프셋
            }
            var shelf_z_relative = shelf_direction == 0 ? - (shelf_depth - frame_thickness + 2) / 2 : (shelf_depth - frame_thickness + 2) / 2;
            var vertical_z = - (board_depth + frame_thickness + 5) / 2;
            var shelf_z_absolute = vertical_z + shelf_z_relative + shelf_z_offset;
            
            if (storage_sliding2_models[model_height]) {
              var storage_sliding2_dup = storage_sliding2_models[model_height].clone();
              storage_sliding2_dup.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                  child.material = storage_sliding2_material;
                  child.castShadow = true;
                  child.receiveShadow = true;
                }
              });
              storage_sliding2_dup.position.set(desk_offset_x, storage_center_y, shelf_z_absolute);
              scene.add(storage_sliding2_dup);
            } else {
              // GLB 모델이 로드되지 않은 경우 기본 박스 사용
              geometry = new THREE.BoxBufferGeometry(storage_sliding2_width, storage_sliding2_height, storage_sliding2_depth);
              var storage_sliding2_dup = new THREE.Mesh(geometry, storage_sliding2_material);
              storage_sliding2_dup.position.set(desk_offset_x, storage_center_y, shelf_z_absolute);
              storage_sliding2_dup.castShadow = true;
              scene.add(storage_sliding2_dup);
            }
          }

          // 수납 플랩도어 (Storage_Flap_color) - GLB 모델 사용
          // 기준 규격은 기존 선반 360 깊이와 폭에 따름(도어 별도/높이 400 개별지정)
          // 수직부재 1400,1860 최상단에만 조합가능
          // 선반 2개와 대체
          // 주로, 4단 이상 구성
          // 규격: width=board_width - 80, depth=360, height=400
          // 위치 규칙: X축 기준 수직부재의 중앙에 위치, Y축 기준위치(센터) 수직부재의 센터와 일치, 옵션의 높이는 선택한 수직부재(1400, 1860) 위 아래 중앙에 위치, 선반360 최상단 위치와 평면위치 동일
          if (storage_flap_color && vertical_length > 0) {
            var storage_flap_width = board_width - 80; // width=board_width - 80
            var storage_flap_depth = 360; // depth=360
            var storage_flap_height = 400; // 높이 400
            // 수직부재 위치 계산
            var vertical_y_current = vertical_y + (vertical_y_offset * 93.5);
            var vertical_bottom_y = vertical_y_current - vertical_length / 2; // 수직부재 하단
            // 옵션모듈의 높이 위치 계산: 수직부재 하단에서 지정된 높이에 위치
            var storage_height_position = 0;
            var model_height = 1400; // 기본 모델 높이
            if (vertical_length_idx == 3) { // 1400
              storage_height_position = 1200; // 높이 1200에 위치
              model_height = 1400;
            } else if (vertical_length_idx == 4) { // 1860
              storage_height_position = 1400; // 높이 1400에 위치
              model_height = 2060; // 1860에 가장 가까운 모델
            }
            // 도어의 센터 위치 = 수직부재 하단 + 지정된 높이 + 도어 높이의 절반 + 오프셋
            var storage_center_y = vertical_bottom_y + storage_height_position + storage_flap_height / 2 + (storage_y_offset * 93.5);
            // 선반360 최상단 위치와 평면위치 동일 (Z 위치)
            // 선반 깊이 200이고 방향이 바깥쪽일 때도 선반 360과 동일한 위치
            var shelf_z_offset = 0;
            if (shelf_depth == 360 || (shelf_depth == 200 && shelf_direction == 0)) {
              shelf_z_offset = 160; // 선반360일 때 또는 선반200 바깥쪽일 때 Z축 오프셋
            }
            var shelf_z_relative = shelf_direction == 0 ? - (shelf_depth - frame_thickness + 2) / 2 : (shelf_depth - frame_thickness + 2) / 2;
            var vertical_z = - (board_depth + frame_thickness + 5) / 2;
            var shelf_z_absolute = vertical_z + shelf_z_relative + shelf_z_offset;
            
            if (storage_flap_models[model_height]) {
              var storage_flap_dup = storage_flap_models[model_height].clone();
              storage_flap_dup.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                  child.material = storage_flap_material;
                  child.castShadow = true;
                  child.receiveShadow = true;
                }
              });
              storage_flap_dup.position.set(desk_offset_x, storage_center_y, shelf_z_absolute);
              scene.add(storage_flap_dup);
            } else {
              // GLB 모델이 로드되지 않은 경우 기본 박스 사용
              geometry = new THREE.BoxBufferGeometry(storage_flap_width, storage_flap_height, storage_flap_depth);
              var storage_flap_dup = new THREE.Mesh(geometry, storage_flap_material);
              storage_flap_dup.position.set(desk_offset_x, storage_center_y, shelf_z_absolute);
              storage_flap_dup.castShadow = true;
              scene.add(storage_flap_dup);
            }
          }

          // 수납 플랩스테이도어 (Storage_FlapStay_color)
          // 기준 규격은 기존 선반 360 깊이와 폭에 따름(도어 별도/높이 400 개별지정)
          // 수직부재 1400,1860 최상단과 최하단에만 조합가능
          // 선반 2개와 대체
          // 주로, 4단 이하 구성
          // 규격: width=board_width - 80, depth=360, height=400
          // 위치 규칙: X축 기준 수직부재의 중앙에 위치, Y축 기준위치(센터) 수직부재의 센터와 일치, 옵션모듈의 높이는 선택한 수직부재의 규격이 1400일 경우 1200 높이에 위치, 선택한 수직부재의 규격이 1860인 경우 1400 높이에 위치, 선반360 최상단 위치와 평면위치 동일
          if (storage_flapstay_color && vertical_length > 0) {
            var storage_flapstay_width = board_width - 80; // width=board_width - 80
            var storage_flapstay_depth = 360; // depth=360
            var storage_flapstay_height = 400; // 높이 400
            // 수직부재 위치 계산
            var vertical_y_current = vertical_y + (vertical_y_offset * 93.5);
            var vertical_bottom_y = vertical_y_current - vertical_length / 2; // 수직부재 하단
            // 옵션모듈의 높이 위치 계산: 수직부재 하단에서 지정된 높이에 위치
            var storage_height_position = 0;
            if (vertical_length_idx == 3) { // 1400
              storage_height_position = 1200; // 높이 1200에 위치
            } else if (vertical_length_idx == 4) { // 1860
              storage_height_position = 1400; // 높이 1400에 위치
            }
            // 도어의 센터 위치 = 수직부재 하단 + 지정된 높이 + 도어 높이의 절반 + 오프셋
            var storage_center_y = vertical_bottom_y + storage_height_position + storage_flapstay_height / 2 + (storage_y_offset * 93.5);
            // 선반360 최상단 위치와 평면위치 동일 (Z 위치)
            // 선반 깊이 200이고 방향이 바깥쪽일 때도 선반 360과 동일한 위치
            var shelf_z_offset = 0;
            if (shelf_depth == 360 || (shelf_depth == 200 && shelf_direction == 0)) {
              shelf_z_offset = 160; // 선반360일 때 또는 선반200 바깥쪽일 때 Z축 오프셋
            }
            var shelf_z_relative = shelf_direction == 0 ? - (shelf_depth - frame_thickness + 2) / 2 : (shelf_depth - frame_thickness + 2) / 2;
            var vertical_z = - (board_depth + frame_thickness + 5) / 2;
            var shelf_z_absolute = vertical_z + shelf_z_relative + shelf_z_offset;
            
            // 모델 높이 결정
            var model_height = 1400; // 기본 모델 높이
            if (vertical_length_idx == 3) { // 1400
              model_height = 1400;
            } else if (vertical_length_idx == 4) { // 1860
              model_height = 2060; // 1860에 가장 가까운 모델
            }
            
            if (storage_flapstay_models[model_height]) {
              var storage_flapstay_dup = storage_flapstay_models[model_height].clone();
              storage_flapstay_dup.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                  child.material = storage_flapstay_material;
                  child.castShadow = true;
                  child.receiveShadow = true;
                }
              });
              storage_flapstay_dup.position.set(desk_offset_x, storage_center_y, shelf_z_absolute);
              scene.add(storage_flapstay_dup);
            } else {
              // GLB 모델이 로드되지 않은 경우 기본 박스 사용
              geometry = new THREE.BoxBufferGeometry(storage_flapstay_width, storage_flapstay_height, storage_flapstay_depth);
              var storage_flapstay_dup = new THREE.Mesh(geometry, storage_flapstay_material);
              storage_flapstay_dup.position.set(desk_offset_x, storage_center_y, shelf_z_absolute);
              storage_flapstay_dup.castShadow = true;
              scene.add(storage_flapstay_dup);
            }
          }

          // 파티션 ver_L: 첫 번째 책상의 왼쪽 파티션만 렌더링 (중첩 부분 제외)
          if (parti_ver_L_height > 0 && desk_idx == 0) {
            var board_top_y = frame_length + board_thickness; // 상판 높이
            var parti_bottom_y; // 파티션의 제일 낮은 부분
            var parti_center_y; // 파티션의 중심 높이
            
            // 파티션 폭 기본값 800
            var parti_width = 800;
            
            // 높이에 따른 설치 위치 계산
            switch (parti_ver_L_height) {
              case 460:
                parti_bottom_y = board_top_y;
                parti_center_y = parti_bottom_y + parti_ver_L_height / 2 + 15; // Y축 +15 이동 (위로)
                break;
              case 800:
                parti_bottom_y = board_top_y - 300; // 100 낮게 조정
                parti_center_y = parti_bottom_y + parti_ver_L_height / 2;
                break;
              case 1200:
              case 1400:
              case 1600:
              case 1800:
                parti_bottom_y = board_top_y - 700;
                parti_center_y = parti_bottom_y + parti_ver_L_height / 2;
                break;
              default:
                parti_bottom_y = board_top_y;
                parti_center_y = parti_bottom_y + parti_ver_L_height / 2;
            }
            
            // 파티션 X 위치 계산: 선반이 있을 경우 선반의 제일 바깥쪽으로
            var parti_x_position;
            if (vertical_length > 0 && shelf_num > 0) {
              // 선반의 바깥쪽 가장자리 계산
              var vertical_z = - (board_depth + frame_thickness + 5) / 2;
              var shelf_z_relative;
              if (shelf_direction == 0) {
                // 바깥쪽 방향 (OUT)
                shelf_z_relative = - (shelf_depth - frame_thickness + 2) / 2;
              } else {
                // 안쪽 방향 (IN)
                shelf_z_relative = (shelf_depth - frame_thickness + 2) / 2;
              }
              var shelf_z_absolute = vertical_z + shelf_z_relative;
              // 선반의 바깥쪽 가장자리 (더 뒤쪽, 음수 방향)
              var shelf_outer_edge_z = shelf_z_absolute - shelf_depth / 2;
              // 파티션을 선반 바깥쪽에 붙임 (파티션 두께의 절반만큼 뒤로)
              parti_x_position = desk_offset_x - board_width / 2 - 6; // 12mm 두께의 절반만큼 바깥쪽
            } else {
              // 선반이 없을 경우: 책상 상판 측면에 바로 붙음
              parti_x_position = desk_offset_x - board_width / 2;
            }
            
            geometry = new THREE.BoxBufferGeometry(12, parti_ver_L_height, parti_width);
            var parti_ver_L_dup = new THREE.Mesh(geometry, parti_ver_L_material);
            // 파티션 Z 위치: 책상 깊이 1000 이상이고 하부옵션 전면 정렬 선택 시
            var parti_z_pos = 0;
            if (board_depth >= 1000 && parti_z_align_front == 1) {
              parti_z_pos = board_depth / 2 - 200; // 하부옵션 전면과 같은 라인
            }
            parti_ver_L_dup.position.set(parti_x_position, parti_center_y, parti_z_pos);
            parti_ver_L_dup.castShadow = true;
            scene.add(parti_ver_L_dup);
          }

          // 파티션 ver_R: 마지막 책상의 오른쪽 파티션만 렌더링 (중첩 부분 제외)
          if (desk_idx == num_desk - 1 && parti_ver_R_height > 0) {
            var board_top_y = frame_length + board_thickness;
            var parti_bottom_y;
            var parti_center_y;
            var parti_width = 800;
            
            switch (parti_ver_R_height) {
              case 460:
                parti_bottom_y = board_top_y;
                parti_center_y = parti_bottom_y + parti_ver_R_height / 2 + 15; // Y축 +15 이동 (위로)
                break;
              case 800:
                parti_bottom_y = board_top_y - 300; // 100 낮게 조정
                parti_center_y = parti_bottom_y + parti_ver_R_height / 2;
                break;
              case 1200:
              case 1400:
              case 1600:
              case 1800:
                parti_bottom_y = board_top_y - 700;
                parti_center_y = parti_bottom_y + parti_ver_R_height / 2;
                break;
              default:
                parti_bottom_y = board_top_y;
                parti_center_y = parti_bottom_y + parti_ver_R_height / 2;
            }
            
            var parti_x_position;
            if (vertical_length > 0 && shelf_num > 0) {
              var vertical_z = - (board_depth + frame_thickness + 5) / 2;
              var shelf_z_relative;
              if (shelf_direction == 0) {
                shelf_z_relative = - (shelf_depth - frame_thickness + 2) / 2;
              } else {
                shelf_z_relative = (shelf_depth - frame_thickness + 2) / 2;
              }
              var shelf_z_absolute = vertical_z + shelf_z_relative;
              var shelf_outer_edge_z = shelf_z_absolute - shelf_depth / 2;
              parti_x_position = desk_offset_x + board_width / 2 + 6;
            } else {
              parti_x_position = desk_offset_x + board_width / 2;
            }
            
            geometry = new THREE.BoxBufferGeometry(12, parti_ver_R_height, parti_width);
            var parti_ver_R_dup = new THREE.Mesh(geometry, parti_ver_R_material);
            // 파티션 Z 위치: 책상 깊이 1000 이상이고 하부옵션 전면 정렬 선택 시
            var parti_z_pos = 0;
            if (board_depth >= 1000 && parti_z_align_front == 1) {
              parti_z_pos = board_depth / 2 - 200; // 하부옵션 전면과 같은 라인
            }
            parti_ver_R_dup.position.set(parti_x_position, parti_center_y, parti_z_pos);
            parti_ver_R_dup.castShadow = true;
            scene.add(parti_ver_R_dup);
          }

          // 책상이 1개일 때 오른쪽 파티션
          if (num_desk == 1 && parti_ver_R_height > 0) {
            var board_top_y = frame_length + board_thickness;
            var parti_bottom_y;
            var parti_center_y;
            var parti_width = 800;
            
            switch (parti_ver_R_height) {
              case 460:
                parti_bottom_y = board_top_y;
                parti_center_y = parti_bottom_y + parti_ver_R_height / 2 + 15; // Y축 +15 이동 (위로)
                break;
              case 800:
                parti_bottom_y = board_top_y - 300; // 100 낮게 조정
                parti_center_y = parti_bottom_y + parti_ver_R_height / 2;
                break;
              case 1200:
              case 1400:
              case 1600:
              case 1800:
                parti_bottom_y = board_top_y - 700;
                parti_center_y = parti_bottom_y + parti_ver_R_height / 2;
                break;
              default:
                parti_bottom_y = board_top_y;
                parti_center_y = parti_bottom_y + parti_ver_R_height / 2;
            }
            
            var parti_x_position;
            if (vertical_length > 0 && shelf_num > 0) {
              var vertical_z = - (board_depth + frame_thickness + 5) / 2;
              var shelf_z_relative;
              if (shelf_direction == 0) {
                shelf_z_relative = - (shelf_depth - frame_thickness + 2) / 2;
              } else {
                shelf_z_relative = (shelf_depth - frame_thickness + 2) / 2;
              }
              var shelf_z_absolute = vertical_z + shelf_z_relative;
              var shelf_outer_edge_z = shelf_z_absolute - shelf_depth / 2;
              parti_x_position = desk_offset_x + board_width / 2 + 6;
            } else {
              parti_x_position = desk_offset_x + board_width / 2;
            }
            
            geometry = new THREE.BoxBufferGeometry(12, parti_ver_R_height, parti_width);
            var parti_ver_R_dup = new THREE.Mesh(geometry, parti_ver_R_material);
            // 파티션 Z 위치: 책상 깊이 1000 이상이고 하부옵션 전면 정렬 선택 시
            var parti_z_pos = 0;
            if (board_depth >= 1000 && parti_z_align_front == 1) {
              parti_z_pos = board_depth / 2 - 200; // 하부옵션 전면과 같은 라인
            }
            parti_ver_R_dup.position.set(parti_x_position, parti_center_y, parti_z_pos);
            parti_ver_R_dup.castShadow = true;
            scene.add(parti_ver_R_dup);
          }

          // 파티션 hol_B (전면 파티션)
          if (parti_hol_B_width > 0) {
            var board_top_y = frame_length + board_thickness; // 상판 높이
            var parti_hol_B_height = 800; // 고정 높이 800mm
            var parti_bottom_y = board_top_y - 200; // 상판 기준 200mm 아래에서 시작
            var parti_center_y = parti_bottom_y + parti_hol_B_height / 2 - 100; // 파티션 중심 높이 (아래로 100mm 이동)
            
            // 설치 위치 계산
            var parti_z_position;
            
            if (vertical_length == 0 || shelf_num == 0) {
              // 책상만 있을 경우: 책상 전면 바깥쪽으로 부착
              parti_z_position = -board_depth / 2 - 6; // 12mm 두께의 절반
            } else {
              // 선반이 있을 경우: 반대편 책상과 가장 멀리 떨어진 선반의 끝에 부착
              var vertical_z = - (board_depth + frame_thickness + 5) / 2;
              
              var shelf_z_relative;
              if (shelf_direction == 0) {
                shelf_z_relative = - (shelf_depth - frame_thickness + 2) / 2;
              } else {
                shelf_z_relative = (shelf_depth - frame_thickness + 2) / 2;
              }
              
              var shelf_z_absolute = vertical_z + shelf_z_relative;
              
              // 선반의 앞쪽 끝과 뒤쪽 끝 계산
              var shelf_front_edge; // 더 앞쪽 (더 작은 음수, Z=0에 가까움)
              var shelf_back_edge;  // 더 뒤쪽 (더 큰 음수, Z=0에서 멀음)
              
              if (shelf_direction == 0) {
                // OUT 방향: 선반이 뒤쪽으로 향함
                shelf_back_edge = shelf_z_absolute + shelf_depth / 2;  // 더 뒤쪽 (더 큰 음수)
                shelf_front_edge = shelf_z_absolute - shelf_depth / 2; // 더 앞쪽 (더 작은 음수)
              } else {
                // IN 방향: 선반이 앞쪽으로 향함
                shelf_front_edge = shelf_z_absolute + shelf_depth / 2;  // 더 앞쪽 (더 작은 음수)
                shelf_back_edge = shelf_z_absolute - shelf_depth / 2;  // 더 뒤쪽 (더 큰 음수)
              }
              
              // 맞은편 배치 선택 여부와 관계없이 항상 뒤쪽 끝 사용 (전면 파티션 위치 고정)
              shelf_farthest_edge = shelf_back_edge;
              
              parti_z_position = shelf_farthest_edge - 6; // 12mm 두께의 절반만큼 앞쪽으로
            }
            
            // 선반의 바깥방향(OUT) 선택 시 Z축으로 -200 이동
            if (vertical_length > 0 && shelf_num > 0 && shelf_direction == 0) {
              parti_z_position -= 200;
            }
            // 선반방향이 안쪽(IN)일 때는 원래 기본위치 유지 (추가 이동 없음)
            
            geometry = new THREE.BoxBufferGeometry(parti_hol_B_width, parti_hol_B_height, 12);
            var parti_hol_B_dup = new THREE.Mesh(geometry, parti_hol_B_material);
            parti_hol_B_dup.position.set(desk_offset_x, parti_center_y, parti_z_position);
            parti_hol_B_dup.castShadow = true;
            scene.add(parti_hol_B_dup);
          }
        }
        
        // 중첩위치 파티션: 책상 사이 중첩 위치에 배치
        if (num_desk > 1 && parti_ver_M_height > 0) {
          var board_top_y = frame_length + board_thickness;
          var parti_bottom_y;
          var parti_center_y;
          var parti_width = 800;
          
          // 높이에 따른 설치 위치 계산
          switch (parti_ver_M_height) {
            case 400:
              parti_bottom_y = board_top_y;
              parti_center_y = parti_bottom_y + parti_ver_M_height / 2;
              break;
            case 800:
              parti_bottom_y = board_top_y - 300; // 100 낮게 조정
              parti_center_y = parti_bottom_y + parti_ver_M_height / 2;
              break;
            case 1200:
            case 1400:
            case 1600:
            case 1800:
              parti_bottom_y = board_top_y - 700;
              parti_center_y = parti_bottom_y + parti_ver_M_height / 2;
              break;
            default:
              parti_bottom_y = board_top_y;
              parti_center_y = parti_bottom_y + parti_ver_M_height / 2;
          }
          
          // 각 책상 사이 중첩 위치에 파티션 배치
          for (var middle_idx = 0; middle_idx < num_desk - 1; middle_idx++) {
            // 두 책상 사이의 중첩 위치 계산
            // 첫 번째 책상의 오른쪽 끝과 두 번째 책상의 왼쪽 끝이 만나는 위치
            var desk1_offset_x = (board_width + 10) * (middle_idx - 0.5 * (num_desk - 1));
            var desk2_offset_x = (board_width + 10) * ((middle_idx + 1) - 0.5 * (num_desk - 1));
            
            // 첫 번째 책상의 오른쪽 끝: desk1_offset_x + board_width/2
            // 두 번째 책상의 왼쪽 끝: desk2_offset_x - board_width/2
            // 중첩 위치는 이 두 위치의 중간 (책상 사이 간격 10의 중간)
            var overlap_x = (desk1_offset_x + board_width / 2 + desk2_offset_x - board_width / 2) / 2;
            
            // 파티션 X 위치 계산: 선반이 있을 경우 선반의 제일 바깥쪽으로
            var parti_x_position;
            if (vertical_length > 0 && shelf_num > 0) {
              var vertical_z = - (board_depth + frame_thickness + 5) / 2;
              var shelf_z_relative;
              if (shelf_direction == 0) {
                shelf_z_relative = - (shelf_depth - frame_thickness + 2) / 2;
              } else {
                shelf_z_relative = (shelf_depth - frame_thickness + 2) / 2;
              }
              var shelf_z_absolute = vertical_z + shelf_z_relative;
              var shelf_outer_edge_z = shelf_z_absolute - shelf_depth / 2;
              parti_x_position = overlap_x + 6; // 중첩 위치에서 파티션 두께의 절반만큼 오른쪽
            } else {
              parti_x_position = overlap_x; // 중첩 위치에 정확히 배치
            }
            
            geometry = new THREE.BoxBufferGeometry(12, parti_ver_M_height, parti_width);
            var parti_middle = new THREE.Mesh(geometry, parti_ver_M_material);
            // 파티션 Z 위치: 책상 깊이 1000 이상이고 하부옵션 전면 정렬 선택 시
            var parti_z_pos = 0;
            if (board_depth >= 1000 && parti_z_align_front == 1) {
              parti_z_pos = board_depth / 2 - 200; // 하부옵션 전면과 같은 라인
            }
            parti_middle.position.set(parti_x_position, parti_center_y, parti_z_pos);
            parti_middle.castShadow = true;
            scene.add(parti_middle);
          }
        }
        
        
        // light
        var lights = [];
        var d = 4000; // 그림자 범위 확대 (기존 2048에서 4000으로 증가)
        lights[0] = new THREE.DirectionalLight(0xffffff, 0.3);
        lights[1] = new THREE.DirectionalLight(0xffffff, 0.3);
        lights[2] = new THREE.DirectionalLight(0xffffff, 0.3);
        lights[3] = new THREE.DirectionalLight(0xffffff, 0.3);
        lights[4] = new THREE.AmbientLight(0xffffff, 0.5);

        lights[0].castShadow = true;
        lights[0].shadow.camera.left = -d ;
        lights[0].shadow.camera.right = d ;
        lights[0].shadow.camera.top = d ;
        lights[0].shadow.camera.bottom = -d ;
        lights[0].shadow.camera.far = 10000;
        lights[0].shadow.mapSize.width = 4096; // 그림자 해상도 증가 (기존 2048에서 4096으로 증가)
        lights[0].shadow.mapSize.height = 4096; // 그림자 해상도 증가 (기존 2048에서 4096으로 증가)
        lights[0].shadow.bias = -0.0001;
        lights[0].position.set(-1000, 1000, 1000);

        lights[1].position.set(1000, 500, -1000);
        lights[2].position.set(-1000, 500, -1000);
        lights[3].position.set(1000, 500, 1000);

        scene.add(lights[0]);
        scene.add(lights[1]);
        scene.add(lights[2]);
        scene.add(lights[3]);
        scene.add(lights[4]);

        // Calculate price and generate product code
        var price_arr = calculatePrice();
        var total_price = price_arr[0] + price_arr[1];

        product_code_string = generateProductCode();

        var my_date = new Date();
        var day_of_month = my_date.getDate();
        my_date.setDate(day_of_month + 7);
        
        var dd = my_date.getDate();
        var mm = my_date.getMonth() + 1;  //January is 0!
        var yyyy = my_date.getFullYear();

        // write price and code into HTML
        var product_code_input = document.getElementById("product_code_input");
        if (product_code_input) {
          product_code_input.value = generateProductCode();
        } else {
          // fallback for old HTML structure
        var product_code_html = document.getElementsByClassName("ft_prd_code");
          if (product_code_html.length > 0) {
        product_code_html[0].innerHTML = generateProductCode();        
          }
        }        
        
        var price_html = document.getElementsByClassName("delivery_info price");
        price_html[0].innerHTML = price_arr[0].toLocaleString();
        price_html[1].innerHTML = price_arr[1].toLocaleString();

        price_html = document.getElementsByClassName("ft_total_price");
        price_html[0].innerHTML = total_price.toLocaleString();

        var delivery_date_html = document.getElementsByClassName("delivery_info");
        delivery_date_html[1].innerHTML = yyyy + "년 " + mm + "월 " + dd + "일";
        
        // 모든 메시에 아웃라인 추가
        addOutlinesToScene();
      }

      function onWindowResize() {
        container = document.getElementById('canvas');
        width = window.innerWidth;
        height = window.innerHeight;

        camera.aspect = width / height;
        camera.updateProjectionMatrix();

        renderer.setSize(width, height);

        render();
      }

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        render();
      }

      function render() {
        renderer.render(scene, camera);
      }
      
      function toggleRotation() {
        if (controls) {
          controls.autoRotate = !controls.autoRotate;
          updateRotationButton();
        }
      }
      
      function updateRotationButton() {
        var btn = document.getElementById('rotation-toggle-btn');
        if (btn && controls) {
          if (controls.autoRotate) {
            btn.innerHTML = '회전정지';
            btn.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
          } else {
            btn.innerHTML = '회전시작';
            btn.style.backgroundColor = 'rgba(0, 100, 0, 0.7)';
          }
        }
      }
      
      function save( blob, filename ) {
        link.href = URL.createObjectURL( blob );
        link.download = filename;
        link.click();
      }
      
      function saveString( text, filename ) {
        save( new Blob( [ text ], { type: 'text/plain' } ), filename );
      }
      
      function saveArrayBuffer( buffer, filename ) {
        save( new Blob( [ buffer ], { type: 'application/octet-stream' } ), filename );
      }
      
      function exportOBJ() {
        var exporter = new THREE.OBJExporter();
        var result = exporter.parse(desk);
        saveString(result, "f1desk_" + product_code_string + ".obj");
      }

      function exportSTL() {
        var exporter = new THREE.STLExporter();
        var result = exporter.parse(desk);
        saveString(result, "f1desk_" + product_code_string + ".stl");
      }

    </script>
</body>
</html>